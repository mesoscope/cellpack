<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>cellpack.autopack.Compartment &#8212; cellPack 1.0.8 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../../_static/classic.css?v=514cf933" />
    
    <script src="../../../_static/documentation_options.js?v=aec50437"></script>
    <script src="../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">cellPack 1.0.8 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../cellpack.html" >cellpack</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="../autopack.html" accesskey="U">cellpack.autopack</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">cellpack.autopack.Compartment</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for cellpack.autopack.Compartment</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1"># autoPACK Authors: Graham T. Johnson, Mostafa Al-Alusi, Ludovic Autin, Michel Sanner</span>
<span class="c1">#   Based on COFFEE Script developed by Graham Johnson between 2005 and 2010</span>
<span class="c1">#   with assistance from Mostafa Al-Alusi in 2009 and periodic input</span>
<span class="c1">#   from Arthur Olson&#39;s Molecular Graphics Lab</span>
<span class="c1">#</span>
<span class="c1"># Compartment.py Authors: Graham Johnson &amp; Michel Sanner with editing/enhancement from Ludovic Autin</span>
<span class="c1">#</span>
<span class="c1"># Translation to Python initiated March 1, 2010 by Michel Sanner with Graham Johnson</span>
<span class="c1">#</span>
<span class="c1"># Class restructuring and organization: Michel Sanner</span>
<span class="c1">#</span>
<span class="c1"># Copyright: Graham Johnson Â©2010</span>
<span class="c1">#</span>
<span class="c1"># This file &quot;Compartment.py&quot; is part of autoPACK, cellPACK.</span>
<span class="c1">#</span>
<span class="c1">#    autoPACK is free software: you can redistribute it and/or modify</span>
<span class="c1">#    it under the terms of the GNU General Public License as published by</span>
<span class="c1">#    the Free Software Foundation, either version 3 of the License, or</span>
<span class="c1">#    (at your option) any later version.</span>
<span class="c1">#</span>
<span class="c1">#    autoPACK is distributed in the hope that it will be useful,</span>
<span class="c1">#    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c1">#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c1">#    GNU General Public License for more details.</span>
<span class="c1">#</span>
<span class="c1">#    You should have received a copy of the GNU General Public License</span>
<span class="c1">#    along with autoPACK (See &quot;CopyingGNUGPL&quot; in the installation.</span>
<span class="c1">#    If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="c1">#</span>
<span class="c1">###############################################################################</span>
<span class="c1"># @author: Graham Johnson, Ludovic Autin, &amp; Michel Sanner</span>

<span class="c1"># Hybrid version merged from Graham&#39;s Sept 6, 2011 and Ludo&#39;s April 2012</span>
<span class="c1"># version on May 16, 2012, re-merged on July 5, 2012 with thesis versions</span>

<span class="c1"># Hybrid version merged from Graham&#39;s Sept 2011 and Ludo&#39;s April 2012 version on May 16, 2012</span>
<span class="c1"># Updated with Sept 16, 2011 thesis versions on July 5, 2012</span>

<span class="c1"># TODO: Describe Organelle class here at high level</span>

<span class="c1"># TODO: Graham and Ludovic implemented a 2D density function to obtain target numbers for</span>
<span class="c1">#   filling surfaces.  This should be formalized and named something other than molarity</span>
<span class="c1">#   or molarity should be converted to a 2D value behind the scenes.</span>
<span class="c1"># IDEA: We should offer the user an option to override molarity with a specific</span>
<span class="c1">#   number, e.g., &quot;I want to place 3 1xyz.pdb files in compartment A&quot; rather than</span>
<span class="c1">#   forcing them to calculate- &quot;I need to place 0.00071M of 1xyz.pdb to get 3 of them</span>
<span class="c1">#   in an compartment A of volume=V.&quot;</span>

<span class="c1"># IDEAS</span>

<span class="c1"># randomly select recipe and then randomly select free point in set of free</span>
<span class="c1"># points corresponding to this recipe would allow giving surface more</span>
<span class="c1"># chances to get filled</span>

<span class="c1"># NOTE changing smallest molecule radius changes grid spacing and invalidates</span>
<span class="c1">#      arrays saved to file</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">pickle</span>

<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">from</span> <span class="nn">time</span> <span class="kn">import</span> <span class="n">time</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">from</span> <span class="nn">trimesh.voxel</span> <span class="kn">import</span> <span class="n">creation</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">spatial</span>

<span class="kn">import</span> <span class="nn">cellpack.autopack</span> <span class="k">as</span> <span class="nn">autopack</span>
<span class="kn">from</span> <span class="nn">cellpack.autopack</span> <span class="kn">import</span> <span class="n">transformation</span> <span class="k">as</span> <span class="n">tr</span><span class="p">,</span> <span class="n">binvox_rw</span>
<span class="kn">from</span> <span class="nn">cellpack.autopack.BaseGrid</span> <span class="kn">import</span> <span class="n">gridPoint</span>
<span class="kn">from</span> <span class="nn">cellpack.autopack.interface_objects.packed_objects</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">PackedObject</span><span class="p">,</span>
    <span class="n">PackedObjects</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">.Recipe</span> <span class="kn">import</span> <span class="n">Recipe</span>
<span class="kn">from</span> <span class="nn">.ray</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">makeMarchingCube</span><span class="p">,</span>
    <span class="n">vcross</span><span class="p">,</span>
    <span class="n">vlen</span><span class="p">,</span>
    <span class="n">findPointsCenter</span><span class="p">,</span>
    <span class="n">f_ray_intersect_polyhedron</span><span class="p">,</span>
    <span class="n">vdiff</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">helper</span> <span class="o">=</span> <span class="n">autopack</span><span class="o">.</span><span class="n">helper</span>
<span class="n">AFDIR</span> <span class="o">=</span> <span class="n">autopack</span><span class="o">.</span><span class="n">__path__</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>


<div class="viewcode-block" id="CompartmentList">
<a class="viewcode-back" href="../../../cellpack.autopack.html#cellpack.autopack.Compartment.CompartmentList">[docs]</a>
<span class="k">class</span> <span class="nc">CompartmentList</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The CompartmentList class</span>
<span class="sd">    ==========================</span>
<span class="sd">    Handle a list of compartments.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="CompartmentList.add_compartment">
<a class="viewcode-back" href="../../../cellpack.autopack.html#cellpack.autopack.Compartment.CompartmentList.add_compartment">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">add_compartment</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">compartment</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;add a new compartment to the list&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">compartment</span><span class="o">.</span><span class="n">parent</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">compartment</span><span class="p">,</span> <span class="n">Compartment</span><span class="p">)</span>
        <span class="n">compartment</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span></div>


    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s2">&quot;compartment&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">propagate</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># list of compartments inside this compartment</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compartments</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># point to parent compartment or Environment</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="kc">None</span></div>



<div class="viewcode-block" id="Compartment">
<a class="viewcode-back" href="../../../cellpack.autopack.html#cellpack.autopack.Compartment.Compartment">[docs]</a>
<span class="k">class</span> <span class="nc">Compartment</span><span class="p">(</span><span class="n">CompartmentList</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The Compartment class</span>
<span class="sd">    ==========================</span>
<span class="sd">    This class represents a sub volume delimited by a polyhedral</span>
<span class="sd">    surface. Compartment can be nested</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">object_info</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">center</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>  <span class="c1"># calculated centroid of the mesh</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">position</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>  <span class="c1"># where the object is placed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">faces</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vnormals</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fnormals</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gname</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ref_obj</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meshType</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">representations</span> <span class="o">=</span> <span class="n">object_info</span><span class="p">[</span><span class="s2">&quot;representations&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">packed_objects</span> <span class="o">=</span> <span class="n">PackedObjects</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">representations</span><span class="o">.</span><span class="n">has_mesh</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">representations</span><span class="o">.</span><span class="n">get_mesh_name</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">meshType</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">representations</span><span class="o">.</span><span class="n">get_mesh_format</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">representations</span><span class="o">.</span><span class="n">get_mesh_path</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="n">autopack</span><span class="o">.</span><span class="n">fixOnePath</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stype</span> <span class="o">=</span> <span class="s2">&quot;mesh&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">radius</span> <span class="o">=</span> <span class="n">object_info</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;radius&quot;</span><span class="p">,</span> <span class="mf">200.0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">height</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">axis</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">area</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rbnode</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ghost</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bb</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">diag</span> <span class="o">=</span> <span class="mf">9999.9</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ghost</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">encapsulating_radius</span> <span class="o">=</span> <span class="n">object_info</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;radius&quot;</span><span class="p">,</span> <span class="mf">200.0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">object_info</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;color&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">checkinside</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">innerRecipe</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surfaceRecipe</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surfaceVolume</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interiorVolume</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rapid_model</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># list of grid point indices inside organelle</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">insidePoints</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># list of grid point indices on compartment surface</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surfacePoints</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surfacePointsNormals</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># will be point index:normal</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">number</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># will be set to an integer when this compartment</span>
        <span class="c1"># is added to a Environment. Positivefor surface pts</span>
        <span class="c1"># negative for interior points</span>
        <span class="c1"># self.parent = None</span>
        <span class="c1"># list of ( (x,y,z), rotation, ingredient) triplet generated by fill</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">overwriteSurfacePts</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1"># do we discretize surface point per edges</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">highresVertices</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># if a highres vertices is provided this give the surface point,</span>
        <span class="c1"># not the one provides</span>
        <span class="c1"># to compute inside points.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_sphere</span> <span class="o">=</span> <span class="n">object_info</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;single_sphere&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">object_info</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_box</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;bounding_box&quot;</span> <span class="ow">in</span> <span class="n">object_info</span> <span class="ow">and</span> <span class="n">object_info</span><span class="p">[</span><span class="s2">&quot;bounding_box&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bounding_box</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">object_info</span><span class="p">[</span><span class="s2">&quot;bounding_box&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="s2">&quot;bounding_box&quot;</span> <span class="ow">in</span> <span class="n">object_info</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_orthogonal_bounding_box</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="s2">&quot;bounding_box&quot;</span> <span class="ow">in</span> <span class="n">object_info</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">grid_type</span> <span class="o">=</span> <span class="s2">&quot;regular&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid_distances</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># signed closest distance for each point</span>
        <span class="c1"># TODO Add openVDB</span>
        <span class="c1"># if self.filename is None:</span>
        <span class="c1">#     autopack.helper.saveDejaVuMesh(</span>
        <span class="c1">#         autopack.cache_geoms + os.sep + self.name, self.vertices, self.faces</span>
        <span class="c1">#     )</span>
        <span class="c1">#     self.filename = autopack.cache_geoms + os.sep + self.name</span>
        <span class="c1">#     self.ref_obj = self.name</span>

<div class="viewcode-block" id="Compartment.reset">
<a class="viewcode-back" href="../../../cellpack.autopack.html#cellpack.autopack.Compartment.Compartment.reset">[docs]</a>
    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;reset the inner compartment data, surface and inner points&quot;&quot;&quot;</span>
        <span class="c1"># list of grid point indices inside compartment</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">insidePoints</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># list of grid point indices on compartment surface</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surfacePoints</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surfacePointsNormals</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># will be point index:normal</span></div>


<div class="viewcode-block" id="Compartment.transformMesh">
<a class="viewcode-back" href="../../../cellpack.autopack.html#cellpack.autopack.Compartment.Compartment.transformMesh">[docs]</a>
    <span class="k">def</span> <span class="nf">transformMesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">rotation</span><span class="p">):</span>
        <span class="n">rot</span> <span class="o">=</span> <span class="n">tr</span><span class="o">.</span><span class="n">matrix_from_quaternion</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
        <span class="n">m</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">rot</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">m</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">pos</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span> <span class="o">=</span> <span class="n">autopack</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">ApplyMatrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>
        <span class="c1"># Recompute the normal ?</span>
        <span class="c1"># self.vnormals = autopack.helper.ApplyMatrix(self.vnormals,m.transpose())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vnormals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getVertexNormals</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span>
        <span class="c1"># self.vnormals = autopack.helper.normal_array(self.vertices,numpy.array(self.faces))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">center</span> <span class="o">=</span> <span class="n">pos</span></div>


<div class="viewcode-block" id="Compartment.buildSphere">
<a class="viewcode-back" href="../../../cellpack.autopack.html#cellpack.autopack.Compartment.Compartment.buildSphere">[docs]</a>
    <span class="k">def</span> <span class="nf">buildSphere</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mesh_store</span><span class="p">):</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="n">mesh_store</span><span class="o">.</span><span class="n">create_sphere</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gname</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">faces</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vnormals</span> <span class="o">=</span> <span class="n">mesh_store</span><span class="o">.</span><span class="n">decompose_mesh</span><span class="p">(</span>
            <span class="n">geom</span><span class="p">,</span> <span class="n">edit</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">tri</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Compartment.buildMesh">
<a class="viewcode-back" href="../../../cellpack.autopack.html#cellpack.autopack.Compartment.Compartment.buildMesh">[docs]</a>
    <span class="k">def</span> <span class="nf">buildMesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">mesh_store</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a polygon mesh object from a dictionary verts,faces,normals</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">geom</span><span class="p">,</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">faces</span><span class="p">,</span> <span class="n">vnormals</span> <span class="o">=</span> <span class="n">mesh_store</span><span class="o">.</span><span class="n">build_mesh</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gname</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span> <span class="o">=</span> <span class="n">vertices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">faces</span> <span class="o">=</span> <span class="n">faces</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vnormals</span> <span class="o">=</span> <span class="n">vnormals</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="n">autopack</span><span class="o">.</span><span class="n">cache_geoms</span> <span class="o">+</span> <span class="n">os</span><span class="o">.</span><span class="n">sep</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">gname</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ref_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">return</span> <span class="n">geom</span></div>


    <span class="k">def</span> <span class="nf">_get_volume</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mesh_store</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_sphere</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="o">**</span><span class="mi">3</span> <span class="o">/</span> <span class="mi">3</span>

<div class="viewcode-block" id="Compartment.initialize_shape">
<a class="viewcode-back" href="../../../cellpack.autopack.html#cellpack.autopack.Compartment.Compartment.initialize_shape">[docs]</a>
    <span class="k">def</span> <span class="nf">initialize_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mesh_store</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_sphere</span><span class="p">:</span>
            <span class="c1"># one sphere, geom is a dictionary</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">buildSphere</span><span class="p">(</span><span class="n">mesh_store</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;mesh&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">faces</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vnormals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getMesh</span><span class="p">(</span><span class="n">mesh_store</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ref_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meshType</span> <span class="o">==</span> <span class="s2">&quot;raw&quot;</span><span class="p">:</span>
            <span class="c1"># need to build the mesh from v,f,n</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">buildMesh</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meshFile</span><span class="p">,</span> <span class="n">mesh_store</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;mb&quot;</span><span class="p">:</span>
            <span class="c1"># one sphere, geom is a dictionary</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">buildSphere</span><span class="p">(</span><span class="n">mesh_store</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">):</span>
            <span class="c1"># can be dae/fbx file, object name that have to be in the scene or dejaVu indexedpolygon file</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getBoundingBox</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_sphere</span><span class="p">:</span>
                <span class="n">center</span><span class="p">,</span> <span class="n">radius</span> <span class="o">=</span> <span class="n">mesh_store</span><span class="o">.</span><span class="n">get_nsphere</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gname</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">center</span> <span class="o">=</span> <span class="n">center</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">encapsulating_radius</span> <span class="o">=</span> <span class="n">radius</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">radius</span> <span class="o">=</span> <span class="n">mesh_store</span><span class="o">.</span><span class="n">get_smallest_radius</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gname</span><span class="p">,</span> <span class="n">center</span><span class="p">)</span></div>


<div class="viewcode-block" id="Compartment.store_packed_object">
<a class="viewcode-back" href="../../../cellpack.autopack.html#cellpack.autopack.Compartment.Compartment.store_packed_object">[docs]</a>
    <span class="k">def</span> <span class="nf">store_packed_object</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">env</span><span class="p">):</span>
        <span class="n">packed_object</span> <span class="o">=</span> <span class="n">PackedObject</span><span class="p">(</span>
            <span class="n">position</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
            <span class="n">rotation</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span>
            <span class="n">radius</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="p">,</span>
            <span class="n">pt_index</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">ingredient</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">is_compartment</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">env</span><span class="o">.</span><span class="n">packed_objects</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">packed_object</span><span class="p">)</span></div>


<div class="viewcode-block" id="Compartment.setGeomFaces">
<a class="viewcode-back" href="../../../cellpack.autopack.html#cellpack.autopack.Compartment.Compartment.setGeomFaces">[docs]</a>
    <span class="k">def</span> <span class="nf">setGeomFaces</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tris</span><span class="p">,</span> <span class="n">face</span><span class="p">):</span>
        <span class="c1"># have to add vertices one by one since they are not in order</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">face</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">face</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">face</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">face</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">face</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">face</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">face</span><span class="p">:</span>
            <span class="n">tris</span><span class="o">.</span><span class="n">addVertex</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">tris</span><span class="o">.</span><span class="n">closePrimitive</span><span class="p">()</span></div>


<div class="viewcode-block" id="Compartment.create_rbnode">
<a class="viewcode-back" href="../../../cellpack.autopack.html#cellpack.autopack.Compartment.Compartment.create_rbnode">[docs]</a>
    <span class="k">def</span> <span class="nf">create_rbnode</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Sphere</span>
        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="Compartment.get_rb_model">
<a class="viewcode-back" href="../../../cellpack.autopack.html#cellpack.autopack.Compartment.Compartment.get_rb_model">[docs]</a>
    <span class="k">def</span> <span class="nf">get_rb_model</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rbnode</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rbnode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_rbnode</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rbnode</span></div>


<div class="viewcode-block" id="Compartment.getMesh">
<a class="viewcode-back" href="../../../cellpack.autopack.html#cellpack.autopack.Compartment.Compartment.getMesh">[docs]</a>
    <span class="k">def</span> <span class="nf">getMesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mesh_store</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieve the compartment 3d representation from the given filename</span>

<span class="sd">        @type  filename: string</span>
<span class="sd">        @param filename: the name of the input file</span>
<span class="sd">        @type  rep: string</span>
<span class="sd">        @param rep: the name of the input file for the representation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">geometry</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">gname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gname</span>
        <span class="n">geometry</span> <span class="o">=</span> <span class="n">mesh_store</span><span class="o">.</span><span class="n">get_mesh</span><span class="p">(</span><span class="n">gname</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">geometry</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">ghost</span><span class="p">:</span>
            <span class="n">faces</span><span class="p">,</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">vnormals</span> <span class="o">=</span> <span class="n">mesh_store</span><span class="o">.</span><span class="n">decompose_mesh</span><span class="p">(</span>
                <span class="n">geometry</span><span class="p">,</span> <span class="n">edit</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">tri</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">faces</span><span class="p">,</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">vnormals</span>
        <span class="k">return</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span></div>


<div class="viewcode-block" id="Compartment.setMesh">
<a class="viewcode-back" href="../../../cellpack.autopack.html#cellpack.autopack.Compartment.Compartment.setMesh">[docs]</a>
    <span class="k">def</span> <span class="nf">setMesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vertices</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">faces</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vnormals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the 3d mesh from the given filename or the given mesh data (v,f,n)</span>

<span class="sd">        @type  filename: string</span>
<span class="sd">        @param filename: the name of the input file</span>
<span class="sd">        @type  vertices: array</span>
<span class="sd">        @param vertices: mesh vertices or None</span>
<span class="sd">        @type  faces: array</span>
<span class="sd">        @param faces: mesh faces or None</span>
<span class="sd">        @type  vnormals: array</span>
<span class="sd">        @param vnormals: mesh vnormals or None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">vertices</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">filename</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">faces</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vnormals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getMesh</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span> <span class="o">=</span> <span class="n">vertices</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">faces</span> <span class="o">=</span> <span class="n">faces</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vnormals</span> <span class="o">=</span> <span class="n">vnormals</span>
        <span class="k">if</span> <span class="s2">&quot;fnormals&quot;</span> <span class="ow">in</span> <span class="n">kw</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fnormals</span> <span class="o">=</span> <span class="n">kw</span><span class="p">[</span><span class="s2">&quot;fnormals&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ref_obj</span> <span class="o">=</span> <span class="n">filename</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getBoundingBox</span><span class="p">()</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="s2">&quot;f&quot;</span><span class="p">)</span>
        <span class="n">length</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">v</span> <span class="o">*</span> <span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">encapsulating_radius</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">length</span><span class="p">)</span></div>


<div class="viewcode-block" id="Compartment.saveGridToFile">
<a class="viewcode-back" href="../../../cellpack.autopack.html#cellpack.autopack.Compartment.Compartment.saveGridToFile">[docs]</a>
    <span class="k">def</span> <span class="nf">saveGridToFile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Save insidePoints and surfacePoints to file&quot;&quot;&quot;</span>
        <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">insidePoints</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
        <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surfacePoints</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
        <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surfacePointsNormals</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
        <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surfacePointsCoords</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span></div>


<div class="viewcode-block" id="Compartment.readGridFromFile">
<a class="viewcode-back" href="../../../cellpack.autopack.html#cellpack.autopack.Compartment.Compartment.readGridFromFile">[docs]</a>
    <span class="k">def</span> <span class="nf">readGridFromFile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;read insidePoints and surfacePoints from file&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">insidePoints</span> <span class="o">=</span> <span class="n">insidePoints</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surfacePoints</span> <span class="o">=</span> <span class="n">surfacePoints</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surfacePointsNormals</span> <span class="o">=</span> <span class="n">surfacePointsNormals</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surfacePointsCoords</span> <span class="o">=</span> <span class="n">surfacePointsCoords</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">surfacePoints</span><span class="p">,</span>
            <span class="n">insidePoints</span><span class="p">,</span>
            <span class="n">surfacePointsNormals</span><span class="p">,</span>
            <span class="n">surfacePointsCoords</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Compartment.setNumber">
<a class="viewcode-back" href="../../../cellpack.autopack.html#cellpack.autopack.Compartment.Compartment.setNumber">[docs]</a>
    <span class="k">def</span> <span class="nf">setNumber</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;set compartment uniq id&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">number</span> <span class="o">=</span> <span class="n">num</span></div>


<div class="viewcode-block" id="Compartment.setInnerRecipe">
<a class="viewcode-back" href="../../../cellpack.autopack.html#cellpack.autopack.Compartment.Compartment.setInnerRecipe">[docs]</a>
    <span class="k">def</span> <span class="nf">setInnerRecipe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">recipe</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;set the inner recipe that define the ingredient to pack inside&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">number</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">recipe</span><span class="p">,</span> <span class="n">Recipe</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">innerRecipe</span> <span class="o">=</span> <span class="n">recipe</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">innerRecipe</span><span class="o">.</span><span class="n">number</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number</span>
        <span class="n">recipe</span><span class="o">.</span><span class="n">compartment</span> <span class="o">=</span> <span class="bp">self</span>  <span class="c1"># weakref.ref(self)</span>
        <span class="k">for</span> <span class="n">ingr</span> <span class="ow">in</span> <span class="n">recipe</span><span class="o">.</span><span class="n">ingredients</span><span class="p">:</span>
            <span class="n">ingr</span><span class="o">.</span><span class="n">compartment_id</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">number</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">ingr</span><span class="p">,</span> <span class="s2">&quot;compMask&quot;</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">ingr</span><span class="o">.</span><span class="n">compMask</span><span class="p">:</span>
                    <span class="n">ingr</span><span class="o">.</span><span class="n">compMask</span> <span class="o">=</span> <span class="p">[</span><span class="n">ingr</span><span class="o">.</span><span class="n">compartment_id</span><span class="p">]</span></div>


<div class="viewcode-block" id="Compartment.setSurfaceRecipe">
<a class="viewcode-back" href="../../../cellpack.autopack.html#cellpack.autopack.Compartment.Compartment.setSurfaceRecipe">[docs]</a>
    <span class="k">def</span> <span class="nf">setSurfaceRecipe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">recipe</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;set the inner recipe that define the ingredient to pack at the surface&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">number</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">recipe</span><span class="p">,</span> <span class="n">Recipe</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surfaceRecipe</span> <span class="o">=</span> <span class="n">recipe</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surfaceRecipe</span><span class="o">.</span><span class="n">number</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number</span>
        <span class="n">recipe</span><span class="o">.</span><span class="n">compartment</span> <span class="o">=</span> <span class="bp">self</span>  <span class="c1"># weakref.ref(self)</span>
        <span class="k">for</span> <span class="n">ingr</span> <span class="ow">in</span> <span class="n">recipe</span><span class="o">.</span><span class="n">ingredients</span><span class="p">:</span>
            <span class="n">ingr</span><span class="o">.</span><span class="n">compartment_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number</span></div>


<div class="viewcode-block" id="Compartment.getCenter">
<a class="viewcode-back" href="../../../cellpack.autopack.html#cellpack.autopack.Compartment.Compartment.getCenter">[docs]</a>
    <span class="k">def</span> <span class="nf">getCenter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;get the center of the mesh (vertices barycenter)&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">center</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>  <span class="c1"># self.allAtoms.coords</span>
            <span class="n">center</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1.0</span><span class="p">)</span>
            <span class="n">center</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">center</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                <span class="n">center</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">center</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">4</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">center</span> <span class="o">=</span> <span class="n">center</span></div>


<div class="viewcode-block" id="Compartment.getRadius">
<a class="viewcode-back" href="../../../cellpack.autopack.html#cellpack.autopack.Compartment.Compartment.getRadius">[docs]</a>
    <span class="k">def</span> <span class="nf">getRadius</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;get the radius as the distance between vertices center and bottom left bounding box&quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">math</span>

        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">center</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">bb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">d</span> <span class="o">*</span> <span class="n">d</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">s</span><span class="p">)</span></div>


<div class="viewcode-block" id="Compartment.getBoundingBox">
<a class="viewcode-back" href="../../../cellpack.autopack.html#cellpack.autopack.Compartment.Compartment.getBoundingBox">[docs]</a>
    <span class="k">def</span> <span class="nf">getBoundingBox</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;get the bounding box&quot;&quot;&quot;</span>
        <span class="n">mini</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">maxi</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">xl</span><span class="p">,</span> <span class="n">yl</span><span class="p">,</span> <span class="n">zl</span> <span class="o">=</span> <span class="n">mini</span>
        <span class="n">xr</span><span class="p">,</span> <span class="n">yr</span><span class="p">,</span> <span class="n">zr</span> <span class="o">=</span> <span class="n">maxi</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">diag</span> <span class="o">=</span> <span class="n">vlen</span><span class="p">(</span><span class="n">vdiff</span><span class="p">((</span><span class="n">xr</span><span class="p">,</span> <span class="n">yr</span><span class="p">,</span> <span class="n">zr</span><span class="p">),</span> <span class="p">(</span><span class="n">xl</span><span class="p">,</span> <span class="n">yl</span><span class="p">,</span> <span class="n">zl</span><span class="p">)))</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">mini</span><span class="p">,</span> <span class="n">maxi</span><span class="p">)</span></div>


<div class="viewcode-block" id="Compartment.getSizeXYZ">
<a class="viewcode-back" href="../../../cellpack.autopack.html#cellpack.autopack.Compartment.Compartment.getSizeXYZ">[docs]</a>
    <span class="k">def</span> <span class="nf">getSizeXYZ</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;get the size per axe&quot;&quot;&quot;</span>
        <span class="n">sizexyz</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="n">sizexyz</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bb</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">bb</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">sizexyz</span></div>


<div class="viewcode-block" id="Compartment.checkPointInsideBB">
<a class="viewcode-back" href="../../../cellpack.autopack.html#cellpack.autopack.Compartment.Compartment.checkPointInsideBB">[docs]</a>
    <span class="k">def</span> <span class="nf">checkPointInsideBB</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pt3d</span><span class="p">,</span> <span class="n">dist</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;check if the given 3d coordinate is inside the compartment bounding box&quot;&quot;&quot;</span>
        <span class="n">origin</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bb</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">E</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bb</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">P</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pt3d</span><span class="p">)</span>

        <span class="c1"># a point is inside is  &lt; min and &gt; maxi etc..</span>
        <span class="n">test1</span> <span class="o">=</span> <span class="n">P</span> <span class="o">&lt;</span> <span class="n">origin</span>
        <span class="n">test2</span> <span class="o">=</span> <span class="n">P</span> <span class="o">&gt;</span> <span class="n">E</span>
        <span class="k">if</span> <span class="kc">True</span> <span class="ow">in</span> <span class="n">test1</span> <span class="ow">or</span> <span class="kc">True</span> <span class="ow">in</span> <span class="n">test2</span><span class="p">:</span>
            <span class="c1"># outside</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">dist</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">d1</span> <span class="o">=</span> <span class="n">P</span> <span class="o">-</span> <span class="n">origin</span>
                <span class="n">s1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">d1</span> <span class="o">*</span> <span class="n">d1</span><span class="p">)</span>
                <span class="n">d2</span> <span class="o">=</span> <span class="n">E</span> <span class="o">-</span> <span class="n">P</span>
                <span class="n">s2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">d2</span> <span class="o">*</span> <span class="n">d2</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">s1</span> <span class="o">&lt;=</span> <span class="n">dist</span> <span class="ow">or</span> <span class="n">s2</span> <span class="o">&lt;=</span> <span class="n">dist</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
            <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="Compartment.inBox">
<a class="viewcode-back" href="../../../cellpack.autopack.html#cellpack.autopack.Compartment.Compartment.inBox">[docs]</a>
    <span class="k">def</span> <span class="nf">inBox</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">box</span><span class="p">,</span> <span class="n">spacing</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        check if bounding box of this compartment fits inside the give box</span>
<span class="sd">        returns true or false and the extended bounding box if this compartment</span>
<span class="sd">        did not fit</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ghost</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">None</span>
        <span class="n">bb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bb</span>

        <span class="n">xm</span><span class="p">,</span> <span class="n">ym</span><span class="p">,</span> <span class="n">zm</span> <span class="o">=</span> <span class="n">box</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">xM</span><span class="p">,</span> <span class="n">yM</span><span class="p">,</span> <span class="n">zM</span> <span class="o">=</span> <span class="n">box</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># padding 50 shows problem</span>
        <span class="n">padding</span> <span class="o">=</span> <span class="n">spacing</span> <span class="o">/</span> <span class="mi">2</span>

        <span class="n">newBB</span> <span class="o">=</span> <span class="p">[</span><span class="n">box</span><span class="p">[</span><span class="mi">0</span><span class="p">][:],</span> <span class="n">box</span><span class="p">[</span><span class="mi">1</span><span class="p">][:]]</span>
        <span class="n">fits</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">bb</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="n">newBB</span>

        <span class="k">if</span> <span class="n">xm</span> <span class="o">&gt;</span> <span class="n">bb</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">padding</span><span class="p">:</span>
            <span class="n">newBB</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">bb</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">padding</span>
            <span class="n">fits</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">ym</span> <span class="o">&gt;</span> <span class="n">bb</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">padding</span><span class="p">:</span>
            <span class="n">newBB</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">bb</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">padding</span>
            <span class="n">fits</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">zm</span> <span class="o">&gt;</span> <span class="n">bb</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">padding</span><span class="p">:</span>
            <span class="n">newBB</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">bb</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">padding</span>
            <span class="n">fits</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">xM</span> <span class="o">&lt;</span> <span class="n">bb</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">padding</span><span class="p">:</span>
            <span class="n">newBB</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">bb</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">padding</span>
            <span class="n">fits</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">yM</span> <span class="o">&lt;</span> <span class="n">bb</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">padding</span><span class="p">:</span>
            <span class="n">newBB</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">bb</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">padding</span>
            <span class="n">fits</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">zM</span> <span class="o">&lt;</span> <span class="n">bb</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">padding</span><span class="p">:</span>
            <span class="n">newBB</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">bb</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">padding</span>
            <span class="n">fits</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="n">fits</span><span class="p">,</span> <span class="n">newBB</span></div>


<div class="viewcode-block" id="Compartment.inGrid">
<a class="viewcode-back" href="../../../cellpack.autopack.html#cellpack.autopack.Compartment.Compartment.inGrid">[docs]</a>
    <span class="k">def</span> <span class="nf">inGrid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="n">fillBB</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        check if bounding box of this compartment fits inside the give box</span>
<span class="sd">        returns true or false and the extended bounding box if this compartment</span>
<span class="sd">        did not fit</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mini</span><span class="p">,</span> <span class="n">maxi</span> <span class="o">=</span> <span class="n">fillBB</span>
        <span class="n">mx</span><span class="p">,</span> <span class="n">my</span><span class="p">,</span> <span class="n">mz</span> <span class="o">=</span> <span class="n">mini</span>
        <span class="n">Mx</span><span class="p">,</span> <span class="n">My</span><span class="p">,</span> <span class="n">Mz</span> <span class="o">=</span> <span class="n">maxi</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">point</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="n">mx</span> <span class="ow">and</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">Mx</span> <span class="ow">and</span> <span class="n">y</span> <span class="o">&gt;=</span> <span class="n">my</span> <span class="ow">and</span> <span class="n">y</span> <span class="o">&lt;=</span> <span class="n">My</span> <span class="ow">and</span> <span class="n">z</span> <span class="o">&gt;=</span> <span class="n">mz</span> <span class="ow">and</span> <span class="n">z</span> <span class="o">&lt;=</span> <span class="n">Mz</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="Compartment.get_normal_for_point">
<a class="viewcode-back" href="../../../cellpack.autopack.html#cellpack.autopack.Compartment.Compartment.get_normal_for_point">[docs]</a>
    <span class="k">def</span> <span class="nf">get_normal_for_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pt</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">mesh_store</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">pt</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">surfacePointsNormals</span><span class="p">:</span>
            <span class="n">normal</span> <span class="o">=</span> <span class="n">mesh_store</span><span class="o">.</span><span class="n">get_normal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gname</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">surfacePointsNormals</span><span class="p">[</span><span class="n">pt</span><span class="p">]</span> <span class="o">=</span> <span class="n">normal</span>
            <span class="k">return</span> <span class="n">normal</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">surfacePointsNormals</span><span class="p">[</span><span class="n">pt</span><span class="p">]</span></div>


<div class="viewcode-block" id="Compartment.getMinMaxProteinSize">
<a class="viewcode-back" href="../../../cellpack.autopack.html#cellpack.autopack.Compartment.Compartment.getMinMaxProteinSize">[docs]</a>
    <span class="k">def</span> <span class="nf">getMinMaxProteinSize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;retrieve minimum and maximum ingredient size for inner and surface recipe ingredients&quot;&quot;&quot;</span>
        <span class="c1"># for compartment in self.compartments:</span>
        <span class="c1">#    mini, maxi = compartment.getSmallestProteinSize(size)</span>
        <span class="n">mini1</span> <span class="o">=</span> <span class="n">mini2</span> <span class="o">=</span> <span class="mf">9999999.0</span>
        <span class="n">maxi1</span> <span class="o">=</span> <span class="n">maxi2</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">surfaceRecipe</span><span class="p">:</span>
            <span class="n">mini1</span><span class="p">,</span> <span class="n">maxi1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surfaceRecipe</span><span class="o">.</span><span class="n">getMinMaxProteinSize</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">innerRecipe</span><span class="p">:</span>
            <span class="n">mini2</span><span class="p">,</span> <span class="n">maxi2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">innerRecipe</span><span class="o">.</span><span class="n">getMinMaxProteinSize</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">mini1</span><span class="p">,</span> <span class="n">mini2</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">maxi1</span><span class="p">,</span> <span class="n">maxi2</span><span class="p">)</span></div>


<div class="viewcode-block" id="Compartment.getVertexNormals">
<a class="viewcode-back" href="../../../cellpack.autopack.html#cellpack.autopack.Compartment.Compartment.getVertexNormals">[docs]</a>
    <span class="k">def</span> <span class="nf">getVertexNormals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">faces</span><span class="p">):</span>
        <span class="n">vnormals</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[:]</span>
        <span class="n">face</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
        <span class="n">v</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">faces</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                <span class="n">face</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">face</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">face</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">face</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">face</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
            <span class="n">normal</span> <span class="o">=</span> <span class="n">vcross</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">vlen</span><span class="p">(</span><span class="n">normal</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="n">n1</span> <span class="o">=</span> <span class="mf">1.0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">n1</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">n</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                <span class="n">vnormals</span><span class="p">[</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">normal</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n1</span><span class="p">,</span>
                    <span class="n">normal</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">n1</span><span class="p">,</span>
                    <span class="n">normal</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">n1</span><span class="p">,</span>
                <span class="p">]</span>
        <span class="k">return</span> <span class="n">vnormals</span>  <span class="c1"># areas added by Graham</span></div>


<div class="viewcode-block" id="Compartment.getFaceNormals">
<a class="viewcode-back" href="../../../cellpack.autopack.html#cellpack.autopack.Compartment.Compartment.getFaceNormals">[docs]</a>
    <span class="k">def</span> <span class="nf">getFaceNormals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">faces</span><span class="p">,</span> <span class="n">fillBB</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;compute the face normal of the compartment mesh&quot;&quot;&quot;</span>
        <span class="n">normals</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">areas</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># added by Graham</span>
        <span class="n">face</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
        <span class="n">v</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">faces</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                <span class="n">face</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">face</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">face</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">face</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">face</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
            <span class="n">normal</span> <span class="o">=</span> <span class="n">vcross</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">vlen</span><span class="p">(</span><span class="n">normal</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="n">n1</span> <span class="o">=</span> <span class="mf">1.0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">n1</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">n</span>
            <span class="n">normals</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">normal</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n1</span><span class="p">,</span> <span class="n">normal</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">n1</span><span class="p">,</span> <span class="n">normal</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">n1</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">fillBB</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">inGrid</span><span class="p">(</span><span class="n">vertices</span><span class="p">[</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">fillBB</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">inGrid</span><span class="p">(</span><span class="n">vertices</span><span class="p">[</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">fillBB</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">inGrid</span><span class="p">(</span><span class="n">vertices</span><span class="p">[</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">fillBB</span><span class="p">)</span>
                <span class="p">):</span>
                    <span class="n">areas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">vlen</span><span class="p">(</span><span class="n">normal</span><span class="p">))</span>  <span class="c1"># added by Graham</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">area</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">areas</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">normals</span><span class="p">,</span> <span class="n">areas</span>  <span class="c1"># areas added by Graham</span></div>


<div class="viewcode-block" id="Compartment.getInterpolatedNormal">
<a class="viewcode-back" href="../../../cellpack.autopack.html#cellpack.autopack.Compartment.Compartment.getInterpolatedNormal">[docs]</a>
    <span class="k">def</span> <span class="nf">getInterpolatedNormal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pt</span><span class="p">,</span> <span class="n">tri</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;compute an interpolated normal for te given triangle at the given point&quot;&quot;&quot;</span>
        <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="n">v3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">faces</span><span class="p">[</span><span class="n">tri</span><span class="p">]</span>
        <span class="n">verts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span>
        <span class="n">d1</span> <span class="o">=</span> <span class="n">vlen</span><span class="p">(</span><span class="n">vdiff</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">verts</span><span class="p">[</span><span class="n">v1</span><span class="p">]))</span>
        <span class="n">d2</span> <span class="o">=</span> <span class="n">vlen</span><span class="p">(</span><span class="n">vdiff</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">verts</span><span class="p">[</span><span class="n">v2</span><span class="p">]))</span>
        <span class="n">d3</span> <span class="o">=</span> <span class="n">vlen</span><span class="p">(</span><span class="n">vdiff</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">verts</span><span class="p">[</span><span class="n">v3</span><span class="p">]))</span>
        <span class="n">sumlen1</span> <span class="o">=</span> <span class="n">d1</span> <span class="o">+</span> <span class="n">d2</span> <span class="o">+</span> <span class="n">d3</span>
        <span class="n">w1</span> <span class="o">=</span> <span class="n">sumlen1</span> <span class="o">/</span> <span class="n">d1</span>
        <span class="n">w2</span> <span class="o">=</span> <span class="n">sumlen1</span> <span class="o">/</span> <span class="n">d2</span>
        <span class="n">w3</span> <span class="o">=</span> <span class="n">sumlen1</span> <span class="o">/</span> <span class="n">d3</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vnormals</span><span class="p">[</span><span class="n">v1</span><span class="p">]</span>
        <span class="n">n2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vnormals</span><span class="p">[</span><span class="n">v2</span><span class="p">]</span>
        <span class="n">n3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vnormals</span><span class="p">[</span><span class="n">v3</span><span class="p">]</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">n1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">w1</span> <span class="o">+</span> <span class="n">n2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">w2</span> <span class="o">+</span> <span class="n">n3</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">w3</span><span class="p">),</span>
            <span class="p">(</span><span class="n">n1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">w1</span> <span class="o">+</span> <span class="n">n2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">w2</span> <span class="o">+</span> <span class="n">n3</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">w3</span><span class="p">),</span>
            <span class="p">(</span><span class="n">n1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">w1</span> <span class="o">+</span> <span class="n">n2</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">w2</span> <span class="o">+</span> <span class="n">n3</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">w3</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">l1</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">vlen</span><span class="p">(</span><span class="n">norm</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">norm</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">l1</span><span class="p">,</span> <span class="n">norm</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">l1</span><span class="p">,</span> <span class="n">norm</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">l1</span><span class="p">)</span></div>


<div class="viewcode-block" id="Compartment.createSurfacePoints">
<a class="viewcode-back" href="../../../cellpack.autopack.html#cellpack.autopack.Compartment.Compartment.createSurfacePoints">[docs]</a>
    <span class="k">def</span> <span class="nf">createSurfacePoints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maxl</span><span class="o">=</span><span class="mi">20</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        create points inside edges and faces with max distance between then maxl</span>
<span class="sd">        creates self.surfacePoints and self.surfacePointsNormals</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span>
        <span class="n">faces</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">faces</span>
        <span class="n">vnormals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vnormals</span>

        <span class="n">points</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">vertices</span><span class="p">)[:]</span>
        <span class="n">normals</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">vnormals</span><span class="p">)[:]</span>

        <span class="c1"># create points in edges</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">fn</span><span class="p">,</span> <span class="n">tri</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">faces</span><span class="p">):</span>
            <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">tri</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tri</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">s2</span><span class="p">,</span> <span class="n">s1</span><span class="p">)</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
                <span class="n">edges</span><span class="p">[(</span><span class="n">s2</span><span class="p">,</span> <span class="n">s1</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">edges</span><span class="p">[(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">)]</span> <span class="o">=</span> <span class="p">[</span><span class="n">fn</span><span class="p">]</span>

            <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">tri</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">tri</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">s2</span><span class="p">,</span> <span class="n">s1</span><span class="p">)</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
                <span class="n">edges</span><span class="p">[(</span><span class="n">s2</span><span class="p">,</span> <span class="n">s1</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">edges</span><span class="p">[(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">)]</span> <span class="o">=</span> <span class="p">[</span><span class="n">fn</span><span class="p">]</span>

            <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">tri</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">tri</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">s2</span><span class="p">,</span> <span class="n">s1</span><span class="p">)</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
                <span class="n">edges</span><span class="p">[(</span><span class="n">s2</span><span class="p">,</span> <span class="n">s1</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">edges</span><span class="p">[(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">)]</span> <span class="o">=</span> <span class="p">[</span><span class="n">fn</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">edge</span><span class="p">,</span> <span class="n">faceInd</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">edges</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">edge</span>
            <span class="n">p1</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[</span><span class="n">s1</span><span class="p">]</span>
            <span class="n">p2</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[</span><span class="n">s2</span><span class="p">]</span>
            <span class="n">v1</span> <span class="o">=</span> <span class="n">vdiff</span><span class="p">(</span><span class="n">p2</span><span class="p">,</span> <span class="n">p1</span><span class="p">)</span>  <span class="c1"># p1-&gt;p2</span>
            <span class="n">l1</span> <span class="o">=</span> <span class="n">vlen</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">l1</span> <span class="o">&lt;=</span> <span class="n">maxl</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># compute number of points</span>
            <span class="n">nbp1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">l1</span> <span class="o">/</span> <span class="n">maxl</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">nbp1</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># compute interval size to spread the points</span>
            <span class="n">dl1</span> <span class="o">=</span> <span class="n">l1</span> <span class="o">/</span> <span class="p">(</span><span class="n">nbp1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

            <span class="c1"># compute interval vector</span>
            <span class="n">dx1</span> <span class="o">=</span> <span class="n">dl1</span> <span class="o">*</span> <span class="n">v1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">l1</span>
            <span class="n">dy1</span> <span class="o">=</span> <span class="n">dl1</span> <span class="o">*</span> <span class="n">v1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">l1</span>
            <span class="n">dz1</span> <span class="o">=</span> <span class="n">dl1</span> <span class="o">*</span> <span class="n">v1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="n">l1</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">p1</span>
            <span class="n">nx1</span><span class="p">,</span> <span class="n">ny1</span><span class="p">,</span> <span class="n">nz1</span> <span class="o">=</span> <span class="n">vnormals</span><span class="p">[</span><span class="n">s1</span><span class="p">]</span>
            <span class="n">nx2</span><span class="p">,</span> <span class="n">ny2</span><span class="p">,</span> <span class="n">nz2</span> <span class="o">=</span> <span class="n">vnormals</span><span class="p">[</span><span class="n">s2</span><span class="p">]</span>
            <span class="n">edgeNorm</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">nx1</span> <span class="o">+</span> <span class="n">nx2</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span>
                <span class="p">(</span><span class="n">ny1</span> <span class="o">+</span> <span class="n">ny2</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span>
                <span class="p">(</span><span class="n">nz1</span> <span class="o">+</span> <span class="n">nz2</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nbp1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">x</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">dx1</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">dy1</span><span class="p">,</span> <span class="n">z</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">dz1</span><span class="p">))</span>
                <span class="n">normals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edgeNorm</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">fn</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">faces</span><span class="p">):</span>
            <span class="c1"># if t[0]==16 and t[1]==6 and t[2]==11:</span>
            <span class="c1">#    pdb.set_trace()</span>
            <span class="n">pa</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">pb</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
            <span class="n">pc</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[</span><span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>

            <span class="n">va</span> <span class="o">=</span> <span class="n">vdiff</span><span class="p">(</span><span class="n">pb</span><span class="p">,</span> <span class="n">pa</span><span class="p">)</span>  <span class="c1"># p1-&gt;p2</span>
            <span class="n">la</span> <span class="o">=</span> <span class="n">vlen</span><span class="p">(</span><span class="n">va</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">la</span> <span class="o">&lt;=</span> <span class="n">maxl</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">vb</span> <span class="o">=</span> <span class="n">vdiff</span><span class="p">(</span><span class="n">pc</span><span class="p">,</span> <span class="n">pb</span><span class="p">)</span>  <span class="c1"># p2-&gt;p3</span>
            <span class="n">lb</span> <span class="o">=</span> <span class="n">vlen</span><span class="p">(</span><span class="n">vb</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">lb</span> <span class="o">&lt;=</span> <span class="n">maxl</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">vc</span> <span class="o">=</span> <span class="n">vdiff</span><span class="p">(</span><span class="n">pa</span><span class="p">,</span> <span class="n">pc</span><span class="p">)</span>  <span class="c1"># p3-&gt;p1</span>
            <span class="n">lc</span> <span class="o">=</span> <span class="n">vlen</span><span class="p">(</span><span class="n">vc</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">lc</span> <span class="o">&lt;=</span> <span class="n">maxl</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># pick shortest edge to be second vector</span>
            <span class="k">if</span> <span class="n">la</span> <span class="o">&lt;=</span> <span class="n">lb</span> <span class="ow">and</span> <span class="n">la</span> <span class="o">&lt;=</span> <span class="n">lc</span><span class="p">:</span>
                <span class="n">p1</span> <span class="o">=</span> <span class="n">pc</span>
                <span class="n">p2</span> <span class="o">=</span> <span class="n">pa</span>
                <span class="n">v1</span> <span class="o">=</span> <span class="n">vc</span>
                <span class="n">l1</span> <span class="o">=</span> <span class="n">lc</span>
                <span class="n">v2</span> <span class="o">=</span> <span class="n">va</span>
                <span class="n">l2</span> <span class="o">=</span> <span class="n">la</span>
                <span class="n">v3</span> <span class="o">=</span> <span class="n">vb</span>

            <span class="k">if</span> <span class="n">lb</span> <span class="o">&lt;=</span> <span class="n">la</span> <span class="ow">and</span> <span class="n">lb</span> <span class="o">&lt;=</span> <span class="n">lc</span><span class="p">:</span>
                <span class="n">p1</span> <span class="o">=</span> <span class="n">pa</span>
                <span class="n">p2</span> <span class="o">=</span> <span class="n">pb</span>
                <span class="n">v1</span> <span class="o">=</span> <span class="n">va</span>
                <span class="n">l1</span> <span class="o">=</span> <span class="n">la</span>
                <span class="n">v2</span> <span class="o">=</span> <span class="n">vb</span>
                <span class="n">l2</span> <span class="o">=</span> <span class="n">lb</span>
                <span class="n">v3</span> <span class="o">=</span> <span class="n">vc</span>

            <span class="k">if</span> <span class="n">lc</span> <span class="o">&lt;=</span> <span class="n">lb</span> <span class="ow">and</span> <span class="n">lc</span> <span class="o">&lt;=</span> <span class="n">la</span><span class="p">:</span>
                <span class="n">p1</span> <span class="o">=</span> <span class="n">pb</span>
                <span class="n">p2</span> <span class="o">=</span> <span class="n">pc</span>
                <span class="n">v1</span> <span class="o">=</span> <span class="n">vb</span>
                <span class="n">l1</span> <span class="o">=</span> <span class="n">lb</span>
                <span class="n">v2</span> <span class="o">=</span> <span class="n">vc</span>
                <span class="n">l2</span> <span class="o">=</span> <span class="n">lc</span>
                <span class="n">v3</span> <span class="o">=</span> <span class="n">va</span>

            <span class="n">lengthRatio</span> <span class="o">=</span> <span class="n">l2</span> <span class="o">/</span> <span class="n">l1</span>

            <span class="n">nbp1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">l1</span> <span class="o">/</span> <span class="n">maxl</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">nbp1</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">dl1</span> <span class="o">=</span> <span class="n">l1</span> <span class="o">/</span> <span class="p">(</span><span class="n">nbp1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

            <span class="n">dx1</span> <span class="o">=</span> <span class="n">dl1</span> <span class="o">*</span> <span class="n">v1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">l1</span>
            <span class="n">dy1</span> <span class="o">=</span> <span class="n">dl1</span> <span class="o">*</span> <span class="n">v1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">l1</span>
            <span class="n">dz1</span> <span class="o">=</span> <span class="n">dl1</span> <span class="o">*</span> <span class="n">v1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="n">l1</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">p1</span>
            <span class="n">fn</span> <span class="o">=</span> <span class="n">vcross</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="n">v3</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="n">v3</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="n">v3</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
            <span class="n">fnl</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">vlen</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
            <span class="n">faceNorm</span> <span class="o">=</span> <span class="p">(</span><span class="n">fn</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">fnl</span><span class="p">,</span> <span class="n">fn</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">fnl</span><span class="p">,</span> <span class="n">fn</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">fnl</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nbp1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">l2c</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">dl1</span><span class="p">)</span> <span class="o">*</span> <span class="n">lengthRatio</span>
                <span class="n">nbp2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">l2c</span> <span class="o">/</span> <span class="n">maxl</span><span class="p">)</span>
                <span class="c1">#                percentage = (i*dl1)/l1</span>
                <span class="c1"># nbp2 = int(l2*lengthRatio*percentage/maxl)</span>
                <span class="k">if</span> <span class="n">nbp2</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="c1"># dl2 = l2*percentage/(nbp2+1)</span>
                <span class="n">dl2</span> <span class="o">=</span> <span class="n">l2c</span> <span class="o">/</span> <span class="p">(</span><span class="n">nbp2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

                <span class="n">dx2</span> <span class="o">=</span> <span class="n">dl2</span> <span class="o">*</span> <span class="n">v2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">l2</span>
                <span class="n">dy2</span> <span class="o">=</span> <span class="n">dl2</span> <span class="o">*</span> <span class="n">v2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">l2</span>
                <span class="n">dz2</span> <span class="o">=</span> <span class="n">dl2</span> <span class="o">*</span> <span class="n">v2</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="n">l2</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nbp2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="p">(</span>
                            <span class="n">x</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">dx1</span> <span class="o">+</span> <span class="n">j</span> <span class="o">*</span> <span class="n">dx2</span><span class="p">,</span>
                            <span class="n">y</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">dy1</span> <span class="o">+</span> <span class="n">j</span> <span class="o">*</span> <span class="n">dy2</span><span class="p">,</span>
                            <span class="n">z</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">dz1</span> <span class="o">+</span> <span class="n">j</span> <span class="o">*</span> <span class="n">dz2</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                    <span class="n">normals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">faceNorm</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ogsurfacePoints</span> <span class="o">=</span> <span class="n">points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ogsurfacePointsNormals</span> <span class="o">=</span> <span class="n">normals</span></div>


<div class="viewcode-block" id="Compartment.is_point_inside_mesh">
<a class="viewcode-back" href="../../../cellpack.autopack.html#cellpack.autopack.Compartment.Compartment.is_point_inside_mesh">[docs]</a>
    <span class="k">def</span> <span class="nf">is_point_inside_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="n">diag</span><span class="p">,</span> <span class="n">mesh_store</span><span class="p">,</span> <span class="n">ray</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">insideBB</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">checkPointInsideBB</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>  <span class="c1"># cutoff?</span>
        <span class="k">if</span> <span class="n">insideBB</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mesh_store</span><span class="o">.</span><span class="n">contains_point</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gname</span><span class="p">,</span> <span class="n">point</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="Compartment.BuildGrid">
<a class="viewcode-back" href="../../../cellpack.autopack.html#cellpack.autopack.Compartment.Compartment.BuildGrid">[docs]</a>
    <span class="k">def</span> <span class="nf">BuildGrid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">env</span><span class="p">,</span> <span class="n">mesh_store</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_orthogonal_bounding_box</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">prepare_buildgrid_box</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ghost</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span>
        <span class="p">)</span>  <span class="c1"># NEED to make these limited to selection box, not whole compartment</span>
        <span class="n">faces</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">faces</span>
        <span class="p">)</span>  <span class="c1"># Should be able to use self.ogsurfacePoints and collect faces too from above</span>

        <span class="n">normalList2</span><span class="p">,</span> <span class="n">areas</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getFaceNormals</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span> <span class="n">faces</span><span class="p">,</span> <span class="n">fillBB</span><span class="o">=</span><span class="n">env</span><span class="o">.</span><span class="n">fillBB</span><span class="p">)</span>
        <span class="n">vSurfaceArea</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">areas</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_box</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">overwriteSurfacePts</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">BuildGrid_box</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">vSurfaceArea</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">insidePoints</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">surfacePoints</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">overwriteSurfacePts</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ogsurfacePoints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[:]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ogsurfacePointsNormals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vnormals</span><span class="p">[:]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">createSurfacePoints</span><span class="p">(</span><span class="n">maxl</span><span class="o">=</span><span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">gridSpacing</span><span class="p">)</span>
        <span class="c1"># Graham Sum the SurfaceArea for each polyhedron</span>
        <span class="c1"># the distance is initialized to the largest possible value</span>
        <span class="c1"># (diagonal of the bounding box)</span>
        <span class="n">distances</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">distToClosestSurf</span>
        <span class="n">compartment_ids</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">compartment_ids</span>
        <span class="n">diag</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">diag</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;distance </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">distances</span><span class="p">))</span>

        <span class="c1"># build search tree for off grid surface points</span>
        <span class="c1"># off grid points are the vertexes of the mesh</span>
        <span class="n">off_grid_surface_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ogsurfacePoints</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">OGsrfPtsBht</span> <span class="o">=</span> <span class="n">ctree</span> <span class="o">=</span> <span class="n">spatial</span><span class="o">.</span><span class="n">cKDTree</span><span class="p">(</span>
            <span class="nb">tuple</span><span class="p">(</span><span class="n">off_grid_surface_points</span><span class="p">),</span> <span class="n">leafsize</span><span class="o">=</span><span class="mi">10</span>
        <span class="p">)</span>
        <span class="c1"># res = numpy.zeros(len(srfPts),&#39;f&#39;)</span>
        <span class="c1"># dist2 = numpy.zeros(len(srfPts),&#39;f&#39;)</span>

        <span class="n">master_grid_positions</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">masterGridPositions</span>
        <span class="n">new_distances</span><span class="p">,</span> <span class="n">indexes</span> <span class="o">=</span> <span class="n">ctree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
            <span class="nb">tuple</span><span class="p">(</span><span class="n">master_grid_positions</span><span class="p">)</span>
        <span class="p">)</span>  <span class="c1"># return both indices and distances</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">closestId</span> <span class="o">=</span> <span class="n">indexes</span>
        <span class="c1"># TODO: do this to the actual closest point on the mesh, not the closet vertex</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">distances</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="n">master_grid_positions</span><span class="p">)]</span> <span class="o">&gt;</span> <span class="n">new_distances</span>
        <span class="n">grid_point_indexes</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
        <span class="n">distances</span><span class="p">[</span><span class="n">grid_point_indexes</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_distances</span><span class="p">[</span><span class="n">grid_point_indexes</span><span class="p">]</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="n">env</span><span class="o">.</span><span class="n">innerGridMethod</span> <span class="o">==</span> <span class="s2">&quot;sdf&quot;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_orthogonal_bounding_box</span> <span class="o">!=</span> <span class="mi">1</span>
        <span class="p">):</span>  <span class="c1"># A fillSelection can now be a mesh too... it can use either of these methods</span>
            <span class="n">inside_points</span><span class="p">,</span> <span class="n">surface_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">BuildGrid_utsdf</span><span class="p">(</span>
                <span class="n">env</span>
            <span class="p">)</span>  <span class="c1"># to make the outer most selection from the master and then the compartment</span>
        <span class="k">elif</span> <span class="n">env</span><span class="o">.</span><span class="n">innerGridMethod</span> <span class="o">==</span> <span class="s2">&quot;bhtree&quot;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_orthogonal_bounding_box</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">inside_points</span><span class="p">,</span> <span class="n">surface_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">BuildGrid_bhtree</span><span class="p">(</span>
                <span class="n">env</span><span class="p">,</span>
                <span class="n">ctree</span><span class="p">,</span>
                <span class="n">master_grid_positions</span><span class="p">,</span>
                <span class="n">diag</span><span class="p">,</span>
                <span class="n">vSurfaceArea</span><span class="p">,</span>
                <span class="n">off_grid_surface_points</span><span class="p">,</span>
                <span class="n">compartment_ids</span><span class="p">,</span>
                <span class="n">distances</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span>
            <span class="n">env</span><span class="o">.</span><span class="n">innerGridMethod</span> <span class="o">==</span> <span class="s2">&quot;raytrace&quot;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_orthogonal_bounding_box</span> <span class="o">!=</span> <span class="mi">1</span>
        <span class="p">):</span>  <span class="c1"># surfaces and interiors will be subtracted from it as normal!</span>
            <span class="n">inside_points</span><span class="p">,</span> <span class="n">surface_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">BuildGrid_ray</span><span class="p">(</span>
                <span class="n">env</span><span class="p">,</span>
                <span class="n">master_grid_positions</span><span class="p">,</span>
                <span class="n">vSurfaceArea</span><span class="p">,</span>
                <span class="n">off_grid_surface_points</span><span class="p">,</span>
                <span class="n">compartment_ids</span><span class="p">,</span>
                <span class="n">mesh_store</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span>
            <span class="n">env</span><span class="o">.</span><span class="n">innerGridMethod</span> <span class="o">==</span> <span class="s2">&quot;pyray&quot;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_orthogonal_bounding_box</span> <span class="o">!=</span> <span class="mi">1</span>
        <span class="p">):</span>  <span class="c1"># surfaces and interiors will be subtracted from it as normal!</span>
            <span class="n">inside_points</span><span class="p">,</span> <span class="n">surface_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">BuildGrid_pyray</span><span class="p">(</span>
                <span class="n">env</span><span class="p">,</span>
                <span class="n">ctree</span><span class="p">,</span>
                <span class="n">distances</span><span class="p">,</span>
                <span class="n">master_grid_positions</span><span class="p">,</span>
                <span class="n">diag</span><span class="p">,</span>
                <span class="n">vSurfaceArea</span><span class="p">,</span>
                <span class="n">off_grid_surface_points</span><span class="p">,</span>
                <span class="n">compartment_ids</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span>
            <span class="n">env</span><span class="o">.</span><span class="n">innerGridMethod</span> <span class="o">==</span> <span class="s2">&quot;floodfill&quot;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_orthogonal_bounding_box</span> <span class="o">!=</span> <span class="mi">1</span>
        <span class="p">):</span>  <span class="c1"># surfaces and interiors will be subtracted from it as normal!</span>
            <span class="n">inside_points</span><span class="p">,</span> <span class="n">surface_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">BuildGrid_kevin</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span>
            <span class="n">env</span><span class="o">.</span><span class="n">innerGridMethod</span> <span class="o">==</span> <span class="s2">&quot;binvox&quot;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_orthogonal_bounding_box</span> <span class="o">!=</span> <span class="mi">1</span>
        <span class="p">):</span>  <span class="c1"># surfaces and interiors will be subtracted from it as normal!</span>
            <span class="n">inside_points</span><span class="p">,</span> <span class="n">surface_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">BuildGrid_binvox</span><span class="p">(</span>
                <span class="n">env</span><span class="p">,</span>
                <span class="n">master_grid_positions</span><span class="p">,</span>
                <span class="n">vSurfaceArea</span><span class="p">,</span>
                <span class="n">off_grid_surface_points</span><span class="p">,</span>
                <span class="n">compartment_ids</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span>
            <span class="n">env</span><span class="o">.</span><span class="n">innerGridMethod</span> <span class="o">==</span> <span class="s2">&quot;trimesh&quot;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_orthogonal_bounding_box</span> <span class="o">!=</span> <span class="mi">1</span>
        <span class="p">):</span>  <span class="c1"># surfaces and interiors will be subtracted from it as normal!</span>
            <span class="n">inside_points</span><span class="p">,</span> <span class="n">surface_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">BuildGrid_trimesh</span><span class="p">(</span>
                <span class="n">env</span><span class="p">,</span>
                <span class="n">master_grid_positions</span><span class="p">,</span>
                <span class="n">vSurfaceArea</span><span class="p">,</span>
                <span class="n">off_grid_surface_points</span><span class="p">,</span>
                <span class="n">compartment_ids</span><span class="p">,</span>
                <span class="n">mesh_store</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span>
            <span class="n">env</span><span class="o">.</span><span class="n">innerGridMethod</span> <span class="o">==</span> <span class="s2">&quot;scanline&quot;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_orthogonal_bounding_box</span> <span class="o">!=</span> <span class="mi">1</span>
        <span class="p">):</span>  <span class="c1"># surfaces and interiors will be subtracted from it as normal!</span>
            <span class="n">inside_points</span><span class="p">,</span> <span class="n">surface_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">BuildGrid_scanline</span><span class="p">(</span>
                <span class="n">env</span><span class="p">,</span>
                <span class="n">master_grid_positions</span><span class="p">,</span>
                <span class="n">new_distances</span><span class="p">,</span>
                <span class="n">diag</span><span class="p">,</span>
                <span class="n">vSurfaceArea</span><span class="p">,</span>
                <span class="n">off_grid_surface_points</span><span class="p">,</span>
                <span class="n">compartment_ids</span><span class="p">,</span>
                <span class="n">mesh_store</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Not a recognized inner grid method&quot;</span><span class="p">,</span> <span class="n">env</span><span class="o">.</span><span class="n">innerGridMethod</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">compute_volume_and_set_count</span><span class="p">(</span>
            <span class="n">env</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">surfacePoints</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">insidePoints</span><span class="p">,</span> <span class="n">areas</span><span class="o">=</span><span class="n">vSurfaceArea</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">inside_points</span><span class="p">,</span> <span class="n">surface_points</span></div>


<div class="viewcode-block" id="Compartment.build_grid_sphere">
<a class="viewcode-back" href="../../../cellpack.autopack.html#cellpack.autopack.Compartment.Compartment.build_grid_sphere">[docs]</a>
    <span class="k">def</span> <span class="nf">build_grid_sphere</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">env</span><span class="p">):</span>
        <span class="n">grid_pts_in_sphere_indexes</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">getPointsInSphere</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">radius</span>
        <span class="p">)</span>  <span class="c1"># This is the highspeed shortcut for inside points! and no surface! that gets used if the fillSelection is an orthogonal box and there are no other compartments.</span>
        <span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">compartment_ids</span><span class="p">[</span><span class="n">grid_pts_in_sphere_indexes</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">number</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surfacePointsCoords</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">vSurfaceArea</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="o">**</span><span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;vSurfaceArea = </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">vSurfaceArea</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">insidePoints</span> <span class="o">=</span> <span class="n">grid_pts_in_sphere_indexes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surfacePoints</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surfacePointsCoords</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surfacePointsNormals</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">grid_pts_in_sphere_indexes</span><span class="p">)</span><span class="si">}</span><span class="s2"> inside pts, </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">grid_pts_in_sphere_indexes</span><span class="p">)</span><span class="si">}</span><span class="s2"> tot grid pts, </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">masterGridPositions</span><span class="p">)</span><span class="si">}</span><span class="s2"> master grid&quot;</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Compartment.prepare_buildgrid_box">
<a class="viewcode-back" href="../../../cellpack.autopack.html#cellpack.autopack.Compartment.Compartment.prepare_buildgrid_box">[docs]</a>
    <span class="k">def</span> <span class="nf">prepare_buildgrid_box</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">env</span><span class="p">):</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">getPointsInCube</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bb</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="p">)</span>  <span class="c1"># This is the highspeed shortcut for inside points! and no surface! that gets used if the fillSelection is an orthogonal box and there are no other compartments.</span>
        <span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">compartment_ids</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">number</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surfacePointsCoords</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">bb0x</span><span class="p">,</span> <span class="n">bb0y</span><span class="p">,</span> <span class="n">bb0z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">bb1x</span><span class="p">,</span> <span class="n">bb1y</span><span class="p">,</span> <span class="n">bb1z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">AreaXplane</span> <span class="o">=</span> <span class="p">(</span><span class="n">bb1y</span> <span class="o">-</span> <span class="n">bb0y</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">bb1z</span> <span class="o">-</span> <span class="n">bb0z</span><span class="p">)</span>
        <span class="n">AreaYplane</span> <span class="o">=</span> <span class="p">(</span><span class="n">bb1x</span> <span class="o">-</span> <span class="n">bb0x</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">bb1z</span> <span class="o">-</span> <span class="n">bb0z</span><span class="p">)</span>
        <span class="n">AreaZplane</span> <span class="o">=</span> <span class="p">(</span><span class="n">bb1y</span> <span class="o">-</span> <span class="n">bb0y</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">bb1x</span> <span class="o">-</span> <span class="n">bb0x</span><span class="p">)</span>
        <span class="n">vSurfaceArea</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">AreaXplane</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="n">AreaYplane</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="n">AreaZplane</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;vSurfaceArea = </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">vSurfaceArea</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">insidePoints</span> <span class="o">=</span> <span class="n">a</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surfacePoints</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surfacePointsCoords</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surfacePointsNormals</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> inside pts, </span><span class="si">%d</span><span class="s2"> tot grid pts, </span><span class="si">%d</span><span class="s2"> master grid&quot;</span><span class="p">,</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">),</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">),</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">masterGridPositions</span><span class="p">),</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Compartment.set_surface_distances">
<a class="viewcode-back" href="../../../cellpack.autopack.html#cellpack.autopack.Compartment.Compartment.set_surface_distances">[docs]</a>
    <span class="k">def</span> <span class="nf">set_surface_distances</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">env</span><span class="p">,</span> <span class="n">master_grid_positions</span><span class="p">,</span> <span class="n">calc_distance_between_surfaces</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>
        <span class="n">surface_mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number</span><span class="p">,</span> <span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">compartment_ids</span><span class="p">)</span>
        <span class="n">surface_ids</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">surface_mask</span><span class="p">)</span>
        <span class="n">surface_positions</span> <span class="o">=</span> <span class="n">master_grid_positions</span><span class="p">[</span><span class="n">surface_ids</span><span class="p">]</span>
        <span class="n">surface_tree</span> <span class="o">=</span> <span class="n">spatial</span><span class="o">.</span><span class="n">cKDTree</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">surface_positions</span><span class="p">),</span> <span class="n">leafsize</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
        <span class="n">parent_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">number</span>
        <span class="c1"># clacluate the distances for the points inside the surface, and outside the surface</span>
        <span class="c1"># up to the next boundary (not including the parent&#39;s surface points)</span>
        <span class="n">grid_pt_indexes</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span>
            <span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">compartment_ids</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">number</span>
        <span class="p">)</span> <span class="o">|</span> <span class="n">numpy</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">compartment_ids</span><span class="p">,</span> <span class="o">-</span><span class="n">parent_id</span><span class="p">)</span>
        <span class="n">grid_pt_to_calc</span> <span class="o">=</span> <span class="n">master_grid_positions</span><span class="p">[</span><span class="n">grid_pt_indexes</span><span class="p">]</span>

        <span class="n">surface_distances</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">surface_tree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">grid_pt_to_calc</span><span class="p">))</span>
        <span class="n">all_surface_distances</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">master_grid_positions</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="n">all_surface_distances</span><span class="p">[</span><span class="n">grid_pt_indexes</span><span class="p">]</span> <span class="o">=</span> <span class="n">surface_distances</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="n">calc_distance_between_surfaces</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="n">parent_id</span> <span class="o">!=</span> <span class="mi">0</span>
        <span class="p">):</span>
            <span class="n">grid_pts_between_surfaces</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span>
                <span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">compartment_ids</span><span class="p">,</span> <span class="o">-</span><span class="n">parent_id</span>
            <span class="p">)</span>
            <span class="n">grid_pt_to_calc</span> <span class="o">=</span> <span class="n">master_grid_positions</span><span class="p">[</span><span class="n">grid_pts_between_surfaces</span><span class="p">]</span>
            <span class="n">scaled_distance_to_next_surface</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">full</span><span class="p">(</span>
                <span class="n">master_grid_positions</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nan</span>
            <span class="p">)</span>
            <span class="p">(</span>
                <span class="n">scaled_distance_to_next_surface</span><span class="p">[</span><span class="n">grid_pts_between_surfaces</span><span class="p">],</span>
                <span class="n">_</span><span class="p">,</span>
                <span class="n">_</span><span class="p">,</span>
            <span class="p">)</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">mesh_store</span><span class="o">.</span><span class="n">get_scaled_distances_between_surfaces</span><span class="p">(</span>
                <span class="n">grid_pt_to_calc</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">gname</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">gname</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scaled_distance_to_next_surface</span> <span class="o">=</span> <span class="n">scaled_distance_to_next_surface</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">max_distance</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">surface_distances</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surface_distances</span> <span class="o">=</span> <span class="n">all_surface_distances</span></div>


<div class="viewcode-block" id="Compartment.BuildGrid_box">
<a class="viewcode-back" href="../../../cellpack.autopack.html#cellpack.autopack.Compartment.Compartment.BuildGrid_box">[docs]</a>
    <span class="k">def</span> <span class="nf">BuildGrid_box</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">env</span><span class="p">,</span> <span class="n">vSurfaceArea</span><span class="p">):</span>
        <span class="n">nbGridPoints</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">masterGridPositions</span><span class="p">)</span>
        <span class="n">insidePoints</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">getPointsInCube</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bb</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">addSP</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">insidePoints</span><span class="p">:</span>
            <span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">compartment_ids</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">number</span>
        <span class="n">surfPtsBB</span><span class="p">,</span> <span class="n">surfPtsBBNorms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_surface_pts_to_fill_box</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ogsurfacePoints</span><span class="p">,</span> <span class="n">env</span>
        <span class="p">)</span>
        <span class="n">srfPts</span> <span class="o">=</span> <span class="n">surfPtsBB</span>
        <span class="n">surfacePoints</span><span class="p">,</span> <span class="n">surfacePointsNormals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extendGridArrays</span><span class="p">(</span>
            <span class="n">nbGridPoints</span><span class="p">,</span> <span class="n">srfPts</span><span class="p">,</span> <span class="n">surfPtsBBNorms</span><span class="p">,</span> <span class="n">env</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">insidePoints</span> <span class="o">=</span> <span class="n">insidePoints</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surfacePoints</span> <span class="o">=</span> <span class="n">surfacePoints</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surfacePointsCoords</span> <span class="o">=</span> <span class="n">surfPtsBB</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surfacePointsNormals</span> <span class="o">=</span> <span class="n">surfacePointsNormals</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> surface pts, </span><span class="si">%d</span><span class="s2"> inside pts, </span><span class="si">%d</span><span class="s2"> tot grid pts, </span><span class="si">%d</span><span class="s2"> master grid&quot;</span><span class="p">,</span>
            <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surfacePoints</span><span class="p">),</span>
            <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">insidePoints</span><span class="p">),</span>
            <span class="n">nbGridPoints</span><span class="p">,</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">masterGridPositions</span><span class="p">),</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Compartment.BuildGrid_ray">
<a class="viewcode-back" href="../../../cellpack.autopack.html#cellpack.autopack.Compartment.Compartment.BuildGrid_ray">[docs]</a>
    <span class="k">def</span> <span class="nf">BuildGrid_ray</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">env</span><span class="p">,</span>
        <span class="n">grdPos</span><span class="p">,</span>
        <span class="n">vSurfaceArea</span><span class="p">,</span>
        <span class="n">vertex_points</span><span class="p">,</span>
        <span class="n">idarray</span><span class="p">,</span>
        <span class="n">mesh_store</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Build the compartment grid using pyembree raycast to find inside points,</span>
<span class="sd">        and then a cKDTree to find &quot;missing&quot; surface points, ie surface points that are</span>
<span class="sd">        in between vertex points&quot;&quot;&quot;</span>

        <span class="n">insidePoints</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">compartment_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number</span>
        <span class="n">spacing</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">gridSpacing</span>
        <span class="n">variation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">encapsulating_radius</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">radius</span>
        <span class="n">is_sphere</span> <span class="o">=</span> <span class="n">variation</span> <span class="o">&lt;</span> <span class="n">spacing</span>
        <span class="c1"># now check if point inside</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="n">spatial</span><span class="o">.</span><span class="n">cKDTree</span><span class="p">(</span><span class="n">grdPos</span><span class="p">,</span> <span class="n">leafsize</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
        <span class="n">points_in_encap_sphere</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">query_ball_point</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">center</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">encapsulating_radius</span><span class="p">,</span> <span class="n">return_sorted</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">is_sphere</span><span class="p">:</span>
            <span class="n">inside</span> <span class="o">=</span> <span class="n">points_in_encap_sphere</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">positions</span> <span class="o">=</span> <span class="n">grdPos</span><span class="p">[</span><span class="n">points_in_encap_sphere</span><span class="p">]</span>
            <span class="n">inside</span> <span class="o">=</span> <span class="n">mesh_store</span><span class="o">.</span><span class="n">contains_points_slow</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gname</span><span class="p">,</span> <span class="n">positions</span><span class="p">)</span>

        <span class="c1"># set inside points in data</span>
        <span class="n">inside_indexes</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points_in_encap_sphere</span><span class="p">)[</span><span class="n">numpy</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">inside</span><span class="p">)]</span>
        <span class="n">insidePoints</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">inside_indexes</span><span class="p">)</span>
        <span class="n">idarray</span><span class="p">[</span><span class="n">inside_indexes</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">compartment_id</span>

        <span class="c1"># find missing surface points</span>
        <span class="n">outside_points_positions</span> <span class="o">=</span> <span class="n">grdPos</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">idarray</span> <span class="o">!=</span> <span class="o">-</span><span class="n">compartment_id</span><span class="p">)]</span>
        <span class="n">inside_points_positions</span> <span class="o">=</span> <span class="n">grdPos</span><span class="p">[</span><span class="n">inside_indexes</span><span class="p">]</span>
        <span class="n">inside_tree</span> <span class="o">=</span> <span class="n">spatial</span><span class="o">.</span><span class="n">cKDTree</span><span class="p">(</span><span class="n">inside_points_positions</span><span class="p">,</span> <span class="n">leafsize</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
        <span class="n">surface_i</span> <span class="o">=</span> <span class="n">inside_tree</span><span class="o">.</span><span class="n">query_ball_point</span><span class="p">(</span>
            <span class="n">outside_points_positions</span><span class="p">,</span> <span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">gridSpacing</span>
        <span class="p">)</span>
        <span class="n">on_grid_surface_point_positions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">surface_i</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">surface_indexes</span> <span class="o">=</span> <span class="n">inside_indexes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">on_grid_surface_point_positions</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">grdPos</span><span class="p">[</span><span class="n">surface_indexes</span><span class="p">])</span>
                <span class="n">idarray</span><span class="p">[</span><span class="n">surface_indexes</span><span class="p">]</span> <span class="o">=</span> <span class="n">compartment_id</span>
        <span class="n">number_of_base_grid_points</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">masterGridPositions</span><span class="p">)</span>
        <span class="p">(</span>
            <span class="n">off_grid_surface_pt_pos</span><span class="p">,</span>
            <span class="n">filtered_surface_pt_normals</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_surface_pts_to_fill_box</span><span class="p">(</span><span class="n">vertex_points</span><span class="p">,</span> <span class="n">env</span><span class="p">)</span>
        <span class="n">ex</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># True if nbGridPoints == len(idarray) else False</span>
        <span class="n">surface_point_ids</span><span class="p">,</span> <span class="n">surfacePointsNormals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extendGridArrays</span><span class="p">(</span>
            <span class="n">number_of_base_grid_points</span><span class="p">,</span>
            <span class="n">off_grid_surface_pt_pos</span><span class="p">,</span>
            <span class="n">filtered_surface_pt_normals</span><span class="p">,</span>
            <span class="n">env</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">surfacePointsNormals</span><span class="p">,</span>
            <span class="n">extended</span><span class="o">=</span><span class="n">ex</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">all_surface_pt_pos</span> <span class="o">=</span> <span class="n">on_grid_surface_point_positions</span>
        <span class="n">all_surface_pt_pos</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">off_grid_surface_pt_pos</span><span class="p">)</span>

        <span class="n">all_surface_pt_ids</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">idarray</span> <span class="o">==</span> <span class="n">compartment_id</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">all_surface_pt_ids</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">surface_point_ids</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">insidePoints</span> <span class="o">=</span> <span class="n">insidePoints</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surfacePoints</span> <span class="o">=</span> <span class="n">all_surface_pt_ids</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surfacePointsCoords</span> <span class="o">=</span> <span class="n">all_surface_pt_pos</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surfacePointsNormals</span> <span class="o">=</span> <span class="n">surfacePointsNormals</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">insidePoints</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">surfacePoints</span></div>


<div class="viewcode-block" id="Compartment.BuildGrid_binvox">
<a class="viewcode-back" href="../../../cellpack.autopack.html#cellpack.autopack.Compartment.Compartment.BuildGrid_binvox">[docs]</a>
    <span class="k">def</span> <span class="nf">BuildGrid_binvox</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">env</span><span class="p">,</span> <span class="n">grdPos</span><span class="p">,</span> <span class="n">vSurfaceArea</span><span class="p">,</span> <span class="n">srfPts</span><span class="p">,</span> <span class="n">idarray</span><span class="p">,</span> <span class="n">ray</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="c1"># create surface points</span>
        <span class="c1"># check if file already exist, otherwise rebuild it</span>
        <span class="n">number</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number</span>
        <span class="n">fileName</span> <span class="o">=</span> <span class="n">autopack</span><span class="o">.</span><span class="n">get_local_file_location</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="s2">&quot;geometries&quot;</span><span class="p">)</span>
        <span class="n">filename</span><span class="p">,</span> <span class="n">file_extension</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">fileName</span><span class="p">)</span>
        <span class="n">binvox_filename</span> <span class="o">=</span> <span class="n">filename</span> <span class="o">+</span> <span class="s2">&quot;.binvox&quot;</span>
        <span class="n">bb</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">boundingBox</span>
        <span class="n">gridN</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">nbGridPoints</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">binvox_filename</span><span class="p">):</span>
            <span class="c1"># build the file</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;doesnt exist..build&quot;</span><span class="p">)</span>
            <span class="c1"># binvox.exe -c -d 30 -bb -850 -850 -850 850 850 850 HIV_VLP.dae</span>
            <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span>
                <span class="n">autopack</span><span class="o">.</span><span class="n">binvox_exe</span>
                <span class="o">+</span> <span class="s2">&quot; -c -dc -d </span><span class="si">%i</span><span class="s2"> -bb </span><span class="si">%f</span><span class="s2"> </span><span class="si">%f</span><span class="s2"> </span><span class="si">%f</span><span class="s2"> </span><span class="si">%f</span><span class="s2"> </span><span class="si">%f</span><span class="s2"> </span><span class="si">%f</span><span class="s2"> </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="o">%</span> <span class="p">(</span>
                    <span class="n">gridN</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="n">bb</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                    <span class="n">bb</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
                    <span class="n">bb</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span>
                    <span class="n">bb</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                    <span class="n">bb</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
                    <span class="n">bb</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span>
                    <span class="n">filename</span> <span class="o">+</span> <span class="s2">&quot;.obj&quot;</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">binvox_filename</span> <span class="o">=</span> <span class="n">binvox_filename</span>
        <span class="c1"># if use the exact approach, can do some floodfill after...</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binvox_filename</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">m</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">binvox_rw</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binvox_filename</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">model</span> <span class="o">=</span> <span class="n">binvox_rw</span><span class="o">.</span><span class="n">read_as_coord_array</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="c1"># model.translate=[0,0,0]</span>
        <span class="n">model</span><span class="o">.</span><span class="n">axis_order</span> <span class="o">=</span> <span class="s2">&quot;xzy&quot;</span>
        <span class="c1"># model.data = m.ijk.transpose()</span>
        <span class="n">xyz_Data</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">ijkToxyz</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">binvox_model</span> <span class="o">=</span> <span class="n">m</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">binvox_3d</span> <span class="o">=</span> <span class="n">xyz_Data</span>

        <span class="c1"># now check if point inside</span>
        <span class="c1">#</span>
        <span class="c1"># the main loop</span>
        <span class="c1"># need the ptInd that are inside the geom.</span>
        <span class="n">m1</span> <span class="o">=</span> <span class="p">(</span><span class="n">grdPos</span> <span class="o">&lt;</span> <span class="n">bb</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">m2</span> <span class="o">=</span> <span class="p">(</span><span class="n">grdPos</span> <span class="o">&gt;</span> <span class="n">bb</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">m3</span> <span class="o">=</span> <span class="n">m1</span> <span class="o">|</span> <span class="n">m2</span>
        <span class="c1"># outside indice</span>
        <span class="c1"># outsidebb = np.nonzero(m3)[0]</span>
        <span class="n">insidebb</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">m3</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">ijk</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">xyzToijk</span><span class="p">(</span><span class="n">grdPos</span><span class="p">[</span><span class="n">insidebb</span><span class="p">]))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">ijkToIndex</span><span class="p">(</span><span class="n">ijk</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">inbb_inside</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">inside_points</span> <span class="o">=</span> <span class="n">insidebb</span><span class="p">[</span><span class="n">inbb_inside</span><span class="p">]</span>
        <span class="n">idarray</span><span class="p">[</span><span class="n">inside_points</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">number</span>
        <span class="n">nbGridPoints</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">masterGridPositions</span><span class="p">)</span>

        <span class="n">surfPtsBB</span><span class="p">,</span> <span class="n">surfPtsBBNorms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_surface_pts_to_fill_box</span><span class="p">(</span><span class="n">srfPts</span><span class="p">,</span> <span class="n">env</span><span class="p">)</span>
        <span class="n">srfPts</span> <span class="o">=</span> <span class="n">surfPtsBB</span>

        <span class="n">ex</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># True if nbGridPoints == len(idarray) else False</span>
        <span class="n">surfacePoints</span><span class="p">,</span> <span class="n">surfacePointsNormals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extendGridArrays</span><span class="p">(</span>
            <span class="n">nbGridPoints</span><span class="p">,</span> <span class="n">srfPts</span><span class="p">,</span> <span class="n">surfPtsBBNorms</span><span class="p">,</span> <span class="n">env</span><span class="p">,</span> <span class="n">extended</span><span class="o">=</span><span class="n">ex</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">insidePoints</span> <span class="o">=</span> <span class="n">inside_points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surfacePoints</span> <span class="o">=</span> <span class="n">surfacePoints</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surfacePointsCoords</span> <span class="o">=</span> <span class="n">surfPtsBB</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surfacePointsNormals</span> <span class="o">=</span> <span class="n">surfacePointsNormals</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">insidePoints</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">surfacePoints</span></div>


<div class="viewcode-block" id="Compartment.BuildGrid_trimesh">
<a class="viewcode-back" href="../../../cellpack.autopack.html#cellpack.autopack.Compartment.Compartment.BuildGrid_trimesh">[docs]</a>
    <span class="k">def</span> <span class="nf">BuildGrid_trimesh</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">env</span><span class="p">,</span>
        <span class="n">master_grid_positions</span><span class="p">,</span>
        <span class="n">vSurfaceArea</span><span class="p">,</span>
        <span class="n">off_grid_surface_points</span><span class="p">,</span>
        <span class="n">compartment_ids</span><span class="p">,</span>
        <span class="n">mesh_store</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Build the compartment grid ie surface and inside points&quot;&quot;&quot;</span>
        <span class="n">insidePoints</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">number</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number</span>
        <span class="c1"># build trimer mesh</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh_store</span><span class="o">.</span><span class="n">get_mesh</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gname</span><span class="p">)</span>
        <span class="c1"># voxelized</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">: CREATED MESH&quot;</span><span class="p">)</span>
        <span class="n">trimesh_grid_surface</span> <span class="o">=</span> <span class="n">creation</span><span class="o">.</span><span class="n">voxelize</span><span class="p">(</span>
            <span class="n">mesh</span><span class="p">,</span> <span class="n">pitch</span><span class="o">=</span><span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">gridSpacing</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="p">)</span><span class="o">.</span><span class="n">hollow</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;VOXELIZED MESH&quot;</span><span class="p">)</span>
        <span class="c1"># the main loop</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="n">spatial</span><span class="o">.</span><span class="n">cKDTree</span><span class="p">(</span><span class="n">master_grid_positions</span><span class="p">,</span> <span class="n">leafsize</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
        <span class="n">points_in_encap_sphere</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="n">tree</span><span class="o">.</span><span class="n">query_ball_point</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">center</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">encapsulating_radius</span> <span class="o">+</span> <span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">gridSpacing</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span>
                <span class="n">return_sorted</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">),</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;GOT POINTS IN SPHERE </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">points_in_encap_sphere</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">point_compartment_ids</span> <span class="o">=</span> <span class="n">compartment_ids</span><span class="p">[</span><span class="n">points_in_encap_sphere</span><span class="p">]</span>
        <span class="c1"># largest compartments need to be created first for this to work</span>
        <span class="n">point_ids_to_assign</span> <span class="o">=</span> <span class="n">points_in_encap_sphere</span><span class="p">[</span>
            <span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">point_compartment_ids</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">number</span>
        <span class="p">]</span>
        <span class="n">point_positions</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float16</span><span class="p">(</span><span class="n">master_grid_positions</span><span class="p">[</span><span class="n">point_ids_to_assign</span><span class="p">])</span>

        <span class="c1"># check surface points</span>
        <span class="n">points_on_surface</span> <span class="o">=</span> <span class="n">trimesh_grid_surface</span><span class="o">.</span><span class="n">is_filled</span><span class="p">(</span><span class="n">point_positions</span><span class="p">)</span>
        <span class="n">compartment_ids</span><span class="p">[</span><span class="n">point_ids_to_assign</span><span class="p">[</span><span class="n">points_on_surface</span><span class="p">]]</span> <span class="o">=</span> <span class="n">number</span>

        <span class="c1"># check inside points</span>
        <span class="n">points_in_mesh</span> <span class="o">=</span> <span class="n">mesh_store</span><span class="o">.</span><span class="n">contains_points_mesh</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gname</span><span class="p">,</span> <span class="n">point_positions</span><span class="p">)</span>

        <span class="n">points_in_mesh</span> <span class="o">=</span> <span class="n">points_in_mesh</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">points_on_surface</span>
        <span class="n">compartment_ids</span><span class="p">[</span><span class="n">point_ids_to_assign</span><span class="p">[</span><span class="n">points_in_mesh</span><span class="p">]]</span> <span class="o">=</span> <span class="o">-</span><span class="n">number</span>
        <span class="n">insidePoints</span> <span class="o">=</span> <span class="n">point_ids_to_assign</span><span class="p">[</span><span class="n">points_in_mesh</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;ASSIGNED INSIDE OUTSIDE&quot;</span><span class="p">)</span>

        <span class="n">nbGridPoints</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">masterGridPositions</span><span class="p">)</span>

        <span class="p">(</span>
            <span class="n">surface_points_in_bounding_box</span><span class="p">,</span>
            <span class="n">surfPtsBBNorms</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_surface_pts_to_fill_box</span><span class="p">(</span><span class="n">off_grid_surface_points</span><span class="p">,</span> <span class="n">env</span><span class="p">)</span>

        <span class="n">off_grid_surface_points</span> <span class="o">=</span> <span class="n">surface_points_in_bounding_box</span>

        <span class="n">ex</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># True if nbGridPoints == len(idarray) else False</span>

        <span class="n">surfacePoints</span><span class="p">,</span> <span class="n">surfacePointsNormals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extendGridArrays</span><span class="p">(</span>
            <span class="n">nbGridPoints</span><span class="p">,</span>
            <span class="n">off_grid_surface_points</span><span class="p">,</span>
            <span class="n">surfPtsBBNorms</span><span class="p">,</span>
            <span class="n">env</span><span class="p">,</span>
            <span class="n">surfacePointsNormals</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">surfacePointsNormals</span><span class="p">,</span>
            <span class="n">extended</span><span class="o">=</span><span class="n">ex</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">insidePoints</span> <span class="o">=</span> <span class="n">insidePoints</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surfacePoints</span> <span class="o">=</span> <span class="n">surfacePoints</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surfacePointsCoords</span> <span class="o">=</span> <span class="n">surface_points_in_bounding_box</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surfacePointsNormals</span> <span class="o">=</span> <span class="n">surfacePointsNormals</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">insidePoints</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">surfacePoints</span></div>


<div class="viewcode-block" id="Compartment.BuildGrid_scanline">
<a class="viewcode-back" href="../../../cellpack.autopack.html#cellpack.autopack.Compartment.Compartment.BuildGrid_scanline">[docs]</a>
    <span class="k">def</span> <span class="nf">BuildGrid_scanline</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">env</span><span class="p">,</span>
        <span class="n">grdPos</span><span class="p">,</span>
        <span class="n">new_distances</span><span class="p">,</span>
        <span class="n">vSurfaceArea</span><span class="p">,</span>
        <span class="n">diag</span><span class="p">,</span>
        <span class="n">srfPts</span><span class="p">,</span>
        <span class="n">idarray</span><span class="p">,</span>
        <span class="n">mesh_store</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Build the compartment grid ie surface and inside point using scanline&quot;&quot;&quot;</span>
        <span class="n">insidePoints</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">number</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number</span>
        <span class="c1"># the main loop</span>
        <span class="c1"># check the first point</span>
        <span class="n">NX</span><span class="p">,</span> <span class="n">NY</span><span class="p">,</span> <span class="n">NZ</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">nbGridPoints</span>
        <span class="c1"># int(k * NX * NY + j * NX + i)</span>
        <span class="n">ptInd</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">coord</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">grdPos</span><span class="o">.</span><span class="n">item</span><span class="p">((</span><span class="n">ptInd</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span>
            <span class="n">grdPos</span><span class="o">.</span><span class="n">item</span><span class="p">((</span><span class="n">ptInd</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span>
            <span class="n">grdPos</span><span class="o">.</span><span class="n">item</span><span class="p">((</span><span class="n">ptInd</span><span class="p">,</span> <span class="mi">2</span><span class="p">)),</span>
        <span class="p">]</span>
        <span class="c1"># is this point inside</span>
        <span class="n">inside</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_point_inside_mesh</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="n">diag</span><span class="p">,</span> <span class="n">mesh_store</span><span class="p">,</span> <span class="n">ray</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">NZ</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">NX</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">NY</span><span class="p">):</span>
                    <span class="n">ptInd</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">k</span> <span class="o">*</span> <span class="n">NX</span> <span class="o">*</span> <span class="n">NY</span> <span class="o">+</span> <span class="n">j</span> <span class="o">*</span> <span class="n">NX</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span>
                    <span class="n">coord</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="n">grdPos</span><span class="o">.</span><span class="n">item</span><span class="p">((</span><span class="n">ptInd</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span>
                        <span class="n">grdPos</span><span class="o">.</span><span class="n">item</span><span class="p">((</span><span class="n">ptInd</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span>
                        <span class="n">grdPos</span><span class="o">.</span><span class="n">item</span><span class="p">((</span><span class="n">ptInd</span><span class="p">,</span> <span class="mi">2</span><span class="p">)),</span>
                    <span class="p">]</span>
                    <span class="n">insideBB</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">checkPointInsideBB</span><span class="p">(</span>
                        <span class="n">coord</span><span class="p">,</span> <span class="n">dist</span><span class="o">=</span><span class="n">new_distances</span><span class="o">.</span><span class="n">item</span><span class="p">(</span><span class="n">ptInd</span><span class="p">)</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="n">insideBB</span><span class="p">:</span>
                        <span class="c1"># check only if close enouhg to surface</span>
                        <span class="k">if</span> <span class="p">(</span>
                            <span class="n">new_distances</span><span class="o">.</span><span class="n">item</span><span class="p">(</span><span class="n">ptInd</span><span class="p">)</span>
                            <span class="o">&lt;</span> <span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">gridSpacing</span> <span class="o">*</span> <span class="mf">1.1547</span> <span class="o">*</span> <span class="mf">2.0</span>
                        <span class="p">):</span>
                            <span class="n">inside</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_point_inside_mesh</span><span class="p">(</span>
                                <span class="n">coord</span><span class="p">,</span> <span class="n">diag</span><span class="p">,</span> <span class="n">mesh_store</span><span class="p">,</span> <span class="n">ray</span><span class="o">=</span><span class="mi">3</span>
                            <span class="p">)</span>
                        <span class="k">if</span> <span class="n">inside</span><span class="p">:</span>
                            <span class="n">insidePoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ptInd</span><span class="p">)</span>
                            <span class="n">idarray</span><span class="o">.</span><span class="n">itemset</span><span class="p">(</span><span class="n">ptInd</span><span class="p">,</span> <span class="o">-</span><span class="n">number</span><span class="p">)</span>
        <span class="n">nbGridPoints</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">masterGridPositions</span><span class="p">)</span>

        <span class="n">surfPtsBB</span><span class="p">,</span> <span class="n">surfPtsBBNorms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_surface_pts_to_fill_box</span><span class="p">(</span><span class="n">srfPts</span><span class="p">,</span> <span class="n">env</span><span class="p">)</span>
        <span class="n">srfPts</span> <span class="o">=</span> <span class="n">surfPtsBB</span>

        <span class="n">ex</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># True if nbGridPoints == len(idarray) else False</span>
        <span class="n">surfacePoints</span><span class="p">,</span> <span class="n">surfacePointsNormals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extendGridArrays</span><span class="p">(</span>
            <span class="n">nbGridPoints</span><span class="p">,</span>
            <span class="n">srfPts</span><span class="p">,</span>
            <span class="n">surfPtsBBNorms</span><span class="p">,</span>
            <span class="n">env</span><span class="p">,</span>
            <span class="n">surfacePointsNormals</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">surfacePointsNormals</span><span class="p">,</span>
            <span class="n">extended</span><span class="o">=</span><span class="n">ex</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">insidePoints</span> <span class="o">=</span> <span class="n">insidePoints</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surfacePoints</span> <span class="o">=</span> <span class="n">surfacePoints</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surfacePointsCoords</span> <span class="o">=</span> <span class="n">surfPtsBB</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surfacePointsNormals</span> <span class="o">=</span> <span class="n">surfacePointsNormals</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">insidePoints</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">surfacePoints</span></div>


<div class="viewcode-block" id="Compartment.BuildGrid_pyray">
<a class="viewcode-back" href="../../../cellpack.autopack.html#cellpack.autopack.Compartment.Compartment.BuildGrid_pyray">[docs]</a>
    <span class="k">def</span> <span class="nf">BuildGrid_pyray</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">env</span><span class="p">,</span>
        <span class="n">ctree</span><span class="p">,</span>
        <span class="n">distances</span><span class="p">,</span>
        <span class="n">grdPos</span><span class="p">,</span>
        <span class="n">diag</span><span class="p">,</span>
        <span class="n">vSurfaceArea</span><span class="p">,</span>
        <span class="n">srfPts</span><span class="p">,</span>
        <span class="n">idarray</span><span class="p">,</span>
        <span class="n">ray</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_box</span><span class="p">:</span>
            <span class="n">nbGridPoints</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">masterGridPositions</span><span class="p">)</span>
            <span class="n">insidePoints</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">getPointsInCube</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bb</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">addSP</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">insidePoints</span><span class="p">:</span>
                <span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">compartment_ids</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">number</span>
            <span class="n">surfPtsBB</span><span class="p">,</span> <span class="n">surfPtsBBNorms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_surface_pts_to_fill_box</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ogsurfacePoints</span><span class="p">,</span> <span class="n">env</span>
            <span class="p">)</span>
            <span class="n">srfPts</span> <span class="o">=</span> <span class="n">surfPtsBB</span>
            <span class="n">surfacePoints</span><span class="p">,</span> <span class="n">surfacePointsNormals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extendGridArrays</span><span class="p">(</span>
                <span class="n">nbGridPoints</span><span class="p">,</span> <span class="n">srfPts</span><span class="p">,</span> <span class="n">surfPtsBBNorms</span><span class="p">,</span> <span class="n">env</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">insidePoints</span> <span class="o">=</span> <span class="n">insidePoints</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">surfacePoints</span> <span class="o">=</span> <span class="n">surfacePoints</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">surfacePointsCoords</span> <span class="o">=</span> <span class="n">surfPtsBB</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">surfacePointsNormals</span> <span class="o">=</span> <span class="n">surfacePointsNormals</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">insidePoints</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">surfacePoints</span>

        <span class="n">number</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number</span>
        <span class="n">insidePoints</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">new_distance</span><span class="p">,</span> <span class="n">nb</span> <span class="o">=</span> <span class="n">ctree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">grdPos</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">wh</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">greater</span><span class="p">(</span><span class="n">distances</span><span class="p">,</span> <span class="n">new_distance</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">closestId</span> <span class="o">=</span> <span class="n">nb</span>
        <span class="n">numpy</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">distances</span><span class="p">,</span> <span class="n">new_distance</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="n">wh</span><span class="p">)</span>
        <span class="c1"># how to get closest triangle ? may help</span>
        <span class="n">helper</span> <span class="o">=</span> <span class="n">autopack</span><span class="o">.</span><span class="n">helper</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span>
        <span class="n">center</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="n">getCenter</span><span class="p">(</span><span class="n">srfPts</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ptInd</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">grdPos</span><span class="p">)):</span>
            <span class="n">inside</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">insideBB</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">checkPointInsideBB</span><span class="p">(</span><span class="n">grdPos</span><span class="p">[</span><span class="n">ptInd</span><span class="p">],</span> <span class="n">dist</span><span class="o">=</span><span class="n">distances</span><span class="p">[</span><span class="n">ptInd</span><span class="p">])</span>
            <span class="n">r</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">insideBB</span><span class="p">:</span>
                <span class="c1"># should use an optional direction for the ray, which will help for unclosed surface....</span>
                <span class="n">intersect</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="n">raycast</span><span class="p">(</span>
                    <span class="n">geom</span><span class="p">,</span>
                    <span class="n">grdPos</span><span class="p">[</span><span class="n">ptInd</span><span class="p">],</span>
                    <span class="n">center</span><span class="p">,</span>
                    <span class="n">diag</span><span class="p">,</span>
                    <span class="n">count</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">vertices</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span>
                    <span class="n">faces</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">faces</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="c1"># intersect, count = helper.raycast(geom, grdPos[ptInd], grdPos[ptInd]+[0.,1.,0.], diag, count = True )</span>
                <span class="n">r</span> <span class="o">=</span> <span class="p">(</span><span class="n">count</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">ray</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="n">intersect2</span><span class="p">,</span> <span class="n">count2</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="n">raycast</span><span class="p">(</span>
                        <span class="n">geom</span><span class="p">,</span>
                        <span class="n">grdPos</span><span class="p">[</span><span class="n">ptInd</span><span class="p">],</span>
                        <span class="n">grdPos</span><span class="p">[</span><span class="n">ptInd</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.1</span><span class="p">],</span>
                        <span class="n">diag</span><span class="p">,</span>
                        <span class="n">count</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="n">vertices</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span>
                        <span class="n">faces</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">faces</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">center</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="n">rotatePoint</span><span class="p">(</span>
                        <span class="n">helper</span><span class="o">.</span><span class="n">ToVec</span><span class="p">(</span><span class="n">center</span><span class="p">),</span>
                        <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
                        <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="mf">33.0</span><span class="p">)],</span>
                    <span class="p">)</span>
                    <span class="n">intersect3</span><span class="p">,</span> <span class="n">count3</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="n">raycast</span><span class="p">(</span>
                        <span class="n">geom</span><span class="p">,</span>
                        <span class="n">grdPos</span><span class="p">[</span><span class="n">ptInd</span><span class="p">],</span>
                        <span class="n">grdPos</span><span class="p">[</span><span class="n">ptInd</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.1</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
                        <span class="n">diag</span><span class="p">,</span>
                        <span class="n">count</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="n">vertices</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span>
                        <span class="n">faces</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">faces</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="c1"># intersect3, count3 = helper.raycast(geom, grdPos[ptInd], center, diag, count = True )#grdPos[ptInd]+[0.,1.1,0.]</span>
                    <span class="k">if</span> <span class="n">r</span><span class="p">:</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">count2</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="p">(</span><span class="n">count3</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">r</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">r</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">r</span><span class="p">:</span>  <span class="c1"># odd inside</span>
                <span class="n">inside</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="n">inside</span><span class="p">:</span>
                    <span class="n">insidePoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ptInd</span><span class="p">)</span>
                    <span class="n">idarray</span><span class="p">[</span><span class="n">ptInd</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">number</span>
            <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">ptInd</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">grdPos</span><span class="p">)))</span> <span class="o">*</span> <span class="mf">100.0</span>

        <span class="n">nbGridPoints</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">masterGridPositions</span><span class="p">)</span>

        <span class="n">surfPtsBB</span><span class="p">,</span> <span class="n">surfPtsBBNorms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_surface_pts_to_fill_box</span><span class="p">(</span><span class="n">srfPts</span><span class="p">,</span> <span class="n">env</span><span class="p">)</span>
        <span class="n">srfPts</span> <span class="o">=</span> <span class="n">surfPtsBB</span>
        <span class="n">ex</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># True if nbGridPoints == len(idarray) else False</span>
        <span class="c1"># back to list type</span>
        <span class="c1"># histoVol.grid.distToClosestSurf = histoVol.grid.distToClosestSurf.tolist()</span>
        <span class="n">surfacePoints</span><span class="p">,</span> <span class="n">surfacePointsNormals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extendGridArrays</span><span class="p">(</span>
            <span class="n">nbGridPoints</span><span class="p">,</span> <span class="n">srfPts</span><span class="p">,</span> <span class="n">surfPtsBBNorms</span><span class="p">,</span> <span class="n">env</span><span class="p">,</span> <span class="n">extended</span><span class="o">=</span><span class="n">ex</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">insidePoints</span> <span class="o">=</span> <span class="n">insidePoints</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surfacePoints</span> <span class="o">=</span> <span class="n">surfacePoints</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surfacePointsCoords</span> <span class="o">=</span> <span class="n">surfPtsBB</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surfacePointsNormals</span> <span class="o">=</span> <span class="n">surfacePointsNormals</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">insidePoints</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">surfacePoints</span></div>


<div class="viewcode-block" id="Compartment.BuildGrid_bhtree">
<a class="viewcode-back" href="../../../cellpack.autopack.html#cellpack.autopack.Compartment.Compartment.BuildGrid_bhtree">[docs]</a>
    <span class="k">def</span> <span class="nf">BuildGrid_bhtree</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">env</span><span class="p">,</span>
        <span class="n">ctree</span><span class="p">,</span>
        <span class="n">grdPos</span><span class="p">,</span>
        <span class="n">new_distances</span><span class="p">,</span>
        <span class="n">diag</span><span class="p">,</span>
        <span class="n">vSurfaceArea</span><span class="p">,</span>
        <span class="n">srfPts</span><span class="p">,</span>
        <span class="n">idarray</span><span class="p">,</span>
        <span class="n">distances</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Build the compartment grid ie surface and inside point&quot;&quot;&quot;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">srfPts</span><span class="p">),</span> <span class="s2">&quot;f&quot;</span><span class="p">)</span>
        <span class="n">dist2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">srfPts</span><span class="p">),</span> <span class="s2">&quot;f&quot;</span><span class="p">)</span>

        <span class="n">number</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number</span>
        <span class="n">ogNormals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ogsurfacePointsNormals</span>
        <span class="n">insidePoints</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">ptInd</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">grdPos</span><span class="p">)):</span>
            <span class="c1"># find closest OGsurfacepoint</span>
            <span class="n">gx</span><span class="p">,</span> <span class="n">gy</span><span class="p">,</span> <span class="n">gz</span> <span class="o">=</span> <span class="n">grdPos</span><span class="p">[</span><span class="n">ptInd</span><span class="p">]</span>
            <span class="n">new_distance</span> <span class="o">=</span> <span class="n">new_distances</span><span class="p">[</span><span class="n">ptInd</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">new_distances</span><span class="p">[</span><span class="n">ptInd</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;ouhoua, closest OGsurfacePoint = -1&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ptInd</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">srfPts</span><span class="p">):</span>
                <span class="n">sx</span><span class="p">,</span> <span class="n">sy</span><span class="p">,</span> <span class="n">sz</span> <span class="o">=</span> <span class="n">srfPts</span><span class="p">[</span><span class="n">ptInd</span><span class="p">]</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">gx</span> <span class="o">-</span> <span class="n">sx</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">gx</span> <span class="o">-</span> <span class="n">sx</span><span class="p">)</span>
                    <span class="o">+</span> <span class="p">(</span><span class="n">gy</span> <span class="o">-</span> <span class="n">sy</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">gy</span> <span class="o">-</span> <span class="n">sy</span><span class="p">)</span>
                    <span class="o">+</span> <span class="p">(</span><span class="n">gz</span> <span class="o">-</span> <span class="n">sz</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">gz</span> <span class="o">-</span> <span class="n">sz</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">n</span> <span class="o">=</span> <span class="n">ctree</span><span class="o">.</span><span class="n">closePointsDist2</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">grdPos</span><span class="p">[</span><span class="n">ptInd</span><span class="p">]),</span> <span class="n">diag</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">dist2</span><span class="p">)</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">dist2</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">n</span><span class="p">])</span>
                    <span class="n">new_distance</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">dist2</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">d</span><span class="p">)]</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="c1"># this is quite long</span>
                    <span class="n">delta</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">srfPts</span><span class="p">)</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">grdPos</span><span class="p">[</span><span class="n">ptInd</span><span class="p">])</span>
                    <span class="n">delta</span> <span class="o">*=</span> <span class="n">delta</span>
                    <span class="n">distA</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">delta</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">distA</span><span class="p">)</span>
                    <span class="n">new_distance</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">distA</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
                <span class="n">sx</span><span class="p">,</span> <span class="n">sy</span><span class="p">,</span> <span class="n">sz</span> <span class="o">=</span> <span class="n">srfPts</span><span class="p">[</span><span class="n">new_distance</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">distances</span><span class="p">[</span><span class="n">ptInd</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">d</span><span class="p">:</span>
                <span class="n">distances</span><span class="p">[</span><span class="n">ptInd</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span>
            <span class="c1"># case a diffent surface ends up being closer in the linear walk through the grid</span>
            <span class="c1"># check if ptInd in inside</span>
            <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">ptInd</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">ogNormals</span><span class="p">):</span>
                <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ogNormals</span><span class="p">[</span><span class="n">ptInd</span><span class="p">])</span>

            <span class="c1"># check on what side of the surface point the grid point is</span>
            <span class="n">vx</span><span class="p">,</span> <span class="n">vy</span><span class="p">,</span> <span class="n">vz</span> <span class="o">=</span> <span class="p">(</span><span class="n">gx</span> <span class="o">-</span> <span class="n">sx</span><span class="p">,</span> <span class="n">gy</span> <span class="o">-</span> <span class="n">sy</span><span class="p">,</span> <span class="n">gz</span> <span class="o">-</span> <span class="n">sz</span><span class="p">)</span>
            <span class="n">dot</span> <span class="o">=</span> <span class="n">vx</span> <span class="o">*</span> <span class="n">nx</span> <span class="o">+</span> <span class="n">vy</span> <span class="o">*</span> <span class="n">ny</span> <span class="o">+</span> <span class="n">vz</span> <span class="o">*</span> <span class="n">nz</span>
            <span class="k">if</span> <span class="n">dot</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># inside</span>
                <span class="c1"># and the point is actually inside the mesh bounding box</span>
                <span class="n">inside</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">checkinside</span><span class="p">:</span>
                    <span class="n">inside</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">checkPointInsideBB</span><span class="p">(</span><span class="n">grdPos</span><span class="p">[</span><span class="n">ptInd</span><span class="p">],</span> <span class="n">dist</span><span class="o">=</span><span class="n">d</span><span class="p">)</span>
                <span class="c1"># this is not working for a plane, or any unclosed compartment...</span>
                <span class="k">if</span> <span class="n">inside</span><span class="p">:</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="n">ptInd</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">idarray</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="p">):</span>  <span class="c1"># Oct 20, 2012 Graham asks: why do we do this if test? not in old code</span>
                        <span class="n">idarray</span><span class="p">[</span><span class="n">ptInd</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">number</span>
                    <span class="n">insidePoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ptInd</span><span class="p">)</span>
                <span class="c1">#                if target2 is not None :</span>
                <span class="c1">#                    afvi.vi.changeObjColorMat(target2,[1,0,0])</span>
                <span class="c1"># sleep(0.01)</span>
                <span class="c1">#            c4d.StatusSetBar(int((ptInd/len(grdPos)*100)))</span>

        <span class="n">nbGridPoints</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">masterGridPositions</span><span class="p">)</span>

        <span class="n">surfPtsBB</span><span class="p">,</span> <span class="n">surfPtsBBNorms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_surface_pts_to_fill_box</span><span class="p">(</span><span class="n">srfPts</span><span class="p">,</span> <span class="n">env</span><span class="p">)</span>
        <span class="n">srfPts</span> <span class="o">=</span> <span class="n">surfPtsBB</span>
        <span class="n">ex</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># True if nbGridPoints == len(idarray) else False</span>
        <span class="n">surfacePoints</span><span class="p">,</span> <span class="n">surfacePointsNormals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extendGridArrays</span><span class="p">(</span>
            <span class="n">nbGridPoints</span><span class="p">,</span>
            <span class="n">srfPts</span><span class="p">,</span>
            <span class="n">surfPtsBBNorms</span><span class="p">,</span>
            <span class="n">env</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">surfacePointsNormals</span><span class="p">,</span>
            <span class="n">extended</span><span class="o">=</span><span class="n">ex</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">insidePoints</span> <span class="o">=</span> <span class="n">insidePoints</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surfacePoints</span> <span class="o">=</span> <span class="n">surfacePoints</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surfacePointsCoords</span> <span class="o">=</span> <span class="n">surfPtsBB</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surfacePointsNormals</span> <span class="o">=</span> <span class="n">surfacePointsNormals</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">insidePoints</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">surfacePoints</span></div>


<div class="viewcode-block" id="Compartment.BuildGrid_kevin">
<a class="viewcode-back" href="../../../cellpack.autopack.html#cellpack.autopack.Compartment.Compartment.BuildGrid_kevin">[docs]</a>
    <span class="k">def</span> <span class="nf">BuildGrid_kevin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">env</span><span class="p">,</span> <span class="n">superFine</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Build the compartment grid ie surface and inside point using flood filling algo from kevin&quot;&quot;&quot;</span>

        <span class="c1"># Graham Sum the SurfaceArea for each polyhedron</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span>
            <span class="p">:</span>
        <span class="p">]</span>  <span class="c1"># NEED to make these limited to selection box, not whole compartment</span>
        <span class="n">faces</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">faces</span><span class="p">[</span>
            <span class="p">:</span>
        <span class="p">]</span>  <span class="c1"># Should be able to use self.ogsurfacePoints and collect faces too from above</span>
        <span class="n">normalList2</span><span class="p">,</span> <span class="n">areas</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getFaceNormals</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span> <span class="n">faces</span><span class="p">,</span> <span class="n">fillBB</span><span class="o">=</span><span class="n">env</span><span class="o">.</span><span class="n">fillBB</span><span class="p">)</span>

        <span class="n">srfPts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ogsurfacePoints</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">OGsrfPtsBht</span> <span class="o">=</span> <span class="n">spatial</span><span class="o">.</span><span class="n">cKDTree</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">srfPts</span><span class="p">),</span> <span class="n">leafsize</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
        <span class="c1"># res = numpy.zeros(len(srfPts),&#39;f&#39;)</span>
        <span class="c1"># dist2 = numpy.zeros(len(srfPts),&#39;f&#39;)</span>

        <span class="c1"># ogNormals = self.ogsurfacePointsNormals</span>
        <span class="n">insidePoints</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># find closest off grid surface point for each grid point</span>
        <span class="c1"># FIXME sould be diag of compartment BB inside fillBB</span>
        <span class="n">grid_point_positions</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">masterGridPositions</span>
        <span class="n">gridPtsPerEdge</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">nbGridPoints</span>
        <span class="n">gridSpacing</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">gridSpacing</span>
        <span class="n">radius</span> <span class="o">=</span> <span class="n">gridSpacing</span>
        <span class="n">boundingBox</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">boundingBox</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">grid</span>
        <span class="c1">#        returnNullIfFail = 0</span>

        <span class="n">helper</span> <span class="o">=</span> <span class="n">autopack</span><span class="o">.</span><span class="n">helper</span>

        <span class="c1"># Pre-allocates a gridPoint object for every single point we have in our grid.</span>
        <span class="n">gridPoints</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">grid_point_positions</span><span class="p">:</span>
            <span class="n">gridPoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gridPoint</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="n">isPolyhedron</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">gridPoints</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid_point_positions</span><span class="p">)</span>

        <span class="c1"># Make a precomputed cube of coordinates and corresponding distances</span>
        <span class="n">distanceCube</span><span class="p">,</span> <span class="n">distX</span><span class="p">,</span> <span class="n">distY</span><span class="p">,</span> <span class="n">distZ</span> <span class="o">=</span> <span class="n">makeMarchingCube</span><span class="p">(</span><span class="n">gridSpacing</span><span class="p">,</span> <span class="n">radius</span><span class="p">)</span>
        <span class="c1"># Flatten and combine these arrays. This is easier to iterate over.</span>
        <span class="n">distanceCubeF</span><span class="p">,</span> <span class="n">distXF</span><span class="p">,</span> <span class="n">distYF</span><span class="p">,</span> <span class="n">distZF</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">distanceCube</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span>
            <span class="n">distX</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span>
            <span class="n">distY</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span>
            <span class="n">distZ</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span>
        <span class="p">)</span>
        <span class="n">zippedNumbers</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">distanceCubeF</span><span class="p">,</span> <span class="n">distXF</span><span class="p">,</span> <span class="n">distYF</span><span class="p">,</span> <span class="n">distZF</span><span class="p">)</span>

        <span class="n">NX</span><span class="p">,</span> <span class="n">NY</span><span class="p">,</span> <span class="n">NZ</span> <span class="o">=</span> <span class="n">gridPtsPerEdge</span>
        <span class="n">OX</span><span class="p">,</span> <span class="n">OY</span><span class="p">,</span> <span class="n">OZ</span> <span class="o">=</span> <span class="n">boundingBox</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">spacing1</span> <span class="o">=</span> <span class="p">(</span>
            <span class="mf">1.0</span> <span class="o">/</span> <span class="n">gridSpacing</span>
        <span class="p">)</span>  <span class="c1"># Inverse of the spacing. We compute this here, so we don&#39;t have to recompute it repeatedly</span>
        <span class="n">allCoordinates</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">[]</span>
        <span class="p">)</span>  <span class="c1"># Tracker for all the fine coordiantes that we have interpolated for the faces of the polyhedron</span>
        <span class="c1"># Walk through the faces, projecting each to the grid and marking immediate neighbors so we can test said</span>
        <span class="c1"># neighbors for inside/outside later.</span>
        <span class="n">helper</span><span class="o">.</span><span class="n">progressBar</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;faces setup&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">face</span> <span class="ow">in</span> <span class="n">faces</span><span class="p">:</span>
            <span class="c1"># Get the vertex coordinates and convert to numpy arrays</span>
            <span class="n">triCoords</span> <span class="o">=</span> <span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vertices</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">face</span><span class="p">]</span>
            <span class="n">thisFaceFineCoords</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">triCoords</span><span class="p">)</span>
            <span class="n">allCoordinates</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">triCoords</span><span class="p">)</span>
            <span class="c1"># Use these u/v vectors to interpolate points that reside on the face</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">triCoords</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">triCoords</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">pos</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">triCoords</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">pos</span>
            <span class="c1"># Smetimes the hypotenuse isn&#39;t fully represented, so use an additional w vector</span>
            <span class="c1"># to interpolate points on the hypotenuse</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">triCoords</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">triCoords</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># If either u or v is greater than the grid spacing, then we need to subdivide it</span>
            <span class="c1"># We will use ceil: if we have a u of length 16, and grid spacing of 5, then we want</span>
            <span class="c1"># a u at 0, 5, 10, 15 which is [0, 1, 2, 3] * gridSpacing.</span>

            <span class="c1"># Using the default gridspacing, some faces will produce leakage. Instead, we</span>
            <span class="c1"># use a denser gridspacing to interpolate, and then project these points back our original spacing.</span>
            <span class="c1"># We&#39;ll decrease the gridspacing by 67% (so that it&#39;s 33% of the original). This seems be the</span>
            <span class="c1"># highest we can push this without leakage on edge cases.</span>
            <span class="n">gridSpacingTempFine</span> <span class="o">=</span> <span class="n">gridSpacing</span> <span class="o">/</span> <span class="mi">3</span>
            <span class="c1"># Determine the number of grid spacing-sized points we can fit on each vector.</span>
            <span class="c1"># Minimum is one because range(1) gives us [0]</span>
            <span class="n">uSubunits</span><span class="p">,</span> <span class="n">vSubunits</span><span class="p">,</span> <span class="n">wSubunits</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">vlen</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">gridSpacingTempFine</span><span class="p">:</span>
                <span class="n">uSubunits</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">vlen</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">/</span> <span class="n">gridSpacingTempFine</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">vlen</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">gridSpacingTempFine</span><span class="p">:</span>
                <span class="n">vSubunits</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">vlen</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">/</span> <span class="n">gridSpacingTempFine</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">vlen</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">gridSpacingTempFine</span><span class="p">:</span>
                <span class="n">wSubunits</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">vlen</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">/</span> <span class="n">gridSpacingTempFine</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="c1"># Because we have observed leakage, maybe we want to try trying a denser interpolation, using numpy&#39;s linspace?</span>
            <span class="c1"># Interpolate face of triangle into a fine mesh.</span>
            <span class="k">for</span> <span class="n">uSub</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">uSubunits</span><span class="p">)):</span>
                <span class="n">percentU</span> <span class="o">=</span> <span class="n">uSub</span> <span class="o">*</span> <span class="n">gridSpacingTempFine</span> <span class="o">/</span> <span class="n">vlen</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
                <span class="n">percentU</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                    <span class="n">percentU</span><span class="p">,</span> <span class="mf">1.0</span>
                <span class="p">)</span>  <span class="c1"># Make sure that we have not stepped outside of our original u vector</span>
                <span class="c1"># h represents the height of the hypotenuse at this u. Naturally, we cannot go past the hypotenuse, so this will be</span>
                <span class="c1"># our upper bound.</span>
                <span class="n">h</span> <span class="o">=</span> <span class="n">percentU</span> <span class="o">*</span> <span class="n">u</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">percentU</span><span class="p">)</span> <span class="o">*</span> <span class="n">v</span>
                <span class="k">for</span> <span class="n">vSub</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">vSubunits</span><span class="p">)):</span>
                    <span class="n">percentV</span> <span class="o">=</span> <span class="n">vSub</span> <span class="o">*</span> <span class="n">gridSpacingTempFine</span> <span class="o">/</span> <span class="n">vlen</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                    <span class="n">percentV</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                        <span class="n">percentV</span><span class="p">,</span> <span class="mf">1.0</span>
                    <span class="p">)</span>  <span class="c1"># Make sure that we have not stepped oustide of our original v vector.</span>
                    <span class="n">interpolatedPoint</span> <span class="o">=</span> <span class="n">percentU</span> <span class="o">*</span> <span class="n">u</span> <span class="o">+</span> <span class="n">percentV</span> <span class="o">*</span> <span class="n">v</span>
                    <span class="c1"># The original if: statement asks if the distance from the origin to the interpolated point is less than</span>
                    <span class="c1"># the distance from the origin to the hypotenuse point, as such:</span>
                    <span class="c1"># if vlen(interpolatedPoint) &lt; vlen(h):</span>
                    <span class="c1"># Wouldn&#39;t it be a better idea to measure distance to the u position instead? This is implemented below.</span>
                    <span class="k">if</span> <span class="n">vlen</span><span class="p">(</span><span class="n">interpolatedPoint</span> <span class="o">-</span> <span class="n">percentU</span> <span class="o">*</span> <span class="n">u</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">vlen</span><span class="p">(</span><span class="n">h</span> <span class="o">-</span> <span class="n">percentU</span> <span class="o">*</span> <span class="n">u</span><span class="p">):</span>
                        <span class="n">allCoordinates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">interpolatedPoint</span> <span class="o">+</span> <span class="n">pos</span><span class="p">)</span>
                        <span class="n">thisFaceFineCoords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">interpolatedPoint</span> <span class="o">+</span> <span class="n">pos</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">break</span>
            <span class="c1"># Interpolate the hypotenuse of the triangle into a fine mesh. Prevents leakage.</span>
            <span class="k">for</span> <span class="n">wSub</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">wSubunits</span><span class="p">)):</span>
                <span class="c1"># Apply the same proceudre we did above for u/v, just for w (for hypotenuse interpolation)</span>
                <span class="n">percentW</span> <span class="o">=</span> <span class="n">wSub</span> <span class="o">*</span> <span class="n">gridSpacingTempFine</span> <span class="o">/</span> <span class="n">vlen</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
                <span class="n">percentW</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">percentW</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
                <span class="n">interpolatedPoint</span> <span class="o">=</span> <span class="n">percentW</span> <span class="o">*</span> <span class="n">w</span>
                <span class="n">allCoordinates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">interpolatedPoint</span> <span class="o">+</span> <span class="n">triCoords</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">thisFaceFineCoords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">interpolatedPoint</span> <span class="o">+</span> <span class="n">triCoords</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="c1"># Once we have interpolated the face, let&#39;s project each fine interpolated point to the grid.</span>
            <span class="n">projectedIndices</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">thisFaceFineCoords</span><span class="p">:</span>
                <span class="c1"># Not sure if we need to flip the coordinates. Let&#39;s not flip them for now.</span>
                <span class="n">projectedPointIndex</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">getPointFrom3D</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span>
                <span class="n">projectedIndices</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">projectedPointIndex</span><span class="p">)</span>

            <span class="c1"># Walk through each grid point that our face spans, gather its closest neighbors, annotate them with</span>
            <span class="c1"># minimum distance and closest faces, &amp; flag them for testing inside/outside later.</span>
            <span class="k">for</span> <span class="n">P</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">projectedIndices</span><span class="p">):</span>
                <span class="c1"># Get the point object corresponding to the index, and set its polyhedron attribute to true</span>
                <span class="n">g</span> <span class="o">=</span> <span class="n">gridPoints</span><span class="p">[</span><span class="n">P</span><span class="p">]</span>
                <span class="n">g</span><span class="o">.</span><span class="n">representsPolyhedron</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="c1"># Get the coordinates of the point, and convert them to grid units</span>
                <span class="c1"># Again, not sure if RH or LH coordinate system. Let&#39;s try RH for now.</span>
                <span class="n">xTemp</span><span class="p">,</span> <span class="n">yTemp</span><span class="p">,</span> <span class="n">zTemp</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">globalCoord</span>
                <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="nb">round</span><span class="p">((</span><span class="n">xTemp</span> <span class="o">-</span> <span class="n">OX</span><span class="p">)</span> <span class="o">*</span> <span class="n">spacing1</span><span class="p">),</span>
                    <span class="nb">round</span><span class="p">((</span><span class="n">yTemp</span> <span class="o">-</span> <span class="n">OY</span><span class="p">)</span> <span class="o">*</span> <span class="n">spacing1</span><span class="p">),</span>
                    <span class="nb">round</span><span class="p">((</span><span class="n">zTemp</span> <span class="o">-</span> <span class="n">OZ</span><span class="p">)</span> <span class="o">*</span> <span class="n">spacing1</span><span class="p">),</span>
                <span class="p">)</span>
                <span class="c1"># Let&#39;s step through our distance cube, and assign faces/closest distances to each</span>
                <span class="k">for</span> <span class="n">d</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">zippedNumbers</span><span class="p">:</span>
                    <span class="c1"># Get the grid indices for the point we&#39;re considering, and pass if we&#39;re stepping oustide the boundaries</span>
                    <span class="n">newI</span><span class="p">,</span> <span class="n">newJ</span><span class="p">,</span> <span class="n">newK</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">x</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="n">k</span> <span class="o">+</span> <span class="n">z</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="n">newI</span> <span class="o">&lt;</span> <span class="mi">0</span>
                        <span class="ow">or</span> <span class="n">newI</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">NX</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                        <span class="ow">or</span> <span class="n">newJ</span> <span class="o">&lt;</span> <span class="mi">0</span>
                        <span class="ow">or</span> <span class="n">newJ</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">NY</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                        <span class="ow">or</span> <span class="n">newK</span> <span class="o">&lt;</span> <span class="mi">0</span>
                        <span class="ow">or</span> <span class="n">newK</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">NZ</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="p">):</span>
                        <span class="k">continue</span>
                    <span class="c1"># Get the point index that this coordinate corresponds to.</span>
                    <span class="n">desiredPointIndex</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">newK</span> <span class="o">*</span> <span class="n">NX</span> <span class="o">*</span> <span class="n">NY</span> <span class="o">+</span> <span class="n">newJ</span> <span class="o">*</span> <span class="n">NX</span> <span class="o">+</span> <span class="n">newI</span><span class="p">))</span>
                    <span class="n">desiredPoint</span> <span class="o">=</span> <span class="n">gridPoints</span><span class="p">[</span><span class="n">desiredPointIndex</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">desiredPoint</span><span class="o">.</span><span class="n">representsPolyhedron</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="c1"># Add the current face to the its list of closest faces</span>
                    <span class="k">if</span> <span class="n">face</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">desiredPoint</span><span class="o">.</span><span class="n">closeFaces</span><span class="p">:</span>
                        <span class="n">desiredPoint</span><span class="o">.</span><span class="n">closeFaces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">face</span><span class="p">)</span>
                    <span class="c1"># Add the distance to the point&#39;s list of distances, and overwrite minimum distance if appropriate</span>
                    <span class="n">desiredPoint</span><span class="o">.</span><span class="n">allDistances</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">v</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="n">desiredPoint</span><span class="o">.</span><span class="n">minDistance</span><span class="p">:</span>
                        <span class="n">desiredPoint</span><span class="o">.</span><span class="n">minDistance</span> <span class="o">=</span> <span class="n">d</span>
                        <span class="c1"># Later down the road, we want to test as few points as possible for inside/outside. Therefore,</span>
                        <span class="c1"># we will only test points that are</span>
                        <span class="c1"># if abs(x) &lt;= 1 and abs(y) &lt;= 1 and abs(z) &lt;= 1:</span>
                        <span class="c1">#     pointsToTestInsideOutside.add(desiredPointIndex)</span>

        <span class="c1"># Let&#39;s start flood filling in inside outside. Here&#39;s the general algorithm:</span>
        <span class="c1"># Walk through all the points in our grid. Once we encounter a point that has closest faces,</span>
        <span class="c1"># then we know we need to test it for inside/outside. Once we test that for inside/outside, we</span>
        <span class="c1"># fill in all previous points with that same inside outisde property. To account for the possible</span>
        <span class="c1"># situation that there is a surface that is only partially bound by the bbox, then we need to</span>
        <span class="c1"># reset the insideOutsideTracker every time we have a change in more than 1 of the 3 coordinates</span>
        <span class="c1"># because that indicates we&#39;re starting a new row/column of points.</span>

        <span class="n">isOutsideTracker</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># This tracks the points that we&#39;ve iterated over which we do not know if inside/outside.</span>
        <span class="c1"># Resets every time we find an inside/outside.</span>
        <span class="n">emptyPointIndicies</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">mismatchCounter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">gridPoints</span><span class="p">:</span>
            <span class="c1"># Check if we&#39;ve started a new line. If so, then we reset everything.</span>
            <span class="c1"># This test should precede all other test, because we don&#39;t want old knowldge</span>
            <span class="c1"># to carry over to the new line, since we don&#39;t know if the polygon is only partially encapsulated by the bounding box.</span>
            <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">index</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># We can&#39;t check the first element, so we can skip it.</span>
                <span class="n">coordDiff</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">globalCoord</span> <span class="o">-</span> <span class="n">gridPoints</span><span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">globalCoord</span>
                <span class="n">coordDiffNonzero</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">coordDiff</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">coordDiffNonzero</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># assert len(emptyPointIndicies) == 0 # When starting a new line, we shouldn&#39;t have any unknowns from the previous line</span>
                    <span class="n">isOutsideTracker</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="n">emptyPointIndicies</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># There&#39;s no point testing inside/outside for points that are on the surface.</span>
            <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">representsPolyhedron</span><span class="p">:</span>
                <span class="n">g</span><span class="o">.</span><span class="n">isOutside</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">closeFaces</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># If it&#39;s not close to any faces, and we don&#39;t know if this row is inside/outside, then</span>
                <span class="c1"># we have to wait till later to figure it out</span>
                <span class="k">if</span> <span class="n">isOutsideTracker</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">emptyPointIndicies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
                <span class="c1"># However, if we do know , we can just use the previous one to fill</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">g</span><span class="o">.</span><span class="n">isOutside</span> <span class="o">=</span> <span class="n">isOutsideTracker</span>
                    <span class="c1"># If there are close faces attached to it, then we need to test it for inside/outside.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Find centroid of all the vertices of all the close faces. This will be our endpoint</span>
                <span class="c1"># when casting a ray for collision testing.</span>
                <span class="n">uniquePoints</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="c1"># This takes just the first face and projects to the center of it.</span>
                <span class="c1"># [uniquePoints.append(x) for x in g.closeFaces[0] if x not in uniquePoints]</span>
                <span class="p">[</span>
                    <span class="n">uniquePoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">closeFaces</span><span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">closestFaceIndex</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">uniquePoints</span>
                <span class="p">]</span>
                <span class="n">uniquePointsCoords</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[</span><span class="n">uniquePoints</span><span class="p">]</span>
                <span class="n">endPoint</span> <span class="o">=</span> <span class="n">findPointsCenter</span><span class="p">(</span><span class="n">uniquePointsCoords</span><span class="p">)</span>
                <span class="n">g</span><span class="o">.</span><span class="n">testedEndpoint</span> <span class="o">=</span> <span class="n">endPoint</span>

                <span class="c1"># Draw a ray to that point, and see if we hit a backface or not</span>
                <span class="n">numHits</span><span class="p">,</span> <span class="n">thisBackFace</span> <span class="o">=</span> <span class="n">f_ray_intersect_polyhedron</span><span class="p">(</span>
                    <span class="n">g</span><span class="o">.</span><span class="n">globalCoord</span><span class="p">,</span> <span class="n">endPoint</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">closeFaces</span><span class="p">,</span> <span class="n">vertices</span><span class="p">,</span> <span class="kc">False</span>
                <span class="p">)</span>

                <span class="c1"># We can check the other face as well if we want to be super precise. If they dont&#39; agree, we then check against the entire polyhedron.</span>
                <span class="c1"># We have not found any cases in which this is necessary, but it is included just in case.</span>
                <span class="k">if</span> <span class="n">superFine</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">closeFaces</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">uniquePoints2</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="p">[</span>
                            <span class="n">uniquePoints2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">closeFaces</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                            <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">uniquePoints2</span>
                        <span class="p">]</span>
                        <span class="n">uniquePointsCoords2</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[</span><span class="n">uniquePoints2</span><span class="p">]</span>
                        <span class="n">endPoint2</span> <span class="o">=</span> <span class="n">findPointsCenter</span><span class="p">(</span><span class="n">uniquePointsCoords2</span><span class="p">)</span>
                        <span class="n">numHits2</span><span class="p">,</span> <span class="n">thisBackFace2</span> <span class="o">=</span> <span class="n">f_ray_intersect_polyhedron</span><span class="p">(</span>
                            <span class="n">g</span><span class="o">.</span><span class="n">globalCoord</span><span class="p">,</span>
                            <span class="n">endPoint2</span><span class="p">,</span>
                            <span class="n">g</span><span class="o">.</span><span class="n">closeFaces</span><span class="p">,</span>
                            <span class="n">vertices</span><span class="p">,</span>
                            <span class="kc">False</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">closeFaces</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">thisBackFace</span> <span class="o">!=</span> <span class="n">thisBackFace2</span><span class="p">:</span>
                        <span class="n">mismatchCounter</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="n">numHits</span><span class="p">,</span> <span class="n">thisBackFace</span> <span class="o">=</span> <span class="n">f_ray_intersect_polyhedron</span><span class="p">(</span>
                            <span class="n">g</span><span class="o">.</span><span class="n">globalCoord</span><span class="p">,</span>
                            <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]),</span>
                            <span class="n">faces</span><span class="p">,</span>
                            <span class="n">vertices</span><span class="p">,</span>
                            <span class="kc">False</span><span class="p">,</span>
                        <span class="p">)</span>

                <span class="c1"># Fill in inside outside attribute for this point, as pRayStartPos, pRayEndPos, faces, vertices, pTruncateToSegmentll as for any points before it</span>
                <span class="n">g</span><span class="o">.</span><span class="n">isOutside</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">thisBackFace</span>
                <span class="n">isOutsideTracker</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">thisBackFace</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">emptyPointIndicies</span><span class="p">:</span>
                    <span class="n">gridPoints</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">isOutside</span> <span class="o">=</span> <span class="n">isOutsideTracker</span>
                <span class="c1"># Because we have filled in all the unknowns, we can reset that counter.</span>
                <span class="n">emptyPointIndicies</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Final pass through for sanity checks.</span>
        <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">gridPoints</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">representsPolyhedron</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">g</span><span class="o">.</span><span class="n">isOutside</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">isOutside</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">g</span><span class="o">.</span><span class="n">isOutside</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">insidePoints</span> <span class="o">=</span> <span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">globalCoord</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">gridPoints</span> <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">isOutside</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">]</span>
        <span class="c1"># outsidePoints = [g.index for g in gridPoints if g.isOutside == True]</span>
        <span class="c1">#        surfacePoints = [g.globalCoord for g in gridPoints if g.representsPolyhedron == True]</span>

        <span class="n">nbGridPoints</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">masterGridPositions</span><span class="p">)</span>

        <span class="n">surfPtsBB</span><span class="p">,</span> <span class="n">surfPtsBBNorms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_surface_pts_to_fill_box</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ogsurfacePoints</span><span class="p">,</span> <span class="n">env</span>
        <span class="p">)</span>
        <span class="n">srfPts</span> <span class="o">=</span> <span class="n">surfPtsBB</span>

        <span class="n">ex</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># True if nbGridPoints == len(idarray) else False</span>
        <span class="n">surfacePoints</span><span class="p">,</span> <span class="n">surfacePointsNormals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extendGridArrays</span><span class="p">(</span>
            <span class="n">nbGridPoints</span><span class="p">,</span> <span class="n">srfPts</span><span class="p">,</span> <span class="n">surfPtsBBNorms</span><span class="p">,</span> <span class="n">env</span><span class="p">,</span> <span class="n">extended</span><span class="o">=</span><span class="n">ex</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">insidePoints</span> <span class="o">=</span> <span class="n">insidePoints</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surfacePoints</span> <span class="o">=</span> <span class="n">surfacePoints</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surfacePointsCoords</span> <span class="o">=</span> <span class="n">surfPtsBB</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surfacePointsNormals</span> <span class="o">=</span> <span class="n">surfacePointsNormals</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">insidePoints</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">surfacePoints</span></div>


<div class="viewcode-block" id="Compartment.extendGridArrays">
<a class="viewcode-back" href="../../../cellpack.autopack.html#cellpack.autopack.Compartment.Compartment.extendGridArrays">[docs]</a>
    <span class="k">def</span> <span class="nf">extendGridArrays</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">nbGridPoints</span><span class="p">,</span>
        <span class="n">off_grid_surface_pts</span><span class="p">,</span>
        <span class="n">surfPtsBBNorms</span><span class="p">,</span>
        <span class="n">env</span><span class="p">,</span>
        <span class="n">surfacePointsNormals</span><span class="p">,</span>
        <span class="n">extended</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extend the environment grd using the compartment point&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">extended</span><span class="p">:</span>
            <span class="n">number_off_grid_pts</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">off_grid_surface_pts</span><span class="p">)</span>
            <span class="n">pointArrayRaw</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nbGridPoints</span> <span class="o">+</span> <span class="n">number_off_grid_pts</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="s2">&quot;f&quot;</span><span class="p">)</span>
            <span class="n">pointArrayRaw</span><span class="p">[:</span><span class="n">nbGridPoints</span><span class="p">]</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">masterGridPositions</span>
            <span class="n">pointArrayRaw</span><span class="p">[</span><span class="n">nbGridPoints</span><span class="p">:]</span> <span class="o">=</span> <span class="n">off_grid_surface_pts</span>
            <span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">nbSurfacePoints</span> <span class="o">+=</span> <span class="n">number_off_grid_pts</span>
            <span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">masterGridPositions</span> <span class="o">=</span> <span class="n">pointArrayRaw</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">distToClosestSurf</span><span class="p">)</span> <span class="o">==</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
                <span class="c1"># histoVol.grid.distToClosestSurf = numpy.append(histoVol.grid.distToClosestSurf,numpy.array([histoVol.grid.diag,]*length ))</span>
                <span class="n">distCS</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">number_off_grid_pts</span><span class="p">)</span> <span class="o">*</span> <span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">diag</span>
                <span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">distToClosestSurf</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">distToClosestSurf</span><span class="p">,</span> <span class="n">distCS</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">distToClosestSurf</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">number_off_grid_pts</span><span class="p">)</span> <span class="o">*</span> <span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">diag</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                <span class="p">)</span>
            <span class="n">ptId</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">number_off_grid_pts</span><span class="p">,</span> <span class="s2">&quot;i&quot;</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">number</span>  <span class="c1"># surface point</span>
            <span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">compartment_ids</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">compartment_ids</span><span class="p">,</span> <span class="n">ptId</span><span class="p">))</span>
            <span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">free_points</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nbGridPoints</span> <span class="o">+</span> <span class="n">number_off_grid_pts</span><span class="p">)</span>
            <span class="n">surfacePoints</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                <span class="nb">range</span><span class="p">(</span><span class="n">nbGridPoints</span><span class="p">,</span> <span class="n">nbGridPoints</span> <span class="o">+</span> <span class="n">number_off_grid_pts</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">surfPtsBBNorms</span><span class="p">):</span>
                <span class="n">surfacePointsNormals</span><span class="p">[</span><span class="n">nbGridPoints</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">number_off_grid_pts</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">off_grid_surface_pts</span><span class="p">)</span>
            <span class="n">pointArrayRaw</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">masterGridPositions</span>
            <span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">nbSurfacePoints</span> <span class="o">+=</span> <span class="n">number_off_grid_pts</span>
            <span class="n">surfacePoints</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                <span class="nb">range</span><span class="p">(</span><span class="n">nbGridPoints</span> <span class="o">-</span> <span class="n">number_off_grid_pts</span><span class="p">,</span> <span class="n">nbGridPoints</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">surfPtsBBNorms</span><span class="p">):</span>
                <span class="n">surfacePointsNormals</span><span class="p">[</span><span class="n">nbGridPoints</span> <span class="o">-</span> <span class="n">number_off_grid_pts</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span>
        <span class="k">return</span> <span class="n">surfacePoints</span><span class="p">,</span> <span class="n">surfacePointsNormals</span></div>


<div class="viewcode-block" id="Compartment.filter_surface_pts_to_fill_box">
<a class="viewcode-back" href="../../../cellpack.autopack.html#cellpack.autopack.Compartment.Compartment.filter_surface_pts_to_fill_box">[docs]</a>
    <span class="k">def</span> <span class="nf">filter_surface_pts_to_fill_box</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">off_grid_pos</span><span class="p">,</span> <span class="n">env</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;get the bounding box from the environment grid that encapsulated the mesh&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">highresVertices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">off_grid_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">highresVertices</span>
        <span class="n">surface_points_positions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">surfPtsBBNorms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">bottom_corner</span><span class="p">,</span> <span class="n">top_corner</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">fillBB</span>
        <span class="n">mx</span><span class="p">,</span> <span class="n">my</span><span class="p">,</span> <span class="n">mz</span> <span class="o">=</span> <span class="n">bottom_corner</span>
        <span class="n">Mx</span><span class="p">,</span> <span class="n">My</span><span class="p">,</span> <span class="n">Mz</span> <span class="o">=</span> <span class="n">top_corner</span>
        <span class="n">off_grid_normals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ogsurfacePointsNormals</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">off_grid_pos</span><span class="p">):</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">p</span>
            <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="n">mx</span> <span class="ow">and</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">Mx</span> <span class="ow">and</span> <span class="n">y</span> <span class="o">&gt;=</span> <span class="n">my</span> <span class="ow">and</span> <span class="n">y</span> <span class="o">&lt;=</span> <span class="n">My</span> <span class="ow">and</span> <span class="n">z</span> <span class="o">&gt;=</span> <span class="n">mz</span> <span class="ow">and</span> <span class="n">z</span> <span class="o">&lt;=</span> <span class="n">Mz</span><span class="p">:</span>
                <span class="n">surface_points_positions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
                <span class="n">surfPtsBBNorms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">off_grid_normals</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">surface_points_positions</span><span class="p">,</span> <span class="n">surfPtsBBNorms</span></div>


<div class="viewcode-block" id="Compartment.BuildGridEnviroOnly">
<a class="viewcode-back" href="../../../cellpack.autopack.html#cellpack.autopack.Compartment.Compartment.BuildGridEnviroOnly">[docs]</a>
    <span class="k">def</span> <span class="nf">BuildGridEnviroOnly</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">env</span><span class="p">,</span> <span class="n">location</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Build the compartment grid ie surface and inside only environment&quot;&quot;&quot;</span>
        <span class="c1"># create surface points</span>
        <span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">createSurfacePoints</span><span class="p">(</span><span class="n">maxl</span><span class="o">=</span><span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">gridSpacing</span><span class="p">)</span>

        <span class="c1"># Graham Sum the SurfaceArea for each polyhedron</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span>
        <span class="p">)</span>  <span class="c1"># NEED to make these limited to selection box, not whole compartment</span>
        <span class="n">faces</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">faces</span>
        <span class="p">)</span>  <span class="c1"># Should be able to use self.ogsurfacePoints and collect faces too from above</span>
        <span class="n">normalList2</span><span class="p">,</span> <span class="n">areas</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getFaceNormals</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span> <span class="n">faces</span><span class="p">,</span> <span class="n">fillBB</span><span class="o">=</span><span class="n">env</span><span class="o">.</span><span class="n">fillBB</span><span class="p">)</span>

        <span class="n">distances</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">distToClosestSurf</span>
        <span class="n">idarray</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">compartment_ids</span>
        <span class="c1">#        diag = histoVol.grid.diag</span>

        <span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>
        <span class="n">srfPts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ogsurfacePoints</span>
        <span class="n">number</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number</span>
        <span class="n">ogNormals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ogsurfacePointsNormals</span>
        <span class="n">insidePoints</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># find closest off grid surface point for each grid point</span>
        <span class="c1"># FIXME sould be diag of compartment BB inside fillBB</span>
        <span class="n">grdPos</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">masterGridPositions</span>
        <span class="c1">#        returnNullIfFail = 0</span>
        <span class="n">closest</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># bht.closestPointsArray(grdPos, diag, returnNullIfFail)</span>

        <span class="k">def</span> <span class="nf">distanceLoop</span><span class="p">(</span>
            <span class="n">ptInd</span><span class="p">,</span>
            <span class="n">distances</span><span class="p">,</span>
            <span class="n">grdPos</span><span class="p">,</span>
            <span class="n">closest</span><span class="p">,</span>
            <span class="n">srfPts</span><span class="p">,</span>
            <span class="n">ogNormals</span><span class="p">,</span>
            <span class="n">idarray</span><span class="p">,</span>
            <span class="n">insidePoints</span><span class="p">,</span>
            <span class="n">number</span><span class="p">,</span>
        <span class="p">):</span>
            <span class="c1"># find closest OGsurfacepoint</span>
            <span class="n">gx</span><span class="p">,</span> <span class="n">gy</span><span class="p">,</span> <span class="n">gz</span> <span class="o">=</span> <span class="n">grdPos</span><span class="p">[</span><span class="n">ptInd</span><span class="p">]</span>
            <span class="n">sptInd</span> <span class="o">=</span> <span class="n">closest</span><span class="p">[</span><span class="n">ptInd</span><span class="p">]</span>
            <span class="c1"># if closest[ptInd] == -1:</span>
            <span class="c1">#     pdb.set_trace()</span>
            <span class="n">sx</span><span class="p">,</span> <span class="n">sy</span><span class="p">,</span> <span class="n">sz</span> <span class="o">=</span> <span class="n">srfPts</span><span class="p">[</span><span class="n">sptInd</span><span class="p">]</span>

            <span class="c1"># update distance field</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
                <span class="p">(</span><span class="n">gx</span> <span class="o">-</span> <span class="n">sx</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">gx</span> <span class="o">-</span> <span class="n">sx</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">gy</span> <span class="o">-</span> <span class="n">sy</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">gy</span> <span class="o">-</span> <span class="n">sy</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">gz</span> <span class="o">-</span> <span class="n">sz</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">gz</span> <span class="o">-</span> <span class="n">sz</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">distances</span><span class="p">[</span><span class="n">ptInd</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">d</span><span class="p">:</span>
                <span class="n">distances</span><span class="p">[</span><span class="n">ptInd</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span>

            <span class="c1"># check if ptInd in inside</span>
            <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span> <span class="o">=</span> <span class="n">ogNormals</span><span class="p">[</span><span class="n">sptInd</span><span class="p">]</span>
            <span class="c1"># check on what side of the surface point the grid point is</span>
            <span class="n">vx</span><span class="p">,</span> <span class="n">vy</span><span class="p">,</span> <span class="n">vz</span> <span class="o">=</span> <span class="p">(</span><span class="n">gx</span> <span class="o">-</span> <span class="n">sx</span><span class="p">,</span> <span class="n">gy</span> <span class="o">-</span> <span class="n">sy</span><span class="p">,</span> <span class="n">gz</span> <span class="o">-</span> <span class="n">sz</span><span class="p">)</span>
            <span class="n">dot</span> <span class="o">=</span> <span class="n">vx</span> <span class="o">*</span> <span class="n">nx</span> <span class="o">+</span> <span class="n">vy</span> <span class="o">*</span> <span class="n">ny</span> <span class="o">+</span> <span class="n">vz</span> <span class="o">*</span> <span class="n">nz</span>
            <span class="k">if</span> <span class="n">dot</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># inside</span>
                <span class="n">idarray</span><span class="p">[</span><span class="n">ptInd</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">number</span>
                <span class="n">insidePoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ptInd</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">location</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="p">[</span>
                <span class="n">distanceLoop</span><span class="p">(</span>
                    <span class="n">x</span><span class="p">,</span>
                    <span class="n">distances</span><span class="p">,</span>
                    <span class="n">grdPos</span><span class="p">,</span>
                    <span class="n">closest</span><span class="p">,</span>
                    <span class="n">srfPts</span><span class="p">,</span>
                    <span class="n">ogNormals</span><span class="p">,</span>
                    <span class="n">idarray</span><span class="p">,</span>
                    <span class="n">insidePoints</span><span class="p">,</span>
                    <span class="n">number</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">grdPos</span><span class="p">))</span>
            <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">insidePoints</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">grdPos</span><span class="p">)))</span>
            <span class="k">for</span> <span class="n">ptInd</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">grdPos</span><span class="p">)):</span>
                <span class="n">distances</span><span class="p">[</span><span class="n">ptInd</span><span class="p">]</span> <span class="o">=</span> <span class="mf">99999.0</span>
                <span class="n">idarray</span><span class="p">[</span><span class="n">ptInd</span><span class="p">]</span> <span class="o">=</span> <span class="n">location</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;time to update distance field and idarray&quot;</span><span class="p">,</span> <span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">t1</span><span class="p">)</span>

        <span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>
        <span class="n">nbGridPoints</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">masterGridPositions</span><span class="p">)</span>

        <span class="n">surfPtsBB</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">surfPtsBBNorms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">mini</span><span class="p">,</span> <span class="n">maxi</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">fillBB</span>
        <span class="n">mx</span><span class="p">,</span> <span class="n">my</span><span class="p">,</span> <span class="n">mz</span> <span class="o">=</span> <span class="n">mini</span>
        <span class="n">Mx</span><span class="p">,</span> <span class="n">My</span><span class="p">,</span> <span class="n">Mz</span> <span class="o">=</span> <span class="n">maxi</span>
        <span class="n">ogNorms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ogsurfacePointsNormals</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">srfPts</span><span class="p">):</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">p</span>
            <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="n">mx</span> <span class="ow">and</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">Mx</span> <span class="ow">and</span> <span class="n">y</span> <span class="o">&gt;=</span> <span class="n">my</span> <span class="ow">and</span> <span class="n">y</span> <span class="o">&lt;=</span> <span class="n">My</span> <span class="ow">and</span> <span class="n">z</span> <span class="o">&gt;=</span> <span class="n">mz</span> <span class="ow">and</span> <span class="n">z</span> <span class="o">&lt;=</span> <span class="n">Mz</span><span class="p">:</span>
                <span class="n">surfPtsBB</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
                <span class="n">surfPtsBBNorms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ogNorms</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;surf points going from to </span><span class="si">%d</span><span class="s2"> </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">srfPts</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">surfPtsBB</span><span class="p">))</span>
        <span class="n">srfPts</span> <span class="o">=</span> <span class="n">surfPtsBB</span>
        <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">srfPts</span><span class="p">)</span>

        <span class="n">pointArrayRaw</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nbGridPoints</span> <span class="o">+</span> <span class="n">length</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="s2">&quot;f&quot;</span><span class="p">)</span>
        <span class="n">pointArrayRaw</span><span class="p">[:</span><span class="n">nbGridPoints</span><span class="p">]</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">masterGridPositions</span>
        <span class="n">pointArrayRaw</span><span class="p">[</span><span class="n">nbGridPoints</span><span class="p">:]</span> <span class="o">=</span> <span class="n">srfPts</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surfacePointsCoords</span> <span class="o">=</span> <span class="n">srfPts</span>
        <span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">nbSurfacePoints</span> <span class="o">+=</span> <span class="n">length</span>
        <span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">masterGridPositions</span> <span class="o">=</span> <span class="n">pointArrayRaw</span>
        <span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">distToClosestSurf</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">diag</span><span class="p">]</span> <span class="o">*</span> <span class="n">length</span><span class="p">)</span>

        <span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">compartment_ids</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">number</span><span class="p">]</span> <span class="o">*</span> <span class="n">length</span><span class="p">)</span>
        <span class="n">surfacePoints</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">nbGridPoints</span><span class="p">,</span> <span class="n">nbGridPoints</span> <span class="o">+</span> <span class="n">length</span><span class="p">))</span>
        <span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">free_points</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">surfacePoints</span><span class="p">)</span>

        <span class="n">surfacePointsNormals</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">surfPtsBBNorms</span><span class="p">):</span>
            <span class="n">surfacePointsNormals</span><span class="p">[</span><span class="n">nbGridPoints</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span>

        <span class="n">insidePoints</span> <span class="o">=</span> <span class="n">insidePoints</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">insidePoints</span> <span class="o">=</span> <span class="n">insidePoints</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surfacePoints</span> <span class="o">=</span> <span class="n">surfacePoints</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surfacePointsCoords</span> <span class="o">=</span> <span class="n">surfPtsBB</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surfacePointsNormals</span> <span class="o">=</span> <span class="n">surfacePointsNormals</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">insidePoints</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">surfacePoints</span></div>


<div class="viewcode-block" id="Compartment.BuildGrid_utsdf">
<a class="viewcode-back" href="../../../cellpack.autopack.html#cellpack.autopack.Compartment.Compartment.BuildGrid_utsdf">[docs]</a>
    <span class="k">def</span> <span class="nf">BuildGrid_utsdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">env</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build the compartment grid ie surface and inside point using signed distance fields</span>
<span class="sd">        from the UT package</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ogsurfacePoints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ogsurfacePointsNormals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vnormals</span><span class="p">[:]</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span>
        <span class="n">faces</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">faces</span>
        <span class="n">normalList2</span><span class="p">,</span> <span class="n">areas</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getFaceNormals</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span> <span class="n">faces</span><span class="p">,</span> <span class="n">fillBB</span><span class="o">=</span><span class="n">env</span><span class="o">.</span><span class="n">fillBB</span><span class="p">)</span>
        <span class="c1">#        labels = numpy.ones(len(faces), &#39;i&#39;)</span>

        <span class="c1"># FIXME .. dimensions on SDF should addapt to compartment size</span>
        <span class="n">sizex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getSizeXYZ</span><span class="p">()</span>

        <span class="kn">from</span> <span class="nn">UTpackages.UTsdf</span> <span class="kn">import</span> <span class="n">utsdf</span>

        <span class="c1"># can be 16,32,64,128,256,512,1024</span>
        <span class="c1">#        if spacing not in [16,32,64,128,256,512,1024]:</span>
        <span class="c1">#            spacing = self.find_nearest(numpy.array([16,32,64,128,256,512,1024]),spacing)</span>
        <span class="c1"># compute SDF</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="mi">16</span>
        <span class="n">dim1</span> <span class="o">=</span> <span class="n">dim</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">dim1</span> <span class="o">*</span> <span class="n">dim1</span> <span class="o">*</span> <span class="n">dim1</span>

        <span class="n">verts</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;f&quot;</span><span class="p">)</span>

        <span class="n">tris</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">faces</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int&quot;</span><span class="p">)</span>
        <span class="n">utsdf</span><span class="o">.</span><span class="n">setParameters</span><span class="p">(</span>
            <span class="n">dim</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="p">)</span>  <span class="c1"># size, bool isNormalFlip, bool insideZero,bufferArr</span>
        <span class="n">surfacePoints</span> <span class="o">=</span> <span class="n">srfPts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span>
        <span class="n">datap</span> <span class="o">=</span> <span class="n">utsdf</span><span class="o">.</span><span class="n">computeSDF</span><span class="p">(</span>
            <span class="n">numpy</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">verts</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span>
            <span class="n">numpy</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">tris</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">utsdf</span><span class="o">.</span><span class="n">createNumArr</span><span class="p">(</span><span class="n">datap</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
        <span class="n">volarr</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:]</span>
        <span class="n">volarr</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">dim1</span><span class="p">,</span> <span class="n">dim1</span><span class="p">,</span> <span class="n">dim1</span><span class="p">)</span>
        <span class="n">volarr</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">volarr</span><span class="p">),</span> <span class="s2">&quot;f&quot;</span><span class="p">)</span>

        <span class="c1"># get grid points distances to compartment surface</span>
        <span class="kn">from</span> <span class="nn">Volume.Operators.trilinterp</span> <span class="kn">import</span> <span class="n">trilinterp</span>

        <span class="n">invstep</span> <span class="o">=</span> <span class="p">(</span>
            <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">sizex</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">dim</span><span class="p">),</span>
            <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">sizex</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">dim</span><span class="p">),</span>
            <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">sizex</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="n">dim</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">origin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">distFromSurf</span> <span class="o">=</span> <span class="n">trilinterp</span><span class="p">(</span><span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">masterGridPositions</span><span class="p">,</span> <span class="n">volarr</span><span class="p">,</span> <span class="n">invstep</span><span class="p">,</span> <span class="n">origin</span><span class="p">)</span>

        <span class="c1"># update histoVol.distToClosestSurf</span>
        <span class="n">distance</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">distToClosestSurf</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">distFromSurf</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">distance</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">d</span><span class="p">:</span>
                <span class="n">distance</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span>

        <span class="c1"># loop over fill box grid points and build the idarray</span>
        <span class="c1"># identify inside and surface points and update the distance field</span>
        <span class="n">insidePoints</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">surfacePoints</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">indice</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">less</span><span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">))</span>
        <span class="n">pointinside</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">masterGridPositions</span><span class="p">,</span> <span class="n">indice</span><span class="p">,</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">indice</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">indice</span> <span class="o">=</span> <span class="n">indice</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pointinside</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">pointinside</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">pointinside</span> <span class="o">=</span> <span class="n">pointinside</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">compartment_ids</span><span class="p">[</span><span class="n">indice</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">number</span>
        <span class="n">nbGridPoints</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">masterGridPositions</span><span class="p">)</span>

        <span class="n">surfPtsBB</span><span class="p">,</span> <span class="n">surfPtsBBNorms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_surface_pts_to_fill_box</span><span class="p">(</span><span class="n">srfPts</span><span class="p">,</span> <span class="n">env</span><span class="p">)</span>
        <span class="n">srfPts</span> <span class="o">=</span> <span class="n">surfPtsBB</span>
        <span class="n">surfacePoints</span><span class="p">,</span> <span class="n">surfacePointsNormals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extendGridArrays</span><span class="p">(</span>
            <span class="n">nbGridPoints</span><span class="p">,</span> <span class="n">srfPts</span><span class="p">,</span> <span class="n">surfPtsBBNorms</span><span class="p">,</span> <span class="n">env</span>
        <span class="p">)</span>

        <span class="n">insidePoints</span> <span class="o">=</span> <span class="n">pointinside</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">insidePoints</span> <span class="o">=</span> <span class="n">insidePoints</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surfacePoints</span> <span class="o">=</span> <span class="n">surfacePoints</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surfacePointsCoords</span> <span class="o">=</span> <span class="n">surfPtsBB</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surfacePointsNormals</span> <span class="o">=</span> <span class="n">surfacePointsNormals</span>
        <span class="k">return</span> <span class="n">insidePoints</span><span class="p">,</span> <span class="n">surfacePoints</span></div>


<div class="viewcode-block" id="Compartment.get_bbox">
<a class="viewcode-back" href="../../../cellpack.autopack.html#cellpack.autopack.Compartment.Compartment.get_bbox">[docs]</a>
    <span class="k">def</span> <span class="nf">get_bbox</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vert_list</span><span class="p">,</span> <span class="n">BB_SCALE</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;get bounding box for the given list of vertices&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">multisdf</span> <span class="kn">import</span> <span class="n">multisdf</span>

        <span class="n">multisdf</span><span class="o">.</span><span class="n">cvar</span><span class="o">.</span><span class="n">BB_SCALE</span> <span class="o">=</span> <span class="n">BB_SCALE</span>
        <span class="n">HUGE</span> <span class="o">=</span> <span class="mi">999999</span>

        <span class="n">bbox</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">x_min</span> <span class="o">=</span> <span class="n">HUGE</span>
        <span class="n">x_max</span> <span class="o">=</span> <span class="o">-</span><span class="n">HUGE</span>
        <span class="n">y_min</span> <span class="o">=</span> <span class="n">HUGE</span>
        <span class="n">y_max</span> <span class="o">=</span> <span class="o">-</span><span class="n">HUGE</span>
        <span class="n">z_min</span> <span class="o">=</span> <span class="n">HUGE</span>
        <span class="n">z_max</span> <span class="o">=</span> <span class="o">-</span><span class="n">HUGE</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vert_list</span><span class="p">)):</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">vert_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="c1"># check x-span</span>
            <span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">x_min</span><span class="p">:</span>
                <span class="n">x_min</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">x_max</span><span class="p">:</span>
                <span class="n">x_max</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># check y-span</span>
            <span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">y_min</span><span class="p">:</span>
                <span class="n">y_min</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">y_max</span><span class="p">:</span>
                <span class="n">y_max</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># check z-span</span>
            <span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">z_min</span><span class="p">:</span>
                <span class="n">z_min</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">z_max</span><span class="p">:</span>
                <span class="n">z_max</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

        <span class="n">bbox</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x_min</span> <span class="o">-</span> <span class="n">BB_SCALE</span> <span class="o">*</span> <span class="p">(</span><span class="n">x_max</span> <span class="o">-</span> <span class="n">x_min</span><span class="p">))</span>
        <span class="n">bbox</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y_min</span> <span class="o">-</span> <span class="n">BB_SCALE</span> <span class="o">*</span> <span class="p">(</span><span class="n">y_max</span> <span class="o">-</span> <span class="n">y_min</span><span class="p">))</span>
        <span class="n">bbox</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">z_min</span> <span class="o">-</span> <span class="n">BB_SCALE</span> <span class="o">*</span> <span class="p">(</span><span class="n">z_max</span> <span class="o">-</span> <span class="n">z_min</span><span class="p">))</span>

        <span class="n">bbox</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x_max</span> <span class="o">+</span> <span class="n">BB_SCALE</span> <span class="o">*</span> <span class="p">(</span><span class="n">x_max</span> <span class="o">-</span> <span class="n">x_min</span><span class="p">))</span>
        <span class="n">bbox</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y_max</span> <span class="o">+</span> <span class="n">BB_SCALE</span> <span class="o">*</span> <span class="p">(</span><span class="n">y_max</span> <span class="o">-</span> <span class="n">y_min</span><span class="p">))</span>
        <span class="n">bbox</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">z_max</span> <span class="o">+</span> <span class="n">BB_SCALE</span> <span class="o">*</span> <span class="p">(</span><span class="n">z_max</span> <span class="o">-</span> <span class="n">z_min</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">bbox</span></div>


<div class="viewcode-block" id="Compartment.BuildGrid_multisdf">
<a class="viewcode-back" href="../../../cellpack.autopack.html#cellpack.autopack.Compartment.Compartment.BuildGrid_multisdf">[docs]</a>
    <span class="k">def</span> <span class="nf">BuildGrid_multisdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">histoVol</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Build the compartment grid ie surface and inside point using multisdf&quot;&quot;&quot;</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span>
        <span class="n">faces</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">faces</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">faces</span><span class="p">),</span> <span class="s2">&quot;i&quot;</span><span class="p">)</span>

        <span class="c1"># FIXME .. dimensions on SDF should addapt to compartment size</span>
        <span class="n">bbox</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bbox</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>
        <span class="n">xmin</span> <span class="o">=</span> <span class="n">bbox</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ymin</span> <span class="o">=</span> <span class="n">bbox</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">zmin</span> <span class="o">=</span> <span class="n">bbox</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">xmax</span> <span class="o">=</span> <span class="n">bbox</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">ymax</span> <span class="o">=</span> <span class="n">bbox</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
        <span class="n">zmax</span> <span class="o">=</span> <span class="n">bbox</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>

        <span class="c1"># compute SDF</span>
        <span class="kn">from</span> <span class="nn">multisdf</span> <span class="kn">import</span> <span class="n">multisdf</span>

        <span class="n">gridSpacing</span> <span class="o">=</span> <span class="mf">30.0</span>
        <span class="n">dimx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">xmax</span> <span class="o">-</span> <span class="n">xmin</span><span class="p">)</span> <span class="o">/</span> <span class="n">gridSpacing</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">dimy</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">ymax</span> <span class="o">-</span> <span class="n">ymin</span><span class="p">)</span> <span class="o">/</span> <span class="n">gridSpacing</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">dimz</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">zmax</span> <span class="o">-</span> <span class="n">zmin</span><span class="p">)</span> <span class="o">/</span> <span class="n">gridSpacing</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="n">gSizeX</span> <span class="o">=</span> <span class="p">(</span><span class="n">xmax</span> <span class="o">-</span> <span class="n">xmin</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">dimx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">gSizeY</span> <span class="o">=</span> <span class="p">(</span><span class="n">ymax</span> <span class="o">-</span> <span class="n">ymin</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">dimy</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">gSizeZ</span> <span class="o">=</span> <span class="p">(</span><span class="n">zmax</span> <span class="o">-</span> <span class="n">zmin</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">dimz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;SDF grid size&quot;</span><span class="p">,</span> <span class="n">dimx</span><span class="p">,</span> <span class="n">dimy</span><span class="p">,</span> <span class="n">dimz</span><span class="p">,</span> <span class="n">gSizeX</span><span class="p">,</span> <span class="n">gSizeY</span><span class="p">,</span> <span class="n">gSizeZ</span><span class="p">)</span>

        <span class="n">mind</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1000.0</span>
        <span class="n">maxd</span> <span class="o">=</span> <span class="mf">1000.0</span>
        <span class="n">datap</span> <span class="o">=</span> <span class="n">multisdf</span><span class="o">.</span><span class="n">computeSDF</span><span class="p">(</span>
            <span class="n">vertices</span><span class="p">,</span> <span class="n">faces</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">dimx</span><span class="p">,</span> <span class="n">dimy</span><span class="p">,</span> <span class="n">dimz</span><span class="p">,</span> <span class="n">maxd</span><span class="p">,</span> <span class="n">mind</span>
        <span class="p">)</span>
        <span class="n">grid_size</span> <span class="o">=</span> <span class="n">dimx</span> <span class="o">*</span> <span class="n">dimy</span> <span class="o">*</span> <span class="n">dimz</span>
        <span class="n">volarr</span> <span class="o">=</span> <span class="n">multisdf</span><span class="o">.</span><span class="n">createNumArr</span><span class="p">(</span><span class="n">datap</span><span class="p">,</span> <span class="n">grid_size</span><span class="p">)</span>
        <span class="n">volarr</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">dimz</span><span class="p">,</span> <span class="n">dimy</span><span class="p">,</span> <span class="n">dimx</span><span class="p">)</span>
        <span class="n">volarr</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">volarr</span><span class="p">),</span> <span class="s2">&quot;f&quot;</span><span class="p">)</span>

        <span class="c1"># get grid points distances to compartment surface</span>
        <span class="kn">from</span> <span class="nn">Volume.Operators.trilinterp</span> <span class="kn">import</span> <span class="n">trilinterp</span>

        <span class="n">invstep</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">gridSpacing</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">gridSpacing</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">gridSpacing</span><span class="p">)</span>
        <span class="n">origin</span> <span class="o">=</span> <span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">zmin</span><span class="p">)</span>
        <span class="n">distFromSurf</span> <span class="o">=</span> <span class="n">trilinterp</span><span class="p">(</span><span class="n">histoVol</span><span class="o">.</span><span class="n">masterGridPositions</span><span class="p">,</span> <span class="n">volarr</span><span class="p">,</span> <span class="n">invstep</span><span class="p">,</span> <span class="n">origin</span><span class="p">)</span>

        <span class="c1"># save SDF</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sdfData</span> <span class="o">=</span> <span class="n">volarr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sdfOrigin</span> <span class="o">=</span> <span class="n">origin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sdfGridSpacing</span> <span class="o">=</span> <span class="p">(</span><span class="n">gSizeX</span><span class="p">,</span> <span class="n">gSizeY</span><span class="p">,</span> <span class="n">gSizeZ</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sdfDims</span> <span class="o">=</span> <span class="p">(</span><span class="n">dimx</span><span class="p">,</span> <span class="n">dimy</span><span class="p">,</span> <span class="n">dimz</span><span class="p">)</span>

        <span class="c1"># update histoVol.distToClosestSurf</span>
        <span class="n">distance</span> <span class="o">=</span> <span class="n">histoVol</span><span class="o">.</span><span class="n">distToClosestSurf</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">distFromSurf</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">distance</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">d</span><span class="p">:</span>
                <span class="n">distance</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span>

        <span class="c1"># loop over fill box grid points and build the idarray</span>
        <span class="c1"># identify inside and surface points and update the distance field</span>
        <span class="n">number</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number</span>
        <span class="n">insidePoints</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">surfacePoints</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">allNormals</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">idarray</span> <span class="o">=</span> <span class="n">histoVol</span><span class="o">.</span><span class="n">compartment_ids</span>
        <span class="c1"># surfaceCutOff = histoVol.gridSpacing*.5</span>
        <span class="c1"># import pdb</span>
        <span class="c1"># pdb.set_trace()</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">distance</span><span class="p">):</span>
            <span class="c1"># identify surface and interior points</span>
            <span class="c1"># there is a problem with SDF putting large negative values</span>
            <span class="c1"># for inside points. For now we pick all negative != mind as</span>
            <span class="c1"># surface points</span>
            <span class="k">if</span> <span class="n">d</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">elif</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="n">mind</span><span class="p">:</span>
                <span class="n">surfacePoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">idarray</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">number</span>
                <span class="n">allNormals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">insidePoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">idarray</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">number</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">insidePoints</span> <span class="o">=</span> <span class="n">insidePoints</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surfacePoints</span> <span class="o">=</span> <span class="n">surfacePoints</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surfacePointsNormals</span> <span class="o">=</span> <span class="n">allNormals</span>

        <span class="k">return</span> <span class="n">insidePoints</span><span class="p">,</span> <span class="n">surfacePoints</span></div>


<div class="viewcode-block" id="Compartment.getSurfacePoint">
<a class="viewcode-back" href="../../../cellpack.autopack.html#cellpack.autopack.Compartment.Compartment.getSurfacePoint">[docs]</a>
    <span class="k">def</span> <span class="nf">getSurfacePoint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">w1</span><span class="p">,</span> <span class="n">w2</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;compute point between p1 and p2 with weight w1 and w2&quot;&quot;&quot;</span>
        <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">z1</span> <span class="o">=</span> <span class="n">p1</span>
        <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">z2</span> <span class="o">=</span> <span class="n">p2</span>
        <span class="c1">#        totalWeight = w1+w2</span>
        <span class="n">ratio</span> <span class="o">=</span> <span class="n">w1</span> <span class="o">/</span> <span class="p">(</span><span class="n">w1</span> <span class="o">+</span> <span class="n">w2</span><span class="p">)</span>
        <span class="n">vec</span> <span class="o">=</span> <span class="p">(</span><span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y2</span> <span class="o">-</span> <span class="n">y1</span><span class="p">,</span> <span class="n">z2</span> <span class="o">-</span> <span class="n">z1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x1</span> <span class="o">+</span> <span class="n">ratio</span> <span class="o">*</span> <span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">y1</span> <span class="o">+</span> <span class="n">ratio</span> <span class="o">*</span> <span class="n">vec</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">z1</span> <span class="o">+</span> <span class="n">ratio</span> <span class="o">*</span> <span class="n">vec</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span></div>


<div class="viewcode-block" id="Compartment.compute_volume_and_set_count">
<a class="viewcode-back" href="../../../cellpack.autopack.html#cellpack.autopack.Compartment.Compartment.compute_volume_and_set_count">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_volume_and_set_count</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">env</span><span class="p">,</span> <span class="n">surfacePoints</span><span class="p">,</span> <span class="n">insidePoints</span><span class="p">,</span> <span class="n">areas</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute volume of surface and interior</span>
<span class="sd">        set &#39;count&#39; in each ingredient of both recipes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">unitVol</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">gridSpacing</span><span class="o">**</span><span class="mi">3</span>
        <span class="k">if</span> <span class="n">surfacePoints</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> surface points </span><span class="si">%.2f</span><span class="s2"> unitVol&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">surfacePoints</span><span class="p">),</span> <span class="n">unitVol</span><span class="p">)</span>
            <span class="c1"># FIXME .. should be surface per surface point instead of unitVol</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">surfaceVolume</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">surfacePoints</span><span class="p">)</span> <span class="o">*</span> <span class="n">unitVol</span>
        <span class="k">if</span> <span class="n">areas</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">surfaceVolume</span> <span class="o">=</span> <span class="n">areas</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interiorVolume</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">insidePoints</span><span class="p">)</span> <span class="o">*</span> <span class="n">unitVol</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">surfaceVolume</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> surface volume </span><span class="si">%.2f</span><span class="s2"> interior volume&quot;</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">surfaceVolume</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">interiorVolume</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">interiorVolume</span><span class="si">}</span><span class="s2"> interior volume&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setCount</span><span class="p">()</span></div>


<div class="viewcode-block" id="Compartment.setCount">
<a class="viewcode-back" href="../../../cellpack.autopack.html#cellpack.autopack.Compartment.Compartment.setCount">[docs]</a>
    <span class="k">def</span> <span class="nf">setCount</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># compute number of molecules and save in recipes</span>
        <span class="n">rs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surfaceRecipe</span>
        <span class="k">if</span> <span class="n">rs</span><span class="p">:</span>
            <span class="n">volume</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surfaceVolume</span>
            <span class="n">rs</span><span class="o">.</span><span class="n">setCount</span><span class="p">(</span><span class="n">volume</span><span class="p">)</span>

        <span class="n">ri</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">innerRecipe</span>
        <span class="k">if</span> <span class="n">ri</span><span class="p">:</span>
            <span class="n">volume</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interiorVolume</span>
            <span class="n">ri</span><span class="o">.</span><span class="n">setCount</span><span class="p">(</span><span class="n">volume</span><span class="p">)</span></div>


<div class="viewcode-block" id="Compartment.getFacesNfromV">
<a class="viewcode-back" href="../../../cellpack.autopack.html#cellpack.autopack.Compartment.Compartment.getFacesNfromV">[docs]</a>
    <span class="k">def</span> <span class="nf">getFacesNfromV</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vindice</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieve the face normal from the indice of a vertice</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">f</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">af</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">faces</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">vindice</span> <span class="ow">in</span> <span class="n">af</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ext</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">vi</span> <span class="ow">in</span> <span class="n">af</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">vi</span> <span class="o">!=</span> <span class="n">vindice</span><span class="p">:</span>
                            <span class="n">ff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getFacesNfromV</span><span class="p">(</span><span class="n">vi</span><span class="p">)</span>
                            <span class="n">f</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">ff</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fnormals</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">f</span></div>


<div class="viewcode-block" id="Compartment.getVNfromF">
<a class="viewcode-back" href="../../../cellpack.autopack.html#cellpack.autopack.Compartment.Compartment.getVNfromF">[docs]</a>
    <span class="k">def</span> <span class="nf">getVNfromF</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieve the vertice normal from the indice of a vertice</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">normals</span>
        <span class="n">fi</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">af</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">faces</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">af</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">af</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">j</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fi</span><span class="p">:</span>
                        <span class="n">fi</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">fi</span><span class="p">:</span>
            <span class="n">n</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">normals</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">n</span></div>


<div class="viewcode-block" id="Compartment.create3DPointLookup">
<a class="viewcode-back" href="../../../cellpack.autopack.html#cellpack.autopack.Compartment.Compartment.create3DPointLookup">[docs]</a>
    <span class="k">def</span> <span class="nf">create3DPointLookup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nbGridPoints</span><span class="p">,</span> <span class="n">gridSpacing</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">boundingBox</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fill the orthogonal bounding box described by two global corners</span>
<span class="sd">         with an array of points spaces pGridSpacing apart. Duplicate from grid class</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">boundingBox</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">boundingBox</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bb</span>
        <span class="n">xl</span><span class="p">,</span> <span class="n">yl</span><span class="p">,</span> <span class="n">zl</span> <span class="o">=</span> <span class="n">boundingBox</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">xr</span><span class="p">,</span> <span class="n">yr</span><span class="p">,</span> <span class="n">zr</span> <span class="o">=</span> <span class="n">boundingBox</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span> <span class="o">=</span> <span class="n">nbGridPoints</span>
        <span class="n">pointArrayRaw</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nx</span> <span class="o">*</span> <span class="n">ny</span> <span class="o">*</span> <span class="n">nz</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="s2">&quot;f&quot;</span><span class="p">)</span>
        <span class="n">ijkPtIndice</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nx</span> <span class="o">*</span> <span class="n">ny</span> <span class="o">*</span> <span class="n">nz</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="s2">&quot;i&quot;</span><span class="p">)</span>
        <span class="n">size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getSizeXYZ</span><span class="p">()</span>
        <span class="c1"># Vector for lower left broken into real of only the z coord.</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">zi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nz</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">yi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ny</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nx</span><span class="p">):</span>
                    <span class="n">pointArrayRaw</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">xl</span> <span class="o">+</span> <span class="n">xi</span> <span class="o">*</span> <span class="p">(</span><span class="n">size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">dim</span><span class="p">),</span>
                        <span class="n">yl</span> <span class="o">+</span> <span class="n">yi</span> <span class="o">*</span> <span class="p">(</span><span class="n">size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">dim</span><span class="p">),</span>
                        <span class="n">zl</span> <span class="o">+</span> <span class="n">zi</span> <span class="o">*</span> <span class="p">(</span><span class="n">size</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="n">dim</span><span class="p">),</span>
                    <span class="p">)</span>
                    <span class="n">ijkPtIndice</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">zi</span><span class="p">)</span>
                    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">ijkPtIndice</span><span class="p">,</span> <span class="n">pointArrayRaw</span></div>


<div class="viewcode-block" id="Compartment.find_nearest">
<a class="viewcode-back" href="../../../cellpack.autopack.html#cellpack.autopack.Compartment.Compartment.find_nearest">[docs]</a>
    <span class="k">def</span> <span class="nf">find_nearest</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;find nearest point indice of value in array using numpy&quot;&quot;&quot;</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">array</span> <span class="o">-</span> <span class="n">value</span><span class="p">))</span><span class="o">.</span><span class="n">argmin</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">array</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span></div>


    <span class="c1"># TOD add and store the grid_distances  (closest distance for each point). not only inside / outside</span>

<div class="viewcode-block" id="Compartment.getSurfaceInnerPoints_sdf">
<a class="viewcode-back" href="../../../cellpack.autopack.html#cellpack.autopack.Compartment.Compartment.getSurfaceInnerPoints_sdf">[docs]</a>
    <span class="k">def</span> <span class="nf">getSurfaceInnerPoints_sdf</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">boundingBox</span><span class="p">,</span> <span class="n">spacing</span><span class="p">,</span> <span class="n">display</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">useFix</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Only compute the inner point. No grid.</span>
<span class="sd">        This is independant from the packing. Help build ingredient sphere tree and representation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">autopack.Environment</span> <span class="kn">import</span> <span class="n">Grid</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="n">grid</span> <span class="o">=</span> <span class="n">Grid</span><span class="p">()</span>
        <span class="n">grid</span><span class="o">.</span><span class="n">boundingBox</span> <span class="o">=</span> <span class="n">boundingBox</span>
        <span class="n">grid</span><span class="o">.</span><span class="n">gridSpacing</span> <span class="o">=</span> <span class="n">spacing</span>
        <span class="n">helper</span><span class="o">.</span><span class="n">progressBar</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;BuildGRid&quot;</span><span class="p">)</span>
        <span class="n">grid</span><span class="o">.</span><span class="n">gridVolume</span><span class="p">,</span> <span class="n">grid</span><span class="o">.</span><span class="n">nbGridPoints</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">computeGridNumberOfPoint</span><span class="p">(</span>
            <span class="n">boundingBox</span><span class="p">,</span> <span class="n">spacing</span>
        <span class="p">)</span>
        <span class="n">grid</span><span class="o">.</span><span class="n">create3DPointLookup</span><span class="p">()</span>
        <span class="n">nbPoints</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">gridVolume</span>
        <span class="n">grid</span><span class="o">.</span><span class="n">compartment_ids</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">nbPoints</span>
        <span class="n">xl</span><span class="p">,</span> <span class="n">yl</span><span class="p">,</span> <span class="n">zl</span> <span class="o">=</span> <span class="n">boundingBox</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">xr</span><span class="p">,</span> <span class="n">yr</span><span class="p">,</span> <span class="n">zr</span> <span class="o">=</span> <span class="n">boundingBox</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># distToClosestSurf is set to self.diag initially</span>
        <span class="n">grid</span><span class="o">.</span><span class="n">diag</span> <span class="o">=</span> <span class="n">diag</span> <span class="o">=</span> <span class="n">vlen</span><span class="p">(</span><span class="n">vdiff</span><span class="p">((</span><span class="n">xr</span><span class="p">,</span> <span class="n">yr</span><span class="p">,</span> <span class="n">zr</span><span class="p">),</span> <span class="p">(</span><span class="n">xl</span><span class="p">,</span> <span class="n">yl</span><span class="p">,</span> <span class="n">zl</span><span class="p">)))</span>
        <span class="n">grid</span><span class="o">.</span><span class="n">distToClosestSurf</span> <span class="o">=</span> <span class="p">[</span><span class="n">diag</span><span class="p">]</span> <span class="o">*</span> <span class="n">nbPoints</span>
        <span class="n">diag</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">diag</span>

        <span class="kn">from</span> <span class="nn">UTpackages.UTsdf</span> <span class="kn">import</span> <span class="n">utsdf</span>

        <span class="c1"># can be 16,32,64,128,256,512,1024</span>
        <span class="k">if</span> <span class="n">spacing</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">16</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="mi">1024</span><span class="p">]:</span>
            <span class="n">spacing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_nearest</span><span class="p">(</span>
                <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">16</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="mi">1024</span><span class="p">]),</span> <span class="n">spacing</span>
            <span class="p">)</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="n">spacing</span>
        <span class="n">dim1</span> <span class="o">=</span> <span class="n">dim</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="n">size</span> <span class="o">=</span> <span class="n">dim1</span> <span class="o">*</span> <span class="n">dim1</span> <span class="o">*</span> <span class="n">dim1</span>
        <span class="c1"># can be 16,32,64,128,256,512,1024</span>
        <span class="n">verts</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;f&quot;</span><span class="p">)</span>
        <span class="n">tris</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">faces</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int&quot;</span><span class="p">)</span>
        <span class="n">utsdf</span><span class="o">.</span><span class="n">setParameters</span><span class="p">(</span>
            <span class="nb">int</span><span class="p">(</span><span class="n">dim</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="p">)</span>  <span class="c1"># size, bool isNormalFlip, bool insideZero,bufferArr</span>

        <span class="c1"># spacing = length / 64</span>
        <span class="n">sizes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getSizeXYZ</span><span class="p">()</span>
        <span class="n">L</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">sizes</span><span class="p">)</span>
        <span class="n">spacing</span> <span class="o">=</span> <span class="n">L</span> <span class="o">/</span> <span class="n">dim</span>  <span class="c1"># = self.smallestProteinSize*1.1547  # 2/sqrt(3)????</span>
        <span class="c1"># helper.progressBar(label=&quot;BuildGRid&quot;)</span>
        <span class="c1"># grid.gridVolume,grid.nbGridPoints = grid.computeGridNumberOfPoint(boundingBox,spacing)</span>
        <span class="n">xl</span><span class="p">,</span> <span class="n">yl</span><span class="p">,</span> <span class="n">zl</span> <span class="o">=</span> <span class="n">boundingBox</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">xr</span><span class="p">,</span> <span class="n">yr</span><span class="p">,</span> <span class="n">zr</span> <span class="o">=</span> <span class="n">boundingBox</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;ok grid points&quot;</span><span class="p">)</span>
        <span class="n">datap</span> <span class="o">=</span> <span class="n">utsdf</span><span class="o">.</span><span class="n">computeSDF</span><span class="p">(</span><span class="n">verts</span><span class="p">,</span> <span class="n">tris</span><span class="p">)</span>
        <span class="c1"># datap = utsdf.computeSDF(verts,tris)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;ok computeSDF&quot;</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">utsdf</span><span class="o">.</span><span class="n">createNumArr</span><span class="p">(</span><span class="n">datap</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid_distances</span> <span class="o">=</span> <span class="n">data</span>
        <span class="n">nbGridPoints</span> <span class="o">=</span> <span class="p">[</span><span class="n">dim1</span><span class="p">,</span> <span class="n">dim1</span><span class="p">,</span> <span class="n">dim1</span><span class="p">]</span>
        <span class="n">ijkPtIndice</span><span class="p">,</span> <span class="n">pointArrayRaw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create3DPointLookup</span><span class="p">(</span>
            <span class="n">nbGridPoints</span><span class="p">,</span> <span class="n">spacing</span><span class="p">,</span> <span class="n">dim</span>
        <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;ok grid&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">size</span><span class="p">)</span>
        <span class="n">nbPoints</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pointArrayRaw</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;n pts&quot;</span><span class="p">,</span> <span class="n">nbPoints</span><span class="p">)</span>
        <span class="n">grdPos</span> <span class="o">=</span> <span class="n">pointArrayRaw</span>
        <span class="n">indice</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">less</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">))</span>
        <span class="n">pointinside</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">grdPos</span><span class="p">,</span> <span class="n">indice</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="c1"># need to update the surface. need to create a aligned grid</span>
        <span class="k">return</span> <span class="n">pointinside</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span></div>


<div class="viewcode-block" id="Compartment.getSurfaceInnerPoints_kevin">
<a class="viewcode-back" href="../../../cellpack.autopack.html#cellpack.autopack.Compartment.Compartment.getSurfaceInnerPoints_kevin">[docs]</a>
    <span class="k">def</span> <span class="nf">getSurfaceInnerPoints_kevin</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">boundingBox</span><span class="p">,</span> <span class="n">spacing</span><span class="p">,</span> <span class="n">display</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">superFine</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Takes a polyhedron, and builds a grid. In this grid:</span>
<span class="sd">            - Projects the polyhedron to the grid.</span>
<span class="sd">            - Determines which points are inside/outside the polyhedron</span>
<span class="sd">            - Determines point&#39;s distance to the polyhedron.</span>
<span class="sd">        superFine provides the option doing a super leakproof test when determining</span>
<span class="sd">        which points are inside or outside. Instead of raycasting to nearby faces to</span>
<span class="sd">        determine inside/outside, setting this setting to true will foce the algorithm</span>
<span class="sd">        to raycast to the entire polyhedron. This usually not necessary, because the</span>
<span class="sd">        built-in algorithm has no known leakage cases, even in extreme edge cases.</span>
<span class="sd">        It is simply there as a safeguard.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Start the timer.</span>
        <span class="n">startTime</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>

        <span class="n">gridSpacing</span> <span class="o">=</span> <span class="n">spacing</span>
        <span class="n">radius</span> <span class="o">=</span> <span class="n">gridSpacing</span>

        <span class="c1"># Make a copy of faces, vertices, and vnormals.</span>
        <span class="n">faces</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">faces</span><span class="p">[:]</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[:]</span>
        <span class="kn">from</span> <span class="nn">cellpack.autopack.Environment</span> <span class="kn">import</span> <span class="n">Grid</span>

        <span class="c1"># Grid initialization</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="n">grid</span> <span class="o">=</span> <span class="n">Grid</span><span class="p">()</span>  <span class="c1"># setup=False)</span>
        <span class="n">grid</span><span class="o">.</span><span class="n">boundingBox</span> <span class="o">=</span> <span class="n">boundingBox</span>
        <span class="n">grid</span><span class="o">.</span><span class="n">gridSpacing</span> <span class="o">=</span> <span class="n">spacing</span>
        <span class="n">grid</span><span class="o">.</span><span class="n">gridVolume</span><span class="p">,</span> <span class="n">grid</span><span class="o">.</span><span class="n">nbGridPoints</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">computeGridNumberOfPoint</span><span class="p">(</span>
            <span class="n">boundingBox</span><span class="p">,</span> <span class="n">spacing</span>
        <span class="p">)</span>
        <span class="n">grid</span><span class="o">.</span><span class="n">create3DPointLookup</span><span class="p">()</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">masterGridPositions</span>
        <span class="n">gridPtsPerEdge</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">nbGridPoints</span>  <span class="c1"># In the form [nx, ny, nz]</span>

        <span class="c1"># Pre-allocates a gridPoint object for every single point we have in our grid.</span>
        <span class="c1"># is this necessary ?</span>
        <span class="n">gridPoints</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">points</span><span class="p">:</span>
            <span class="n">gridPoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gridPoint</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="n">isPolyhedron</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">gridPoints</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>

        <span class="c1"># Make a precomputed cube of coordinates and corresponding distances</span>
        <span class="n">distanceCube</span><span class="p">,</span> <span class="n">distX</span><span class="p">,</span> <span class="n">distY</span><span class="p">,</span> <span class="n">distZ</span> <span class="o">=</span> <span class="n">makeMarchingCube</span><span class="p">(</span><span class="n">gridSpacing</span><span class="p">,</span> <span class="n">radius</span><span class="p">)</span>
        <span class="c1"># Flatten and combine these arrays. This is easier to iterate over.</span>
        <span class="n">distanceCubeF</span><span class="p">,</span> <span class="n">distXF</span><span class="p">,</span> <span class="n">distYF</span><span class="p">,</span> <span class="n">distZF</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">distanceCube</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span>
            <span class="n">distX</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span>
            <span class="n">distY</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span>
            <span class="n">distZ</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span>
        <span class="p">)</span>
        <span class="n">zippedNumbers</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">distanceCubeF</span><span class="p">,</span> <span class="n">distXF</span><span class="p">,</span> <span class="n">distYF</span><span class="p">,</span> <span class="n">distZF</span><span class="p">)</span>

        <span class="n">NX</span><span class="p">,</span> <span class="n">NY</span><span class="p">,</span> <span class="n">NZ</span> <span class="o">=</span> <span class="n">gridPtsPerEdge</span>
        <span class="n">OX</span><span class="p">,</span> <span class="n">OY</span><span class="p">,</span> <span class="n">OZ</span> <span class="o">=</span> <span class="n">boundingBox</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">spacing1</span> <span class="o">=</span> <span class="p">(</span>
            <span class="mf">1.0</span> <span class="o">/</span> <span class="n">gridSpacing</span>
        <span class="p">)</span>  <span class="c1"># Inverse of the spacing. We compute this here, so we don&#39;t have to recompute it repeatedly</span>
        <span class="n">allCoordinates</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">[]</span>
        <span class="p">)</span>  <span class="c1"># Tracker for all the fine coordiantes that we have interpolated for the faces of the polyhedron</span>

        <span class="c1"># Walk through the faces, projecting each to the grid and marking immediate neighbors so we can test said</span>
        <span class="c1"># neighbors for inside/outside later.</span>
        <span class="k">for</span> <span class="n">face</span> <span class="ow">in</span> <span class="n">faces</span><span class="p">:</span>
            <span class="c1"># Get the vertex coordinates and convert to numpy arrays</span>
            <span class="n">triCoords</span> <span class="o">=</span> <span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vertices</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">face</span><span class="p">]</span>
            <span class="n">thisFaceFineCoords</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">triCoords</span><span class="p">)</span>
            <span class="n">allCoordinates</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">triCoords</span><span class="p">)</span>
            <span class="c1"># Use these u/v vectors to interpolate points that reside on the face</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">triCoords</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">triCoords</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">pos</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">triCoords</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">pos</span>
            <span class="c1"># Smetimes the hypotenuse isn&#39;t fully represented, so use an additional w vector</span>
            <span class="c1"># to interpolate points on the hypotenuse</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">triCoords</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">triCoords</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># If either u or v is greater than the grid spacing, then we need to subdivide it</span>
            <span class="c1"># We will use ceil: if we have a u of length 16, and grid spacing of 5, then we want</span>
            <span class="c1"># a u at 0, 5, 10, 15 which is [0, 1, 2, 3] * gridSpacing.</span>

            <span class="c1"># Using the default gridspacing, some faces will produce leakage. Instead, we</span>
            <span class="c1"># use a denser gridspacing to interpolate, and then project these points back our original spacing.</span>
            <span class="c1"># We&#39;ll decrease the gridspacing by 67% (so that it&#39;s 33% of the original). This seems be the</span>
            <span class="c1"># highest we can push this without leakage on edge cases.</span>
            <span class="n">gridSpacingTempFine</span> <span class="o">=</span> <span class="n">gridSpacing</span> <span class="o">/</span> <span class="mi">3</span>
            <span class="c1"># Determine the number of grid spacing-sized points we can fit on each vector.</span>
            <span class="c1"># Minimum is one because range(1) gives us [0]</span>
            <span class="n">uSubunits</span><span class="p">,</span> <span class="n">vSubunits</span><span class="p">,</span> <span class="n">wSubunits</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">vlen</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">gridSpacingTempFine</span><span class="p">:</span>
                <span class="n">uSubunits</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">vlen</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">/</span> <span class="n">gridSpacingTempFine</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">vlen</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">gridSpacingTempFine</span><span class="p">:</span>
                <span class="n">vSubunits</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">vlen</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">/</span> <span class="n">gridSpacingTempFine</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">vlen</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">gridSpacingTempFine</span><span class="p">:</span>
                <span class="n">wSubunits</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">vlen</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">/</span> <span class="n">gridSpacingTempFine</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="c1"># Because we have observed leakage, maybe we want to try trying a denser interpolation, using numpy&#39;s linspace?</span>
            <span class="c1"># Interpolate face of triangle into a fine mesh.</span>
            <span class="k">for</span> <span class="n">uSub</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">uSubunits</span><span class="p">):</span>
                <span class="n">percentU</span> <span class="o">=</span> <span class="n">uSub</span> <span class="o">*</span> <span class="n">gridSpacingTempFine</span> <span class="o">/</span> <span class="n">vlen</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
                <span class="n">percentU</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                    <span class="n">percentU</span><span class="p">,</span> <span class="mf">1.0</span>
                <span class="p">)</span>  <span class="c1"># Make sure that we have not stepped outside of our original u vector</span>
                <span class="c1"># h represents the height of the hypotenuse at this u. Naturally, we cannot go past the hypotenuse, so this will be</span>
                <span class="c1"># our upper bound.</span>
                <span class="n">h</span> <span class="o">=</span> <span class="n">percentU</span> <span class="o">*</span> <span class="n">u</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">percentU</span><span class="p">)</span> <span class="o">*</span> <span class="n">v</span>
                <span class="k">for</span> <span class="n">vSub</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">vSubunits</span><span class="p">):</span>
                    <span class="n">percentV</span> <span class="o">=</span> <span class="n">vSub</span> <span class="o">*</span> <span class="n">gridSpacingTempFine</span> <span class="o">/</span> <span class="n">vlen</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                    <span class="n">percentV</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                        <span class="n">percentV</span><span class="p">,</span> <span class="mf">1.0</span>
                    <span class="p">)</span>  <span class="c1"># Make sure that we have not stepped oustide of our original v vector.</span>
                    <span class="n">interpolatedPoint</span> <span class="o">=</span> <span class="n">percentU</span> <span class="o">*</span> <span class="n">u</span> <span class="o">+</span> <span class="n">percentV</span> <span class="o">*</span> <span class="n">v</span>
                    <span class="c1"># The original if: statement asks if the distance from the origin to the interpolated point is less than</span>
                    <span class="c1"># the distance from the origin to the hypotenuse point, as such:</span>
                    <span class="c1"># if vlen(interpolatedPoint) &lt; vlen(h):</span>
                    <span class="c1"># Wouldn&#39;t it be a better idea to measure distance to the u position instead? This is implemented below.</span>
                    <span class="k">if</span> <span class="n">vlen</span><span class="p">(</span><span class="n">interpolatedPoint</span> <span class="o">-</span> <span class="n">percentU</span> <span class="o">*</span> <span class="n">u</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">vlen</span><span class="p">(</span><span class="n">h</span> <span class="o">-</span> <span class="n">percentU</span> <span class="o">*</span> <span class="n">u</span><span class="p">):</span>
                        <span class="n">allCoordinates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">interpolatedPoint</span> <span class="o">+</span> <span class="n">pos</span><span class="p">)</span>
                        <span class="n">thisFaceFineCoords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">interpolatedPoint</span> <span class="o">+</span> <span class="n">pos</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">break</span>
            <span class="c1"># Interpolate the hypotenuse of the triangle into a fine mesh. Prevents leakage.</span>
            <span class="k">for</span> <span class="n">wSub</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">wSubunits</span><span class="p">):</span>
                <span class="c1"># Apply the same proceudre we did above for u/v, just for w (for hypotenuse interpolation)</span>
                <span class="n">percentW</span> <span class="o">=</span> <span class="n">wSub</span> <span class="o">*</span> <span class="n">gridSpacingTempFine</span> <span class="o">/</span> <span class="n">vlen</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
                <span class="n">percentW</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">percentW</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
                <span class="n">interpolatedPoint</span> <span class="o">=</span> <span class="n">percentW</span> <span class="o">*</span> <span class="n">w</span>
                <span class="n">allCoordinates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">interpolatedPoint</span> <span class="o">+</span> <span class="n">triCoords</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">thisFaceFineCoords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">interpolatedPoint</span> <span class="o">+</span> <span class="n">triCoords</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="c1"># Once we have interpolated the face, let&#39;s project each fine interpolated point to the grid.</span>
            <span class="n">projectedIndices</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">thisFaceFineCoords</span><span class="p">:</span>
                <span class="c1"># Not sure if we need to flip the coordinates. Let&#39;s not flip them for now.</span>
                <span class="n">projectedPointIndex</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">getPointFrom3D</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span>
                <span class="n">projectedIndices</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">projectedPointIndex</span><span class="p">)</span>

            <span class="c1"># Walk through each grid point that our face spans, gather its closest neighbors, annotate them with</span>
            <span class="c1"># minimum distance and closest faces, &amp; flag them for testing inside/outside later.</span>
            <span class="k">for</span> <span class="n">P</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">projectedIndices</span><span class="p">):</span>
                <span class="c1"># Get the point object corresponding to the index, and set its polyhedron attribute to true</span>
                <span class="n">g</span> <span class="o">=</span> <span class="n">gridPoints</span><span class="p">[</span><span class="n">P</span><span class="p">]</span>
                <span class="n">g</span><span class="o">.</span><span class="n">representsPolyhedron</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="c1"># Get the coordinates of the point, and convert them to grid units</span>
                <span class="c1"># Again, not sure if RH or LH coordinate system. Let&#39;s try RH for now.</span>
                <span class="n">xTemp</span><span class="p">,</span> <span class="n">yTemp</span><span class="p">,</span> <span class="n">zTemp</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">globalCoord</span>
                <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="nb">round</span><span class="p">((</span><span class="n">xTemp</span> <span class="o">-</span> <span class="n">OX</span><span class="p">)</span> <span class="o">*</span> <span class="n">spacing1</span><span class="p">),</span>
                    <span class="nb">round</span><span class="p">((</span><span class="n">yTemp</span> <span class="o">-</span> <span class="n">OY</span><span class="p">)</span> <span class="o">*</span> <span class="n">spacing1</span><span class="p">),</span>
                    <span class="nb">round</span><span class="p">((</span><span class="n">zTemp</span> <span class="o">-</span> <span class="n">OZ</span><span class="p">)</span> <span class="o">*</span> <span class="n">spacing1</span><span class="p">),</span>
                <span class="p">)</span>
                <span class="c1"># Let&#39;s step through our distance cube, and assign faces/closest distances to each</span>
                <span class="k">for</span> <span class="n">d</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">zippedNumbers</span><span class="p">:</span>
                    <span class="c1"># Get the grid indices for the point we&#39;re considering, and pass if we&#39;re stepping oustide the boundaries</span>
                    <span class="n">newI</span><span class="p">,</span> <span class="n">newJ</span><span class="p">,</span> <span class="n">newK</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">x</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="n">k</span> <span class="o">+</span> <span class="n">z</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="n">newI</span> <span class="o">&lt;</span> <span class="mi">0</span>
                        <span class="ow">or</span> <span class="n">newI</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">NX</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                        <span class="ow">or</span> <span class="n">newJ</span> <span class="o">&lt;</span> <span class="mi">0</span>
                        <span class="ow">or</span> <span class="n">newJ</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">NY</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                        <span class="ow">or</span> <span class="n">newK</span> <span class="o">&lt;</span> <span class="mi">0</span>
                        <span class="ow">or</span> <span class="n">newK</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">NZ</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="p">):</span>
                        <span class="k">continue</span>
                    <span class="c1"># Get the point index that this coordinate corresponds to.</span>
                    <span class="n">desiredPointIndex</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">newK</span> <span class="o">*</span> <span class="n">NX</span> <span class="o">*</span> <span class="n">NY</span> <span class="o">+</span> <span class="n">newJ</span> <span class="o">*</span> <span class="n">NX</span> <span class="o">+</span> <span class="n">newI</span><span class="p">))</span>
                    <span class="n">desiredPoint</span> <span class="o">=</span> <span class="n">gridPoints</span><span class="p">[</span><span class="n">desiredPointIndex</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">desiredPoint</span><span class="o">.</span><span class="n">representsPolyhedron</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="c1"># Add the current face to the its list of closest faces</span>
                    <span class="k">if</span> <span class="n">face</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">desiredPoint</span><span class="o">.</span><span class="n">closeFaces</span><span class="p">:</span>
                        <span class="n">desiredPoint</span><span class="o">.</span><span class="n">closeFaces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">face</span><span class="p">)</span>
                    <span class="c1"># Add the distance to the point&#39;s list of distances, and overwrite minimum distance if appropriate</span>
                    <span class="n">desiredPoint</span><span class="o">.</span><span class="n">allDistances</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">v</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="n">desiredPoint</span><span class="o">.</span><span class="n">minDistance</span><span class="p">:</span>
                        <span class="n">desiredPoint</span><span class="o">.</span><span class="n">minDistance</span> <span class="o">=</span> <span class="n">d</span>
                        <span class="c1"># Later down the road, we want to test as few points as possible for inside/outside. Therefore,</span>
                        <span class="c1"># we will only test points that are</span>
                        <span class="c1"># if abs(x) &lt;= 1 and abs(y) &lt;= 1 and abs(z) &lt;= 1:</span>
                        <span class="c1">#     pointsToTestInsideOutside.add(desiredPointIndex)</span>
        <span class="n">timeFinishProjection</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot;Projecting polyhedron to grid took &quot;</span>
            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">timeFinishProjection</span> <span class="o">-</span> <span class="n">startTime</span><span class="p">)</span>
            <span class="o">+</span> <span class="s2">&quot; seconds.&quot;</span>
        <span class="p">)</span>

        <span class="c1"># Let&#39;s start flood filling in inside outside. Here&#39;s the general algorithm:</span>
        <span class="c1"># Walk through all the points in our grid. Once we encounter a point that has closest faces,</span>
        <span class="c1"># then we know we need to test it for inside/outside. Once we test that for inside/outside, we</span>
        <span class="c1"># fill in all previous points with that same inside outisde property. To account for the possible</span>
        <span class="c1"># situation that there is a surface that is only partially bound by the bbox, then we need to</span>
        <span class="c1"># reset the insideOutsideTracker every time we have a change in more than 1 of the 3 coordinates</span>
        <span class="c1"># because that indicates we&#39;re starting a new row/column of points.</span>

        <span class="n">isOutsideTracker</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># This tracks the points that we&#39;ve iterated over which we do not know if inside/outside.</span>
        <span class="c1"># Resets every time we find an inside/outside.</span>
        <span class="n">emptyPointIndicies</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">mismatchCounter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">gridPoints</span><span class="p">:</span>
            <span class="c1"># Check if we&#39;ve started a new line. If so, then we reset everything.</span>
            <span class="c1"># This test should precede all other test, because we don&#39;t want old knowldge</span>
            <span class="c1"># to carry over to the new line, since we don&#39;t know if the polygon is only partially encapsulated by the bounding box.</span>
            <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">index</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># We can&#39;t check the first element, so we can skip it.</span>
                <span class="n">coordDiff</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">globalCoord</span> <span class="o">-</span> <span class="n">gridPoints</span><span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">globalCoord</span>
                <span class="n">coordDiffNonzero</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">coordDiff</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">coordDiffNonzero</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># assert len(emptyPointIndicies) == 0 # When starting a new line, we shouldn&#39;t have any unknowns from the previous line</span>
                    <span class="n">isOutsideTracker</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="n">emptyPointIndicies</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># There&#39;s no point testing inside/outside for points that are on the surface.</span>
            <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">representsPolyhedron</span><span class="p">:</span>
                <span class="n">g</span><span class="o">.</span><span class="n">isOutside</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">closeFaces</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># If it&#39;s not close to any faces, and we don&#39;t know if this row is inside/outside, then</span>
                <span class="c1"># we have to wait till later to figure it out</span>
                <span class="k">if</span> <span class="n">isOutsideTracker</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">emptyPointIndicies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
                <span class="c1"># However, if we do know , we can just use the previous one to fill</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">g</span><span class="o">.</span><span class="n">isOutside</span> <span class="o">=</span> <span class="n">isOutsideTracker</span>
                    <span class="c1"># If there are close faces attached to it, then we need to test it for inside/outside.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Find centroid of all the vertices of all the close faces. This will be our endpoint</span>
                <span class="c1"># when casting a ray for collision testing.</span>
                <span class="n">uniquePoints</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="c1"># This takes just the first face and projects to the center of it.</span>
                <span class="c1"># [uniquePoints.append(x) for x in g.closeFaces[0] if x not in uniquePoints]</span>
                <span class="p">[</span>
                    <span class="n">uniquePoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">closeFaces</span><span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">closestFaceIndex</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">uniquePoints</span>
                <span class="p">]</span>
                <span class="n">uniquePointsCoords</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[</span><span class="n">uniquePoints</span><span class="p">]</span>
                <span class="n">endPoint</span> <span class="o">=</span> <span class="n">findPointsCenter</span><span class="p">(</span><span class="n">uniquePointsCoords</span><span class="p">)</span>
                <span class="n">g</span><span class="o">.</span><span class="n">testedEndpoint</span> <span class="o">=</span> <span class="n">endPoint</span>

                <span class="c1"># Draw a ray to that point, and see if we hit a backface or not</span>
                <span class="n">numHits</span><span class="p">,</span> <span class="n">thisBackFace</span> <span class="o">=</span> <span class="n">f_ray_intersect_polyhedron</span><span class="p">(</span>
                    <span class="n">g</span><span class="o">.</span><span class="n">globalCoord</span><span class="p">,</span> <span class="n">endPoint</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">closeFaces</span><span class="p">,</span> <span class="n">vertices</span><span class="p">,</span> <span class="kc">False</span>
                <span class="p">)</span>

                <span class="c1"># We can check the other face as well if we want to be super precise. If they dont&#39; agree, we then check against the entire polyhedron.</span>
                <span class="c1"># We have not found any cases in which this is necessary, but it is included just in case.</span>
                <span class="k">if</span> <span class="n">superFine</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">closeFaces</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">uniquePoints2</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="p">[</span>
                            <span class="n">uniquePoints2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">closeFaces</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                            <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">uniquePoints2</span>
                        <span class="p">]</span>
                        <span class="n">uniquePointsCoords2</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[</span><span class="n">uniquePoints2</span><span class="p">]</span>
                        <span class="n">endPoint2</span> <span class="o">=</span> <span class="n">findPointsCenter</span><span class="p">(</span><span class="n">uniquePointsCoords2</span><span class="p">)</span>
                        <span class="n">numHits2</span><span class="p">,</span> <span class="n">thisBackFace2</span> <span class="o">=</span> <span class="n">f_ray_intersect_polyhedron</span><span class="p">(</span>
                            <span class="n">g</span><span class="o">.</span><span class="n">globalCoord</span><span class="p">,</span>
                            <span class="n">endPoint2</span><span class="p">,</span>
                            <span class="n">g</span><span class="o">.</span><span class="n">closeFaces</span><span class="p">,</span>
                            <span class="n">vertices</span><span class="p">,</span>
                            <span class="kc">False</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">closeFaces</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">thisBackFace</span> <span class="o">!=</span> <span class="n">thisBackFace2</span><span class="p">:</span>
                        <span class="n">mismatchCounter</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="n">numHits</span><span class="p">,</span> <span class="n">thisBackFace</span> <span class="o">=</span> <span class="n">f_ray_intersect_polyhedron</span><span class="p">(</span>
                            <span class="n">g</span><span class="o">.</span><span class="n">globalCoord</span><span class="p">,</span>
                            <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]),</span>
                            <span class="n">faces</span><span class="p">,</span>
                            <span class="n">vertices</span><span class="p">,</span>
                            <span class="kc">False</span><span class="p">,</span>
                        <span class="p">)</span>

                <span class="c1"># Fill in inside outside attribute for this point, as pRayStartPos, pRayEndPos, faces, vertices, pTruncateToSegmentll as for any points before it</span>
                <span class="n">g</span><span class="o">.</span><span class="n">isOutside</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">thisBackFace</span>
                <span class="n">isOutsideTracker</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">thisBackFace</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">emptyPointIndicies</span><span class="p">:</span>
                    <span class="n">gridPoints</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">isOutside</span> <span class="o">=</span> <span class="n">isOutsideTracker</span>
                <span class="c1"># Because we have filled in all the unknowns, we can reset that counter.</span>
                <span class="n">emptyPointIndicies</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Final pass through for sanity checks.</span>
        <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">gridPoints</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">representsPolyhedron</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">g</span><span class="o">.</span><span class="n">isOutside</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">isOutside</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">g</span><span class="o">.</span><span class="n">isOutside</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot;Flood filling grid inside/outside took &quot;</span>
            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">timeFinishProjection</span><span class="p">)</span>
            <span class="o">+</span> <span class="s2">&quot; seconds.&quot;</span>
        <span class="p">)</span>
        <span class="n">insidePoints</span> <span class="o">=</span> <span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">globalCoord</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">gridPoints</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">g</span><span class="o">.</span><span class="n">isOutside</span><span class="p">]</span>
        <span class="c1"># outsidePoints = [g.index for g in gridPoints if g.isOutside == True]</span>
        <span class="n">surfacePoints</span> <span class="o">=</span> <span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">globalCoord</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">gridPoints</span> <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">representsPolyhedron</span><span class="p">]</span>
        <span class="c1"># distance ?</span>
        <span class="k">if</span> <span class="n">superFine</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;Superfine was on and it identified &quot;</span>
                <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">mismatchCounter</span><span class="p">)</span>
                <span class="o">+</span> <span class="s2">&quot; mismatches.&quot;</span>
            <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot;Grid construction took &quot;</span>
            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">startTime</span><span class="p">)</span>
            <span class="o">+</span> <span class="s2">&quot; seconds for &quot;</span>
            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">faces</span><span class="p">))</span>
            <span class="o">+</span> <span class="s2">&quot; faces and &quot;</span>
            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">gridPoints</span><span class="p">))</span>
            <span class="o">+</span> <span class="s2">&quot; points.&quot;</span>
        <span class="p">)</span>
        <span class="c1"># what are the grid distance opinmt ?self.grid_distances</span>
        <span class="k">return</span> <span class="n">insidePoints</span><span class="p">,</span> <span class="n">surfacePoints</span></div>


<div class="viewcode-block" id="Compartment.getSurfaceInnerPoints_sdf_interpolate">
<a class="viewcode-back" href="../../../cellpack.autopack.html#cellpack.autopack.Compartment.Compartment.getSurfaceInnerPoints_sdf_interpolate">[docs]</a>
    <span class="k">def</span> <span class="nf">getSurfaceInnerPoints_sdf_interpolate</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">boundingBox</span><span class="p">,</span> <span class="n">spacing</span><span class="p">,</span> <span class="n">display</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">useFix</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Only compute the inner point. No grid.</span>
<span class="sd">        This is independant from the packing. Help build ingredient sphere tree and representation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">autopack.Environment</span> <span class="kn">import</span> <span class="n">Grid</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="n">grid</span> <span class="o">=</span> <span class="n">Grid</span><span class="p">()</span>
        <span class="n">grid</span><span class="o">.</span><span class="n">boundingBox</span> <span class="o">=</span> <span class="n">boundingBox</span>
        <span class="n">grid</span><span class="o">.</span><span class="n">gridSpacing</span> <span class="o">=</span> <span class="n">spacing</span>  <span class="c1"># = self.smallestProteinSize*1.1547  # 2/sqrt(3)????</span>
        <span class="n">helper</span><span class="o">.</span><span class="n">progressBar</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;BuildGRid&quot;</span><span class="p">)</span>
        <span class="n">grid</span><span class="o">.</span><span class="n">gridVolume</span><span class="p">,</span> <span class="n">grid</span><span class="o">.</span><span class="n">nbGridPoints</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">computeGridNumberOfPoint</span><span class="p">(</span>
            <span class="n">boundingBox</span><span class="p">,</span> <span class="n">spacing</span>
        <span class="p">)</span>
        <span class="n">grid</span><span class="o">.</span><span class="n">create3DPointLookup</span><span class="p">()</span>
        <span class="n">nbPoints</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">gridVolume</span>
        <span class="n">grid</span><span class="o">.</span><span class="n">compartment_ids</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">nbPoints</span>
        <span class="n">xl</span><span class="p">,</span> <span class="n">yl</span><span class="p">,</span> <span class="n">zl</span> <span class="o">=</span> <span class="n">boundingBox</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">xr</span><span class="p">,</span> <span class="n">yr</span><span class="p">,</span> <span class="n">zr</span> <span class="o">=</span> <span class="n">boundingBox</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># distToClosestSurf is set to self.diag initially</span>
        <span class="n">grid</span><span class="o">.</span><span class="n">diag</span> <span class="o">=</span> <span class="n">diag</span> <span class="o">=</span> <span class="n">vlen</span><span class="p">(</span><span class="n">vdiff</span><span class="p">((</span><span class="n">xr</span><span class="p">,</span> <span class="n">yr</span><span class="p">,</span> <span class="n">zr</span><span class="p">),</span> <span class="p">(</span><span class="n">xl</span><span class="p">,</span> <span class="n">yl</span><span class="p">,</span> <span class="n">zl</span><span class="p">)))</span>
        <span class="n">grid</span><span class="o">.</span><span class="n">distToClosestSurf</span> <span class="o">=</span> <span class="p">[</span><span class="n">diag</span><span class="p">]</span> <span class="o">*</span> <span class="n">nbPoints</span>
        <span class="n">diag</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">diag</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="mi">16</span>
        <span class="n">dim1</span> <span class="o">=</span> <span class="n">dim</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">dim1</span> <span class="o">*</span> <span class="n">dim1</span> <span class="o">*</span> <span class="n">dim1</span>
        <span class="kn">from</span> <span class="nn">UTpackages.UTsdf</span> <span class="kn">import</span> <span class="n">utsdf</span>

        <span class="n">verts</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;f&quot;</span><span class="p">)</span>
        <span class="n">tris</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">faces</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int&quot;</span><span class="p">)</span>
        <span class="n">utsdf</span><span class="o">.</span><span class="n">setParameters</span><span class="p">(</span>
            <span class="n">dim</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="p">)</span>  <span class="c1"># size, bool isNormalFlip, bool insideZero,bufferArr</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;ok grid points&quot;</span><span class="p">)</span>
        <span class="c1"># datap = utsdf.computeSDF(N.ascontiguousarray(verts, dtype=N.float32),N.ascontiguousarray(tris, dtype=N.int32))</span>
        <span class="n">datap</span> <span class="o">=</span> <span class="n">utsdf</span><span class="o">.</span><span class="n">computeSDF</span><span class="p">(</span><span class="n">verts</span><span class="p">,</span> <span class="n">tris</span><span class="p">)</span>  <span class="c1"># noncontiguous?</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;ok computeSDF &quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">verts</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">tris</span><span class="p">))</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">utsdf</span><span class="o">.</span><span class="n">createNumArr</span><span class="p">(</span><span class="n">datap</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
        <span class="n">volarr</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:]</span>
        <span class="n">volarr</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">dim1</span><span class="p">,</span> <span class="n">dim1</span><span class="p">,</span> <span class="n">dim1</span><span class="p">)</span>
        <span class="n">volarr</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">volarr</span><span class="p">),</span> <span class="s2">&quot;f&quot;</span><span class="p">)</span>

        <span class="c1"># get grid points distances to compartment surface</span>
        <span class="kn">from</span> <span class="nn">Volume.Operators.trilinterp</span> <span class="kn">import</span> <span class="n">trilinterp</span>

        <span class="n">sizex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getSizeXYZ</span><span class="p">()</span>
        <span class="n">invstep</span> <span class="o">=</span> <span class="p">(</span>
            <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">sizex</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">dim</span><span class="p">),</span>
            <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">sizex</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">dim</span><span class="p">),</span>
            <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">sizex</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">dim</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">origin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">distFromSurf</span> <span class="o">=</span> <span class="n">trilinterp</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">masterGridPositions</span><span class="p">,</span> <span class="n">volarr</span><span class="p">,</span> <span class="n">invstep</span><span class="p">,</span> <span class="n">origin</span><span class="p">)</span>
        <span class="c1"># update histoVol.distToClosestSurf</span>
        <span class="n">distance</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">distToClosestSurf</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">distFromSurf</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">distance</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">d</span><span class="p">:</span>
                <span class="n">distance</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid_distances</span> <span class="o">=</span> <span class="n">distance</span>
        <span class="c1">#        idarray = histoVol.compartment_ids</span>
        <span class="n">indice</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">less</span><span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">))</span>
        <span class="n">pointinside</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">masterGridPositions</span><span class="p">,</span> <span class="n">indice</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="c1"># need to update the surface. need to create a aligned grid</span>
        <span class="k">return</span> <span class="n">pointinside</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span></div>


<div class="viewcode-block" id="Compartment.getSurfaceInnerPoints">
<a class="viewcode-back" href="../../../cellpack.autopack.html#cellpack.autopack.Compartment.Compartment.getSurfaceInnerPoints">[docs]</a>
    <span class="k">def</span> <span class="nf">getSurfaceInnerPoints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">boundingBox</span><span class="p">,</span> <span class="n">spacing</span><span class="p">,</span> <span class="n">display</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">useFix</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Only compute the inner point. No grid.</span>
<span class="sd">        This is independant from the packing. Help build ingredient sphere tree and representation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">autopack.Environment</span> <span class="kn">import</span> <span class="n">Grid</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="n">grid</span> <span class="o">=</span> <span class="n">Grid</span><span class="p">()</span>
        <span class="n">grid</span><span class="o">.</span><span class="n">boundingBox</span> <span class="o">=</span> <span class="n">boundingBox</span>
        <span class="n">grid</span><span class="o">.</span><span class="n">gridSpacing</span> <span class="o">=</span> <span class="n">spacing</span>  <span class="c1"># = self.smallestProteinSize*1.1547  # 2/sqrt(3)????</span>
        <span class="n">helper</span><span class="o">.</span><span class="n">progressBar</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;BuildGRid&quot;</span><span class="p">)</span>
        <span class="n">grid</span><span class="o">.</span><span class="n">gridVolume</span><span class="p">,</span> <span class="n">grid</span><span class="o">.</span><span class="n">nbGridPoints</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">computeGridNumberOfPoint</span><span class="p">(</span>
            <span class="n">boundingBox</span><span class="p">,</span> <span class="n">spacing</span>
        <span class="p">)</span>
        <span class="n">grid</span><span class="o">.</span><span class="n">create3DPointLookup</span><span class="p">()</span>
        <span class="n">nbPoints</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">gridVolume</span>
        <span class="n">grid</span><span class="o">.</span><span class="n">compartment_ids</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">nbPoints</span>
        <span class="n">xl</span><span class="p">,</span> <span class="n">yl</span><span class="p">,</span> <span class="n">zl</span> <span class="o">=</span> <span class="n">boundingBox</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">xr</span><span class="p">,</span> <span class="n">yr</span><span class="p">,</span> <span class="n">zr</span> <span class="o">=</span> <span class="n">boundingBox</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># distToClosestSurf is set to self.diag initially</span>
        <span class="n">grid</span><span class="o">.</span><span class="n">diag</span> <span class="o">=</span> <span class="n">diag</span> <span class="o">=</span> <span class="n">vlen</span><span class="p">(</span><span class="n">vdiff</span><span class="p">((</span><span class="n">xr</span><span class="p">,</span> <span class="n">yr</span><span class="p">,</span> <span class="n">zr</span><span class="p">),</span> <span class="p">(</span><span class="n">xl</span><span class="p">,</span> <span class="n">yl</span><span class="p">,</span> <span class="n">zl</span><span class="p">)))</span>
        <span class="n">grid</span><span class="o">.</span><span class="n">distToClosestSurf</span> <span class="o">=</span> <span class="p">[</span><span class="n">diag</span><span class="p">]</span> <span class="o">*</span> <span class="n">nbPoints</span>
        <span class="n">distances</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">distToClosestSurf</span>
        <span class="n">idarray</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">compartment_ids</span>
        <span class="n">diag</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">diag</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ogsurfacePoints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ogsurfacePointsNormals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vnormals</span><span class="p">[</span>
            <span class="p">:</span>
        <span class="p">]</span>  <span class="c1"># helper.FixNormals(self.vertices,self.faces,self.vnormals,fn=self.fnormals)</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="n">getTransformation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ref_obj</span><span class="p">)</span>
        <span class="c1"># c4dmat = poly.GetMg()</span>
        <span class="c1"># mat,imat = self.c4dMat2numpy(c4dmat)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">normals</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="n">FixNormals</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">faces</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vnormals</span><span class="p">,</span> <span class="n">fn</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fnormals</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ogsurfacePointsNormals</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="n">ApplyMatrix</span><span class="p">(</span>
            <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">normals</span><span class="p">),</span> <span class="n">helper</span><span class="o">.</span><span class="n">ToMat</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">surfacePoints</span> <span class="o">=</span> <span class="n">srfPts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ogsurfacePoints</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">OGsrfPtsBht</span> <span class="o">=</span> <span class="n">bht</span> <span class="o">=</span> <span class="n">spatial</span><span class="o">.</span><span class="n">cKDTree</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">srfPts</span><span class="p">),</span> <span class="n">leafsize</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>

        <span class="n">res</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">srfPts</span><span class="p">),</span> <span class="s2">&quot;f&quot;</span><span class="p">)</span>
        <span class="n">dist2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">srfPts</span><span class="p">),</span> <span class="s2">&quot;f&quot;</span><span class="p">)</span>

        <span class="n">number</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number</span>
        <span class="n">ogNormals</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ogsurfacePointsNormals</span><span class="p">)</span>
        <span class="n">insidePoints</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># find closest off grid surface point for each grid point</span>
        <span class="c1"># FIXME sould be diag of compartment BB inside fillBB</span>
        <span class="n">grdPos</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">masterGridPositions</span>
        <span class="n">returnNullIfFail</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">closest</span> <span class="o">=</span> <span class="n">bht</span><span class="o">.</span><span class="n">closestPointsArray</span><span class="p">(</span>
            <span class="nb">tuple</span><span class="p">(</span><span class="n">grdPos</span><span class="p">),</span> <span class="n">diag</span><span class="p">,</span> <span class="n">returnNullIfFail</span>
        <span class="p">)</span>  <span class="c1"># diag is  cutoff ? meanin max distance ?</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">closestId</span> <span class="o">=</span> <span class="n">closest</span>
        <span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>
        <span class="n">helper</span><span class="o">.</span><span class="n">resetProgressBar</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">display</span><span class="p">:</span>
            <span class="n">sph</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="s2">&quot;gPts&quot;</span><span class="p">,</span> <span class="n">res</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mf">20.0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">sph2</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="s2">&quot;sPts&quot;</span><span class="p">,</span> <span class="n">res</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mf">20.0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">cylN</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="n">oneCylinder</span><span class="p">(</span>
                <span class="s2">&quot;normal&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span> <span class="n">radius</span><span class="o">=</span><span class="mf">20.0</span>
            <span class="p">)</span>
            <span class="n">helper</span><span class="o">.</span><span class="n">oneCylinder</span><span class="p">(</span><span class="s2">&quot;V&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span> <span class="n">radius</span><span class="o">=</span><span class="mf">20.0</span><span class="p">)</span>
            <span class="n">helper</span><span class="o">.</span><span class="n">changeObjColorMat</span><span class="p">(</span><span class="n">sph2</span><span class="p">,</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">ptInd</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">grdPos</span><span class="p">)):</span>  <span class="c1"># len(grdPos)):</span>
            <span class="c1"># find closest OGsurfacepoint</span>
            <span class="k">if</span> <span class="n">display</span><span class="p">:</span>
                <span class="n">helper</span><span class="o">.</span><span class="n">changeObjColorMat</span><span class="p">(</span><span class="n">sph</span><span class="p">,</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">))</span>
                <span class="n">helper</span><span class="o">.</span><span class="n">changeObjColorMat</span><span class="p">(</span><span class="n">cylN</span><span class="p">,</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">))</span>
            <span class="n">inside</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">gx</span><span class="p">,</span> <span class="n">gy</span><span class="p">,</span> <span class="n">gz</span> <span class="o">=</span> <span class="n">grdPos</span><span class="p">[</span><span class="n">ptInd</span><span class="p">]</span>
            <span class="n">sptInd</span> <span class="o">=</span> <span class="n">closest</span><span class="p">[</span><span class="n">ptInd</span><span class="p">]</span>  <span class="c1"># this is a vertices</span>
            <span class="k">if</span> <span class="n">display</span><span class="p">:</span>
                <span class="n">helper</span><span class="o">.</span><span class="n">setTranslation</span><span class="p">(</span><span class="n">sph</span><span class="p">,</span> <span class="n">grdPos</span><span class="p">[</span><span class="n">ptInd</span><span class="p">])</span>
                <span class="n">helper</span><span class="o">.</span><span class="n">setTranslation</span><span class="p">(</span><span class="n">sph2</span><span class="p">,</span> <span class="n">srfPts</span><span class="p">[</span><span class="n">sptInd</span><span class="p">])</span>
            <span class="c1">#            helper.update()</span>
            <span class="k">if</span> <span class="n">closest</span><span class="p">[</span><span class="n">ptInd</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;ouhoua, closest OGsurfacePoint = -1&quot;</span><span class="p">)</span>
                <span class="c1"># pdb.set_trace()</span>
                <span class="k">return</span>
            <span class="k">if</span> <span class="n">sptInd</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">srfPts</span><span class="p">):</span>
                <span class="n">sx</span><span class="p">,</span> <span class="n">sy</span><span class="p">,</span> <span class="n">sz</span> <span class="o">=</span> <span class="n">srfPts</span><span class="p">[</span><span class="n">sptInd</span><span class="p">]</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">gx</span> <span class="o">-</span> <span class="n">sx</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">gx</span> <span class="o">-</span> <span class="n">sx</span><span class="p">)</span>
                    <span class="o">+</span> <span class="p">(</span><span class="n">gy</span> <span class="o">-</span> <span class="n">sy</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">gy</span> <span class="o">-</span> <span class="n">sy</span><span class="p">)</span>
                    <span class="o">+</span> <span class="p">(</span><span class="n">gz</span> <span class="o">-</span> <span class="n">sz</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">gz</span> <span class="o">-</span> <span class="n">sz</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1">#                try :</span>
                <span class="n">n</span> <span class="o">=</span> <span class="n">bht</span><span class="o">.</span><span class="n">closePointsDist2</span><span class="p">(</span>
                    <span class="nb">tuple</span><span class="p">(</span><span class="n">grdPos</span><span class="p">[</span><span class="n">ptInd</span><span class="p">]),</span> <span class="n">diag</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">dist2</span>
                <span class="p">)</span>  <span class="c1"># wthis is not working</span>
                <span class="n">d</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">dist2</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">n</span><span class="p">])</span>
                <span class="n">sptInd</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">dist2</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">d</span><span class="p">)]</span>
                <span class="n">sx</span><span class="p">,</span> <span class="n">sy</span><span class="p">,</span> <span class="n">sz</span> <span class="o">=</span> <span class="n">srfPts</span><span class="p">[</span><span class="n">sptInd</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">distances</span><span class="p">[</span><span class="n">ptInd</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">d</span><span class="p">:</span>
                <span class="n">distances</span><span class="p">[</span><span class="n">ptInd</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fnormals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">useFix</span><span class="p">:</span>
                <span class="c1"># too slow</span>
                <span class="n">facesN</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getFacesNfromV</span><span class="p">(</span><span class="n">sptInd</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="c1"># now lets get all fnormals and averge them</span>
                <span class="n">n</span> <span class="o">=</span> <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">facesN</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
            <span class="c1">#            print (faces)</span>

            <span class="c1"># check if ptInd in inside</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ogNormals</span><span class="p">[</span><span class="n">sptInd</span><span class="p">])</span>
            <span class="c1">#            vRayCollidePos = iRT.f_ray_intersect_polyhedron(numpy.array(grdPos[ptInd]), numpy.array(srfPts[sptInd]), self.ref_obj, 0,point = ptInd);</span>
            <span class="c1">#            if (vRayCollidePos %  2):</span>
            <span class="c1">#                print (&quot;inside&quot;)</span>
            <span class="c1">#                inside = True</span>
            <span class="c1">#                idarray[ptInd] = -number</span>
            <span class="c1">#                insidePoints.append(grdPos[ptInd])</span>
            <span class="c1">#            vnpos = numpy.array(npost[sptInd])</span>
            <span class="n">facesN</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getVNfromF</span><span class="p">(</span><span class="n">sptInd</span><span class="p">)</span>
            <span class="n">d1</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="n">measure_distance</span><span class="p">(</span>
                <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">grdPos</span><span class="p">[</span><span class="n">ptInd</span><span class="p">]),</span>
                <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">srfPts</span><span class="p">[</span><span class="n">sptInd</span><span class="p">])</span> <span class="o">+</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="mf">0.00001</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="n">d2</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="n">measure_distance</span><span class="p">(</span>
                <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">grdPos</span><span class="p">[</span><span class="n">ptInd</span><span class="p">]),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">srfPts</span><span class="p">[</span><span class="n">sptInd</span><span class="p">])</span>
            <span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;gridpont distance from surf normal </span><span class="si">%0.10f</span><span class="s2"> from surf  </span><span class="si">%0.10f</span><span class="s2"> closer to snormal </span><span class="si">%s</span><span class="s2">&quot;</span>
                <span class="o">%</span> <span class="p">(</span><span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">d1</span> <span class="o">&lt;</span> <span class="n">d2</span><span class="p">))</span>
            <span class="p">)</span>
            <span class="c1">#             check on what side of the surface point the grid point is</span>
            <span class="n">vptos</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">srfPts</span><span class="p">[</span><span class="n">sptInd</span><span class="p">])</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">grdPos</span><span class="p">[</span><span class="n">ptInd</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">display</span><span class="p">:</span>
                <span class="c1">#                helper.updateOneCylinder(&quot;normal&quot;,[0.,0.,0.],(n*spacing),radius=1.0)#srfPts[sptInd],numpy.array(srfPts[sptInd])+(n*spacing*10.0),radius=10.0)</span>
                <span class="c1">#                helper.updateOneCylinder(&quot;V&quot;,[0.,0,0.],vptos,radius=1.0)#srfPts[sptInd],numpy.array(srfPts[sptInd])+(v*spacing*10.0),radius=10.0)</span>
                <span class="n">helper</span><span class="o">.</span><span class="n">updateOneCylinder</span><span class="p">(</span>
                    <span class="s2">&quot;normal&quot;</span><span class="p">,</span>
                    <span class="n">srfPts</span><span class="p">[</span><span class="n">sptInd</span><span class="p">],</span>
                    <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">srfPts</span><span class="p">[</span><span class="n">sptInd</span><span class="p">])</span> <span class="o">+</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="n">spacing</span> <span class="o">*</span> <span class="mf">10.0</span><span class="p">),</span>
                    <span class="n">radius</span><span class="o">=</span><span class="mf">10.0</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">helper</span><span class="o">.</span><span class="n">updateOneCylinder</span><span class="p">(</span>
                    <span class="s2">&quot;V&quot;</span><span class="p">,</span>
                    <span class="n">srfPts</span><span class="p">[</span><span class="n">sptInd</span><span class="p">],</span>
                    <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">srfPts</span><span class="p">[</span><span class="n">sptInd</span><span class="p">])</span> <span class="o">+</span> <span class="p">(</span><span class="n">vptos</span> <span class="o">*</span> <span class="n">spacing</span> <span class="o">*</span> <span class="mf">10.0</span><span class="p">),</span>
                    <span class="n">radius</span><span class="o">=</span><span class="mf">10.0</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">helper</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
            <span class="n">dots</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">vptos</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">vptos</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="n">facesN</span><span class="p">:</span>
                <span class="n">dot</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vptos</span><span class="p">,</span> <span class="n">fn</span><span class="p">)</span>
                <span class="n">dots</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dot</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">display</span><span class="p">:</span>
                    <span class="n">helper</span><span class="o">.</span><span class="n">updateOneCylinder</span><span class="p">(</span>
                        <span class="s2">&quot;normal&quot;</span><span class="p">,</span>
                        <span class="n">srfPts</span><span class="p">[</span><span class="n">sptInd</span><span class="p">],</span>
                        <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">srfPts</span><span class="p">[</span><span class="n">sptInd</span><span class="p">])</span> <span class="o">+</span> <span class="p">(</span><span class="n">fn</span> <span class="o">*</span> <span class="n">spacing</span> <span class="o">*</span> <span class="mf">10.0</span><span class="p">),</span>
                        <span class="n">radius</span><span class="o">=</span><span class="mf">10.0</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">helper</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
            <span class="n">gr</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">greater</span><span class="p">(</span><span class="n">dots</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
            <span class="c1">#            print dots</span>
            <span class="c1">#            print gr</span>
            <span class="n">include</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="kc">True</span> <span class="ow">in</span> <span class="n">gr</span> <span class="ow">and</span> <span class="kc">False</span> <span class="ow">in</span> <span class="n">gr</span><span class="p">:</span>
                <span class="n">include</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">dot</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vptos</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>  <span class="c1"># project vptos on n -1 0 1</span>
            <span class="n">vx</span><span class="p">,</span> <span class="n">vy</span><span class="p">,</span> <span class="n">vz</span> <span class="o">=</span> <span class="p">(</span><span class="n">gx</span> <span class="o">-</span> <span class="n">sx</span><span class="p">,</span> <span class="n">gy</span> <span class="o">-</span> <span class="n">sy</span><span class="p">,</span> <span class="n">gz</span> <span class="o">-</span> <span class="n">sz</span><span class="p">)</span>
            <span class="n">dot2</span> <span class="o">=</span> <span class="n">vx</span> <span class="o">*</span> <span class="n">nx</span> <span class="o">+</span> <span class="n">vy</span> <span class="o">*</span> <span class="n">ny</span> <span class="o">+</span> <span class="n">vz</span> <span class="o">*</span> <span class="n">nz</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="n">angle_between_vectors</span><span class="p">(</span><span class="n">vptos</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">dot</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="ow">and</span> <span class="n">include</span>
            <span class="p">):</span>  <span class="c1"># and d1 &gt; d2 :#and dot &lt; (-1.*10E-5): # inside ?</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;INSIDE&quot;</span><span class="p">,</span> <span class="n">dot</span><span class="p">,</span> <span class="n">dot2</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>

                <span class="c1"># and the point is actually inside the mesh bounding box</span>
                <span class="n">inside</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="c1"># this is not working for a plane, or any unclosed compartment...</span>
                <span class="k">if</span> <span class="n">inside</span><span class="p">:</span>
                    <span class="n">idarray</span><span class="p">[</span><span class="n">ptInd</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">number</span>
                    <span class="n">insidePoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">grdPos</span><span class="p">[</span><span class="n">ptInd</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">display</span><span class="p">:</span>
                    <span class="n">helper</span><span class="o">.</span><span class="n">changeObjColorMat</span><span class="p">(</span><span class="n">sph</span><span class="p">,</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">))</span>
                    <span class="n">helper</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
                    <span class="n">res</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="n">drawQuestion</span><span class="p">(</span>
                        <span class="n">title</span><span class="o">=</span><span class="s2">&quot;Inside?&quot;</span><span class="p">,</span>
                        <span class="n">question</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">%0.2f</span><span class="s2"> </span><span class="si">%0.2f</span><span class="s2"> </span><span class="si">%0.2f</span><span class="s2"> </span><span class="si">%0.2f</span><span class="s2"> </span><span class="si">%s</span><span class="s2">&quot;</span>
                        <span class="o">%</span> <span class="p">(</span><span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">inside</span><span class="p">)),</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">res</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">insidePoints</span><span class="p">,</span> <span class="n">surfacePoints</span>
                    <span class="c1">#                sleep(5.0)</span>

            <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">ptInd</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">grdPos</span><span class="p">)))</span> <span class="o">*</span> <span class="mf">100.0</span>
            <span class="n">helper</span><span class="o">.</span><span class="n">progressBar</span><span class="p">(</span>
                <span class="n">progress</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">p</span><span class="p">),</span>
                <span class="n">label</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">ptInd</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;/&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">grdPos</span><span class="p">))</span> <span class="o">+</span> <span class="s2">&quot; inside &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">inside</span><span class="p">),</span>
            <span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;total time&quot;</span><span class="p">,</span> <span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">t1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid_distances</span> <span class="o">=</span> <span class="n">distances</span>
        <span class="k">return</span> <span class="n">insidePoints</span><span class="p">,</span> <span class="n">surfacePoints</span></div>


<div class="viewcode-block" id="Compartment.create_voxelized_mask">
<a class="viewcode-back" href="../../../cellpack.autopack.html#cellpack.autopack.Compartment.Compartment.create_voxelized_mask">[docs]</a>
    <span class="k">def</span> <span class="nf">create_voxelized_mask</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">x_width</span><span class="p">,</span>
        <span class="n">y_width</span><span class="p">,</span>
        <span class="n">z_width</span><span class="p">,</span>
        <span class="n">center</span><span class="p">,</span>
        <span class="n">voxel_size</span><span class="p">,</span>
        <span class="n">mesh_store</span><span class="p">,</span>
        <span class="n">hollow</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a mask of the compartment voxelization</span>

<span class="sd">        :param x_width: number of voxels in the x direction</span>
<span class="sd">        :param y_width: number of voxels in the y direction</span>
<span class="sd">        :param z_width: number of voxels in the z direction</span>
<span class="sd">        :param center: center of the voxelization</span>
<span class="sd">        :param voxel_size: size of the voxels</span>
<span class="sd">        :param mesh_store: mesh store</span>
<span class="sd">        :param hollow: if True, the mask will be hollow otherwise it will fill in the segmentation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">voxel_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">voxel_size</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">center</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># use the middle of the grid</span>
            <span class="n">center</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bounding_box</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounding_box</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mf">2.0</span>

        <span class="n">Z</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">X</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span>
            <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">z_width</span><span class="p">),</span>
            <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">y_width</span><span class="p">),</span>
            <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">x_width</span><span class="p">),</span>
            <span class="n">indexing</span><span class="o">=</span><span class="s2">&quot;ij&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">column_stack</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="p">(</span><span class="n">X</span> <span class="o">*</span> <span class="n">voxel_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span>
                <span class="p">(</span><span class="n">Y</span> <span class="o">*</span> <span class="n">voxel_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span>
                <span class="p">(</span><span class="n">Z</span> <span class="o">*</span> <span class="n">voxel_size</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">center</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span>
            <span class="p">]</span>
        <span class="p">)</span>

        <span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh_store</span><span class="o">.</span><span class="n">get_mesh</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gname</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">hollow</span><span class="p">:</span>
            <span class="n">trimesh_grid</span> <span class="o">=</span> <span class="n">creation</span><span class="o">.</span><span class="n">voxelize</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">pitch</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">voxel_size</span><span class="p">))</span><span class="o">.</span><span class="n">hollow</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">trimesh_grid</span> <span class="o">=</span> <span class="n">creation</span><span class="o">.</span><span class="n">voxelize</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">pitch</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">voxel_size</span><span class="p">))</span><span class="o">.</span><span class="n">fill</span><span class="p">()</span>

        <span class="n">mask_ravel</span> <span class="o">=</span> <span class="n">trimesh_grid</span><span class="o">.</span><span class="n">is_filled</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">mask_ravel</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">x_width</span><span class="p">,</span> <span class="n">y_width</span><span class="p">,</span> <span class="n">z_width</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;F&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">mask</span></div>


<div class="viewcode-block" id="Compartment.create_voxelization">
<a class="viewcode-back" href="../../../cellpack.autopack.html#cellpack.autopack.Compartment.Compartment.create_voxelization">[docs]</a>
    <span class="k">def</span> <span class="nf">create_voxelization</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">image_data</span><span class="p">,</span>
        <span class="n">bounding_box</span><span class="p">,</span>
        <span class="n">voxel_size</span><span class="p">,</span>
        <span class="n">image_size</span><span class="p">,</span>
        <span class="n">position</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a voxelization mask at the position of the compartment</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;mesh_store&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;mesh_store must be provided for compartment voxelization&quot;</span>
            <span class="p">)</span>

        <span class="n">mesh_store</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;mesh_store&quot;</span><span class="p">]</span>
        <span class="n">hollow</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;hollow&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="n">relative_position</span> <span class="o">=</span> <span class="n">position</span> <span class="o">-</span> <span class="n">bounding_box</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_voxelized_mask</span><span class="p">(</span>
            <span class="o">*</span><span class="n">image_size</span><span class="p">,</span>
            <span class="n">center</span><span class="o">=</span><span class="n">relative_position</span><span class="p">,</span>
            <span class="n">voxel_size</span><span class="o">=</span><span class="n">voxel_size</span><span class="p">,</span>
            <span class="n">mesh_store</span><span class="o">=</span><span class="n">mesh_store</span><span class="p">,</span>
            <span class="n">hollow</span><span class="o">=</span><span class="n">hollow</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">image_data</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="mi">255</span>

        <span class="k">return</span> <span class="n">image_data</span></div>


<div class="viewcode-block" id="Compartment.printFillInfo">
<a class="viewcode-back" href="../../../cellpack.autopack.html#cellpack.autopack.Compartment.Compartment.printFillInfo">[docs]</a>
    <span class="k">def</span> <span class="nf">printFillInfo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;print some info about the compartment and its recipe&quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;compartment </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">number</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surfaceRecipe</span>
        <span class="k">if</span> <span class="n">r</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;    surface recipe:&quot;</span><span class="p">)</span>
            <span class="n">r</span><span class="o">.</span><span class="n">printFillInfo</span><span class="p">(</span><span class="s2">&quot;        &quot;</span><span class="p">)</span>

        <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">innerRecipe</span>
        <span class="k">if</span> <span class="n">r</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;    interior recipe:&quot;</span><span class="p">)</span>
            <span class="n">r</span><span class="o">.</span><span class="n">printFillInfo</span><span class="p">(</span><span class="s2">&quot;        &quot;</span><span class="p">)</span></div>
</div>

</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">cellPack 1.0.8 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../cellpack.html" >cellpack</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="../autopack.html" >cellpack.autopack</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">cellpack.autopack.Compartment</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2021, Megan Riel-Mehan.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    </div>
  </body>
</html>