<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>cellpack.autopack.ingredient.grow &#8212; cellPack 1.0.3 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/classic.css" />
    
    <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    <script src="../../../../_static/sphinx_highlight.js"></script>
    
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">cellPack 1.0.3 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../../cellpack.html" >cellpack</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="../../autopack.html" accesskey="U">cellpack.autopack</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">cellpack.autopack.ingredient.grow</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for cellpack.autopack.ingredient.grow</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>

<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">spatial</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">matrix</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">pi</span><span class="p">,</span> <span class="n">sqrt</span>
<span class="kn">from</span> <span class="nn">panda3d.core</span> <span class="kn">import</span> <span class="n">Point3</span><span class="p">,</span> <span class="n">TransformState</span>
<span class="kn">from</span> <span class="nn">panda3d.bullet</span> <span class="kn">import</span> <span class="n">BulletSphereShape</span><span class="p">,</span> <span class="n">BulletRigidBodyNode</span>
<span class="kn">from</span> <span class="nn">random</span> <span class="kn">import</span> <span class="n">uniform</span><span class="p">,</span> <span class="n">gauss</span><span class="p">,</span> <span class="n">random</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">from</span> <span class="nn">cellpack.autopack.ingredient.Ingredient</span> <span class="kn">import</span> <span class="n">Ingredient</span>

<span class="kn">from</span> <span class="nn">cellpack.autopack.transformation</span> <span class="kn">import</span> <span class="n">angle_between_vectors</span>
<span class="kn">from</span> <span class="nn">cellpack.autopack.ldSequence</span> <span class="kn">import</span> <span class="n">SphereHalton</span>
<span class="kn">from</span> <span class="nn">cellpack.autopack.BaseGrid</span> <span class="kn">import</span> <span class="n">BaseGrid</span> <span class="k">as</span> <span class="n">BaseGrid</span>
<span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="n">rotVectToVect</span><span class="p">,</span> <span class="n">get_reflected_point</span>

<span class="kn">import</span> <span class="nn">cellpack.autopack</span> <span class="k">as</span> <span class="nn">autopack</span>

<span class="kn">from</span> <span class="nn">.multi_cylinder</span> <span class="kn">import</span> <span class="n">MultiCylindersIngr</span>

<span class="n">helper</span> <span class="o">=</span> <span class="n">autopack</span><span class="o">.</span><span class="n">helper</span>


<div class="viewcode-block" id="GrowIngredient"><a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.grow.GrowIngredient">[docs]</a><span class="k">class</span> <span class="nc">GrowIngredient</span><span class="p">(</span><span class="n">MultiCylindersIngr</span><span class="p">):</span>
    <span class="n">ARGUMENTS</span> <span class="o">=</span> <span class="n">Ingredient</span><span class="o">.</span><span class="n">ARGUMENTS</span>
    <span class="n">ARGUMENTS</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="s2">&quot;length&quot;</span><span class="p">,</span>
            <span class="s2">&quot;closed&quot;</span><span class="p">,</span>
            <span class="s2">&quot;uLength&quot;</span><span class="p">,</span>
            <span class="s2">&quot;biased&quot;</span><span class="p">,</span>
            <span class="s2">&quot;marge&quot;</span><span class="p">,</span>
            <span class="s2">&quot;orientation&quot;</span><span class="p">,</span>
            <span class="s2">&quot;walkignMode&quot;</span><span class="p">,</span>
            <span class="s2">&quot;constraintMarge&quot;</span><span class="p">,</span>
            <span class="s2">&quot;useHalton&quot;</span><span class="p">,</span>
            <span class="s2">&quot;compMask&quot;</span><span class="p">,</span>
            <span class="s2">&quot;use_rbsphere&quot;</span><span class="p">,</span>
        <span class="p">]</span>
    <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">available_regions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;Grow&quot;</span><span class="p">,</span>
        <span class="n">biased</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
        <span class="n">closed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">color</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">compMask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">constraintMarge</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">cutoff_boundary</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
        <span class="n">cutoff_surface</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
        <span class="n">gradient</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">is_attractor</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">max_jitter</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
        <span class="n">length</span><span class="o">=</span><span class="mf">10.0</span><span class="p">,</span>
        <span class="n">marge</span><span class="o">=</span><span class="mf">20.0</span><span class="p">,</span>
        <span class="n">meshFile</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">meshObject</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">model_type</span><span class="o">=</span><span class="s2">&quot;Cylinders&quot;</span><span class="p">,</span>
        <span class="n">molarity</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
        <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">jitter_attempts</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
        <span class="n">count</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">orientation</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
        <span class="n">orient_bias_range</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="n">pi</span><span class="p">,</span> <span class="n">pi</span><span class="p">],</span>
        <span class="n">priority</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">packing_mode</span><span class="o">=</span><span class="s2">&quot;random&quot;</span><span class="p">,</span>
        <span class="n">partners</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">perturb_axis_amplitude</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
        <span class="n">place_method</span><span class="o">=</span><span class="s2">&quot;jitter&quot;</span><span class="p">,</span>
        <span class="n">positions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">positions2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">principal_vector</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
        <span class="n">radii</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">representations</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">rejection_threshold</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span>
        <span class="n">rotation_axis</span><span class="o">=</span><span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
        <span class="n">rotation_range</span><span class="o">=</span><span class="mf">6.2831</span><span class="p">,</span>
        <span class="n">source</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">uLength</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">use_rbsphere</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">useHalton</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">useLength</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">use_orient_bias</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">use_rotation_axis</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">walkingMode</span><span class="o">=</span><span class="s2">&quot;sphere&quot;</span><span class="p">,</span>
        <span class="n">weight</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="c1"># TODO: need to fix multi_bounds and radii settings</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">multi_bounds</span><span class="o">=</span><span class="p">[[],</span> <span class="p">[]],</span>
            <span class="n">radii</span><span class="o">=</span><span class="n">radii</span><span class="p">,</span>
            <span class="nb">type</span><span class="o">=</span><span class="nb">type</span><span class="p">,</span>
            <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span>
            <span class="n">cutoff_surface</span><span class="o">=</span><span class="n">cutoff_surface</span><span class="p">,</span>
            <span class="n">gradient</span><span class="o">=</span><span class="n">gradient</span><span class="p">,</span>
            <span class="n">is_attractor</span><span class="o">=</span><span class="n">is_attractor</span><span class="p">,</span>
            <span class="n">max_jitter</span><span class="o">=</span><span class="n">max_jitter</span><span class="p">,</span>
            <span class="n">molarity</span><span class="o">=</span><span class="n">molarity</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
            <span class="n">jitter_attempts</span><span class="o">=</span><span class="n">jitter_attempts</span><span class="p">,</span>
            <span class="n">count</span><span class="o">=</span><span class="n">count</span><span class="p">,</span>
            <span class="n">orient_bias_range</span><span class="o">=</span><span class="n">orient_bias_range</span><span class="p">,</span>
            <span class="n">priority</span><span class="o">=</span><span class="n">priority</span><span class="p">,</span>
            <span class="n">partners</span><span class="o">=</span><span class="n">partners</span><span class="p">,</span>
            <span class="n">perturb_axis_amplitude</span><span class="o">=</span><span class="n">perturb_axis_amplitude</span><span class="p">,</span>
            <span class="n">place_method</span><span class="o">=</span><span class="n">place_method</span><span class="p">,</span>
            <span class="n">principal_vector</span><span class="o">=</span><span class="n">principal_vector</span><span class="p">,</span>
            <span class="n">representations</span><span class="o">=</span><span class="n">representations</span><span class="p">,</span>
            <span class="n">rejection_threshold</span><span class="o">=</span><span class="n">rejection_threshold</span><span class="p">,</span>
            <span class="n">rotation_axis</span><span class="o">=</span><span class="n">rotation_axis</span><span class="p">,</span>
            <span class="n">rotation_range</span><span class="o">=</span><span class="n">rotation_range</span><span class="p">,</span>
            <span class="n">use_orient_bias</span><span class="o">=</span><span class="n">use_orient_bias</span><span class="p">,</span>
            <span class="n">use_rotation_axis</span><span class="o">=</span><span class="n">use_rotation_axis</span><span class="p">,</span>
            <span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">_</span><span class="si">%f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">radii</span><span class="p">),</span> <span class="n">molarity</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model_type</span> <span class="o">=</span> <span class="n">model_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">collisionLevel</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_radius</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">radii</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">marge</span> <span class="o">=</span> <span class="n">marge</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">closed</span> <span class="o">=</span> <span class="n">closed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nbCurve</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start_positions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">listePtLinear</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">listePtCurve</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># snake</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Ptis</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># snakePts</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">startGridPoint</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">currentLength</span> <span class="o">=</span> <span class="mf">0.0</span>  <span class="c1"># snakelength</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">direction</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># direction of growing</span>
        <span class="c1"># can be place either using grid point/jittering or dynamics</span>
        <span class="c1">#        self.uLength = 0. #length of the cylinder or averall radius for sphere, this is the lenght of one unit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">uLength</span> <span class="o">=</span> <span class="n">uLength</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">positions2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">uLength</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">uLength</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">radii</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vector</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">principal_vector</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">uLength</span> <span class="o">/</span> <span class="mf">2.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">positions</span> <span class="o">=</span> <span class="p">[[(</span><span class="bp">self</span><span class="o">.</span><span class="n">vector</span> <span class="o">*</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()]]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">positions2</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">vector</span><span class="o">.</span><span class="n">tolist</span><span class="p">()]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">positions2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">v</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">measure_distance</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">positions2</span><span class="p">,</span> <span class="n">vec</span><span class="o">=</span><span class="kc">True</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">uLength</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">uLength</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">radii</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">encapsulating_radius</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">uLength</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unitNumberF</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># number of unit pose so far forward</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unitNumberR</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># number of unit pose so far reverse</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">orientation</span> <span class="o">=</span> <span class="n">orientation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seedOnPlus</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># The filament should continue to grow on its (+) end</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seedOnMinus</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># The filamen should continue to grow on its (-) end.</span>
        <span class="c1">#        if self.compNum &gt; 0 :</span>
        <span class="c1">#            self.seedOnMinus = False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vector</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">biased</span> <span class="o">=</span> <span class="n">biased</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">absoluteLengthMax</span> <span class="o">=</span> <span class="mf">99999999.9999</span>  <span class="c1"># (default value is infinite or some safety number like 1billion)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">probableLengthEquation</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># (this can be a number or an equation, e.g., every actin should grow to</span>
        <span class="c1"># 10 units long, or this actin fiber seed instance should grow to (random*10)^2</span>
        <span class="c1"># actually its a function of self.uLength like self.uLength * 10. or *(random*10)^2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ingGrowthMatrix</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
        <span class="c1"># (ultimately, we&#39;ll build a database for these (David Goodsell has a few examples),</span>
        <span class="c1"># but users should be able to put in their own, so for a test for now, lets say we&#39;ll</span>
        <span class="c1"># grow one unit for a singleSphereIng r=60 along its X as [55,0,0;1,0,0;0,1,0;0,0,1]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ingGrowthWobbleFormula</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># (this could be a rotation matrix to make a helix, or just a formula,</span>
        <span class="c1"># like the precession algorithm Michel and I already put in</span>
        <span class="c1"># for surface ingredients.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_rbsphere</span> <span class="o">=</span> <span class="n">use_rbsphere</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">useHalton</span> <span class="o">=</span> <span class="n">useHalton</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">constraintMarge</span> <span class="o">=</span> <span class="n">constraintMarge</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cutoff_boundary</span> <span class="o">=</span> <span class="n">cutoff_boundary</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cutoff_surface</span> <span class="o">=</span> <span class="n">cutoff_surface</span>
        <span class="c1"># mesh object representing one uLength? or a certain length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unitParent</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unitParentLength</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">walkingMode</span> <span class="o">=</span> <span class="n">walkingMode</span>  <span class="c1"># [&quot;sphere&quot;,&quot;lattice&quot;]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">walkingType</span> <span class="o">=</span> <span class="s2">&quot;stepbystep&quot;</span>  <span class="c1"># or atonce</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compMask</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prev_v3</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">compMask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">compMask</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">compMask</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">compMask</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">compMask</span> <span class="o">=</span> <span class="n">compMask</span>
        <span class="c1"># create a simple geom if none pass?</span>
        <span class="c1"># self.compMask=[]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">autopack</span><span class="o">.</span><span class="n">helper</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">autopack</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">nogui</span><span class="p">:</span>
                <span class="c1"># build a cylinder and make it length uLength, radius radii[0]</span>
                <span class="c1"># this mesh is used bu RAPID for collision</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">autopack</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">getObject</span><span class="p">(</span><span class="s2">&quot;autopackHider&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">p</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="n">autopack</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">newEmpty</span><span class="p">(</span><span class="s2">&quot;autopackHider&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">autopack</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">host</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;blender&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">autopack</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">toggleDisplay</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
            <span class="c1"># is axis working ?</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">autopack</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">Cylinder</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;_basic&quot;</span><span class="p">,</span>
                <span class="n">radius</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">radii</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mf">1.24</span><span class="p">,</span>
                <span class="n">length</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">uLength</span><span class="p">,</span>
                <span class="n">res</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span>
                <span class="n">parent</span><span class="o">=</span><span class="s2">&quot;autopackHider&quot;</span><span class="p">,</span>
                <span class="n">axis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">orientation</span><span class="p">,</span>
            <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">autopack</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">nogui</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">getData</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sphere_points_nb</span> <span class="o">=</span> <span class="mi">50000</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sphere_points</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">SphereHalton</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sphere_points_nb</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sphere_points_mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sphere_points_nb</span><span class="p">,</span> <span class="s2">&quot;i&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sphere_points_masked</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># need to define the binder/modifier. This is different from partner</span>
        <span class="c1"># Every nth place alternative repesentation</span>
        <span class="c1"># name proba is this for ingredient in general ?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alternates_names</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">alternates_proba</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">alternates_weight</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">prev_alt</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prev_was_alternate</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prev_alt_pt</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mini_interval</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alternate_interval</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># keep record of point Id that are bound to alternate and change the</span>
        <span class="c1"># representation according.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">safetycutoff</span> <span class="o">=</span> <span class="mi">10</span>

<div class="viewcode-block" id="GrowIngredient.get_signed_distance"><a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.grow.GrowIngredient.get_signed_distance">[docs]</a>    <span class="k">def</span> <span class="nf">get_signed_distance</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">packing_location</span><span class="p">,</span>
        <span class="n">grid_point_location</span><span class="p">,</span>
        <span class="n">rotation_matrix</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">cent1T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformPoints</span><span class="p">(</span>
            <span class="n">packing_location</span><span class="p">,</span> <span class="n">rotation_matrix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">cent2T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformPoints</span><span class="p">(</span>
            <span class="n">packing_location</span><span class="p">,</span> <span class="n">rotation_matrix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">positions2</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="k">for</span> <span class="n">radc</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">radii</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">cent1T</span><span class="p">,</span> <span class="n">cent2T</span><span class="p">):</span>
            <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">z1</span> <span class="o">=</span> <span class="n">p1</span>
            <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">z2</span> <span class="o">=</span> <span class="n">p2</span>
            <span class="n">vx</span><span class="p">,</span> <span class="n">vy</span><span class="p">,</span> <span class="n">vz</span> <span class="o">=</span> <span class="n">vector_along_ingredient</span> <span class="o">=</span> <span class="p">(</span><span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y2</span> <span class="o">-</span> <span class="n">y1</span><span class="p">,</span> <span class="n">z2</span> <span class="o">-</span> <span class="n">z1</span><span class="p">)</span>
            <span class="n">lengthsq</span> <span class="o">=</span> <span class="n">vx</span> <span class="o">*</span> <span class="n">vx</span> <span class="o">+</span> <span class="n">vy</span> <span class="o">*</span> <span class="n">vy</span> <span class="o">+</span> <span class="n">vz</span> <span class="o">*</span> <span class="n">vz</span>
            <span class="n">pd</span> <span class="o">=</span> <span class="n">grid_point_location</span> <span class="o">-</span> <span class="n">p1</span>
            <span class="n">pd2</span> <span class="o">=</span> <span class="n">grid_point_location</span> <span class="o">-</span> <span class="n">p2</span>

            <span class="n">dot_product</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">grid_point_location</span><span class="p">,</span> <span class="n">vector_along_ingredient</span><span class="p">)</span>
            <span class="n">d2toP1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pd</span> <span class="o">*</span> <span class="n">pd</span><span class="p">)</span>
            <span class="n">dsq</span> <span class="o">=</span> <span class="n">d2toP1</span> <span class="o">-</span> <span class="n">dot_product</span> <span class="o">*</span> <span class="n">dot_product</span> <span class="o">/</span> <span class="n">lengthsq</span>

            <span class="n">d2toP2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pd2</span> <span class="o">*</span> <span class="n">pd2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dot_product</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>  <span class="c1"># outside 1st cap</span>
                <span class="n">signed_distance</span> <span class="o">=</span> <span class="n">d2toP1</span>

            <span class="k">elif</span> <span class="n">dot_product</span> <span class="o">&gt;</span> <span class="n">lengthsq</span><span class="p">:</span>
                <span class="n">signed_distance</span> <span class="o">=</span> <span class="n">d2toP2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">signed_distance</span> <span class="o">=</span> <span class="n">dsq</span> <span class="o">-</span> <span class="n">radc</span>
        <span class="k">return</span> <span class="n">signed_distance</span></div>

<div class="viewcode-block" id="GrowIngredient.get_new_distance_values"><a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.grow.GrowIngredient.get_new_distance_values">[docs]</a>    <span class="k">def</span> <span class="nf">get_new_distance_values</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">jtrans</span><span class="p">,</span> <span class="n">rotMatj</span><span class="p">,</span> <span class="n">gridPointsCoords</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">dpad</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">0</span>
    <span class="p">):</span>
        <span class="n">insidePoints</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">newDistPoints</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">cent1T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformPoints</span><span class="p">(</span><span class="n">jtrans</span><span class="p">,</span> <span class="n">rotMatj</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">cent2T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformPoints</span><span class="p">(</span><span class="n">jtrans</span><span class="p">,</span> <span class="n">rotMatj</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">positions2</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">radc</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">radii</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">cent1T</span><span class="p">,</span> <span class="n">cent2T</span><span class="p">):</span>
            <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">z1</span> <span class="o">=</span> <span class="n">p1</span>
            <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">z2</span> <span class="o">=</span> <span class="n">p2</span>
            <span class="n">vx</span><span class="p">,</span> <span class="n">vy</span><span class="p">,</span> <span class="n">vz</span> <span class="o">=</span> <span class="n">vect</span> <span class="o">=</span> <span class="p">(</span><span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y2</span> <span class="o">-</span> <span class="n">y1</span><span class="p">,</span> <span class="n">z2</span> <span class="o">-</span> <span class="n">z1</span><span class="p">)</span>
            <span class="n">lengthsq</span> <span class="o">=</span> <span class="n">vx</span> <span class="o">*</span> <span class="n">vx</span> <span class="o">+</span> <span class="n">vy</span> <span class="o">*</span> <span class="n">vy</span> <span class="o">+</span> <span class="n">vz</span> <span class="o">*</span> <span class="n">vz</span>
            <span class="n">length</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">lengthsq</span><span class="p">)</span>
            <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">,</span> <span class="n">cz</span> <span class="o">=</span> <span class="n">posc</span> <span class="o">=</span> <span class="n">x1</span> <span class="o">+</span> <span class="n">vx</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">y1</span> <span class="o">+</span> <span class="n">vy</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">z1</span> <span class="o">+</span> <span class="n">vz</span> <span class="o">*</span> <span class="mf">0.5</span>
            <span class="n">radt</span> <span class="o">=</span> <span class="n">length</span> <span class="o">+</span> <span class="n">radc</span> <span class="o">+</span> <span class="n">dpad</span>
            <span class="n">bb</span> <span class="o">=</span> <span class="p">([</span><span class="n">cx</span> <span class="o">-</span> <span class="n">radt</span><span class="p">,</span> <span class="n">cy</span> <span class="o">-</span> <span class="n">radt</span><span class="p">,</span> <span class="n">cz</span> <span class="o">-</span> <span class="n">radt</span><span class="p">],</span> <span class="p">[</span><span class="n">cx</span> <span class="o">+</span> <span class="n">radt</span><span class="p">,</span> <span class="n">cy</span> <span class="o">+</span> <span class="n">radt</span><span class="p">,</span> <span class="n">cz</span> <span class="o">+</span> <span class="n">radt</span><span class="p">])</span>
            <span class="n">pointsInCube</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">callFunction</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">getPointsInCube</span><span class="p">,</span> <span class="p">(</span><span class="n">bb</span><span class="p">,</span> <span class="n">posc</span><span class="p">,</span> <span class="n">radt</span><span class="p">)</span>
            <span class="p">)</span>

            <span class="n">pd</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">numpy</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">gridPointsCoords</span><span class="p">,</span> <span class="n">pointsInCube</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">p1</span>
            <span class="p">)</span>  <span class="c1"># vector joining grid point and 1st corner</span>
            <span class="n">dotp</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">pd</span><span class="p">,</span> <span class="n">vect</span><span class="p">)</span>
            <span class="n">d2toP1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pd</span> <span class="o">*</span> <span class="n">pd</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">dsq</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">d2toP1</span> <span class="o">-</span> <span class="n">dotp</span> <span class="o">*</span> <span class="n">dotp</span> <span class="o">/</span> <span class="n">lengthsq</span>
            <span class="p">)</span>  <span class="c1"># perpendicular distance between grid point and cylinder axis</span>

            <span class="n">pd2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">gridPointsCoords</span><span class="p">,</span> <span class="n">pointsInCube</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">p2</span>
            <span class="n">d2toP2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pd2</span> <span class="o">*</span> <span class="n">pd2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">pti</span><span class="p">,</span> <span class="n">pt</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pointsInCube</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">insidePoints</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="k">if</span> <span class="n">dotp</span><span class="p">[</span><span class="n">pti</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>  <span class="c1"># outside 1st cap, p1 is closer</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">d2toP1</span><span class="p">[</span><span class="n">pti</span><span class="p">])</span> <span class="o">-</span> <span class="n">radc</span>  <span class="c1"># add cylindrical cap at ends?</span>
                    <span class="k">if</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="n">distance</span><span class="p">[</span><span class="n">pt</span><span class="p">]:</span>  <span class="c1"># point in region of influence</span>
                        <span class="k">if</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">newDistPoints</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="n">newDistPoints</span><span class="p">[</span><span class="n">pt</span><span class="p">]:</span>
                                <span class="n">newDistPoints</span><span class="p">[</span><span class="n">pt</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">newDistPoints</span><span class="p">[</span><span class="n">pt</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span>
                <span class="k">elif</span> <span class="n">dotp</span><span class="p">[</span><span class="n">pti</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">lengthsq</span><span class="p">:</span>  <span class="c1"># p2 is closer</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">d2toP2</span><span class="p">[</span><span class="n">pti</span><span class="p">])</span> <span class="o">-</span> <span class="n">radc</span>  <span class="c1"># add cylindrical cap at ends?</span>
                    <span class="k">if</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="n">distance</span><span class="p">[</span><span class="n">pt</span><span class="p">]:</span>  <span class="c1"># point in region of influence</span>
                        <span class="k">if</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">newDistPoints</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="n">newDistPoints</span><span class="p">[</span><span class="n">pt</span><span class="p">]:</span>
                                <span class="n">newDistPoints</span><span class="p">[</span><span class="n">pt</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">newDistPoints</span><span class="p">[</span><span class="n">pt</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">dsq</span><span class="p">[</span><span class="n">pti</span><span class="p">])</span> <span class="o">-</span> <span class="n">radc</span>
                    <span class="k">if</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>  <span class="c1"># point is inside dropped sphere</span>
                        <span class="k">if</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">insidePoints</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="n">insidePoints</span><span class="p">[</span><span class="n">pt</span><span class="p">]:</span>
                                <span class="n">insidePoints</span><span class="p">[</span><span class="n">pt</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">insidePoints</span><span class="p">[</span><span class="n">pt</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span>
        <span class="k">return</span> <span class="n">insidePoints</span><span class="p">,</span> <span class="n">newDistPoints</span></div>

<div class="viewcode-block" id="GrowIngredient.resetSphereDistribution"><a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.grow.GrowIngredient.resetSphereDistribution">[docs]</a>    <span class="k">def</span> <span class="nf">resetSphereDistribution</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># given a radius, create the sphere distribution</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sphere_points</span> <span class="o">=</span> <span class="n">SphereHalton</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sphere_points_nb</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sphere_points_mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sphere_points_nb</span><span class="p">,</span> <span class="s2">&quot;i&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="GrowIngredient.getNextPoint"><a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.grow.GrowIngredient.getNextPoint">[docs]</a>    <span class="k">def</span> <span class="nf">getNextPoint</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># pick a random point from the sphere point distribution</span>
        <span class="n">pointsmask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sphere_points_mask</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">pointsmask</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;no sphere point available from mask&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">ptIndr</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">uniform</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">pointsmask</span><span class="p">))</span>
        <span class="n">sp_pt_indice</span> <span class="o">=</span> <span class="n">pointsmask</span><span class="p">[</span><span class="n">ptIndr</span><span class="p">]</span>
        <span class="n">np</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sphere_points</span><span class="p">[</span><span class="n">sp_pt_indice</span><span class="p">])</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">max_jitter</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">unit_vector</span><span class="p">(</span><span class="n">np</span><span class="p">))</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">uLength</span>
        <span class="p">)</span>  <span class="c1"># biased by max_jitter ?</span></div>

<div class="viewcode-block" id="GrowIngredient.mask_sphere_points_boundary"><a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.grow.GrowIngredient.mask_sphere_points_boundary">[docs]</a>    <span class="k">def</span> <span class="nf">mask_sphere_points_boundary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pt</span><span class="p">,</span> <span class="n">boundingBox</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">boundingBox</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">boundingBox</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">fillBB</span>
        <span class="n">pts</span> <span class="o">=</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sphere_points</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">uLength</span><span class="p">)</span> <span class="o">+</span> <span class="n">pt</span>
        <span class="n">points_mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sphere_points_mask</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">points_mask</span><span class="p">):</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">point_is_available</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">pts</span><span class="p">[</span><span class="n">points_mask</span><span class="p">]]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sphere_points_mask</span><span class="p">[</span><span class="n">points_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                    <span class="n">mask</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sphere_points_mask</span><span class="p">[</span><span class="n">points_mask</span><span class="p">]</span>
                <span class="p">)</span></div>

<div class="viewcode-block" id="GrowIngredient.mask_sphere_points_ingredients"><a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.grow.GrowIngredient.mask_sphere_points_ingredients">[docs]</a>    <span class="k">def</span> <span class="nf">mask_sphere_points_ingredients</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pt</span><span class="p">,</span> <span class="n">listeclosest</span><span class="p">):</span>
        <span class="n">listeclosest</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">elem</span>
            <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">listeclosest</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">elem</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">autopack</span><span class="o">.</span><span class="n">Compartment</span><span class="o">.</span><span class="n">Compartment</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="n">points_mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sphere_points_mask</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">listeclosest</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">points_mask</span><span class="p">):</span>
            <span class="n">points</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">listeclosest</span><span class="p">)[:,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">ingrs</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">listeclosest</span><span class="p">)[:,</span> <span class="mi">3</span><span class="p">]</span>
            <span class="n">radius</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">ingr</span><span class="o">.</span><span class="n">encapsulating_radius</span><span class="p">)</span> <span class="k">for</span> <span class="n">ingr</span> <span class="ow">in</span> <span class="n">ingrs</span><span class="p">]</span>
            <span class="c1"># this distance is between unit vector and 3d points...</span>
            <span class="c1"># translate and scale the spheres points</span>
            <span class="n">sp</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sphere_points</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">dp</span> <span class="o">=</span> <span class="n">sp</span><span class="p">[</span><span class="n">points_mask</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">uLength</span> <span class="o">+</span> <span class="n">pt</span>
            <span class="n">pts</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="c1"># distance between sphere point and ingredient positions</span>
            <span class="n">distances</span> <span class="o">=</span> <span class="n">spatial</span><span class="o">.</span><span class="n">distance</span><span class="o">.</span><span class="n">cdist</span><span class="p">(</span><span class="n">pts</span><span class="p">,</span> <span class="n">dp</span><span class="p">)</span>
            <span class="c1"># empty mask for the point</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dp</span><span class="p">)))[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># mas cumulative ?for</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">distances</span><span class="p">)):</span>
                <span class="c1"># if distance is &gt;= to ingredient encapsulating_radius we keep the point</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">greater_equal</span><span class="p">(</span><span class="n">distances</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">radius</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
            <span class="c1"># ponts to keep</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sphere_points_mask</span><span class="p">[</span><span class="n">points_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                <span class="n">mask</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sphere_points_mask</span><span class="p">[</span><span class="n">points_mask</span><span class="p">]</span>
            <span class="p">)</span></div>
            <span class="c1"># indices = numpy.nonzero(mask)[0]#indice f</span>
            <span class="c1"># i = self.sphere_points_mask[indices]</span>
            <span class="c1"># self.sphere_points_mask = i</span>

<div class="viewcode-block" id="GrowIngredient.mask_sphere_points_dihedral"><a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.grow.GrowIngredient.mask_sphere_points_dihedral">[docs]</a>    <span class="k">def</span> <span class="nf">mask_sphere_points_dihedral</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="n">marge_out</span><span class="p">,</span> <span class="n">marge_diedral</span><span class="p">,</span> <span class="n">v3</span><span class="o">=</span><span class="p">[]):</span>
        <span class="n">points_mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sphere_points_mask</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">v3</span><span class="p">):</span>
            <span class="c1">#            a=angle_between_vectors(self.vi.unit_vector(v2),self.sphere_points[points_mask], axis=1)</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">angle_between_vectors</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">unit_vector</span><span class="p">(</span><span class="n">v3</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">sphere_points</span><span class="p">[</span><span class="n">points_mask</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">marge_out</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">float</span><span class="p">:</span>
                <span class="n">marge_out</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">marge_out</span><span class="p">]</span>
            <span class="c1"># mask1 = numpy.logical_and(a&lt;math.radians(marge_out[1]), a &gt; math.radians(marge_out[0]))#794</span>
            <span class="n">mask4</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">less</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>  <span class="c1"># 18</span>
            <span class="c1">#            mask3 = numpy.logical_and(mask4,mask1)#0?</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">sphere_points_mask</span><span class="p">[</span><span class="n">points_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                <span class="n">mask4</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sphere_points_mask</span><span class="p">[</span><span class="n">points_mask</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">angle_between_vectors</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">unit_vector</span><span class="p">(</span><span class="n">v2</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">sphere_points</span><span class="p">[</span><span class="n">points_mask</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
            <span class="p">)</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">angle_between_vectors</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">unit_vector</span><span class="p">(</span><span class="n">v1</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">sphere_points</span><span class="p">[</span><span class="n">points_mask</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">marge_out</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">float</span><span class="p">:</span>
                <span class="n">marge_out</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">marge_out</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">marge_diedral</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">float</span><span class="p">:</span>
                <span class="n">marge_diedral</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">marge_diedral</span><span class="p">]</span>
            <span class="n">mask1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                <span class="n">a</span> <span class="o">&lt;</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">marge_out</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">marge_out</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="p">)</span>
            <span class="n">mask2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                <span class="n">b</span> <span class="o">&lt;</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">marge_diedral</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">b</span> <span class="o">&gt;</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">marge_diedral</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="p">)</span>
            <span class="n">mask3</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">mask1</span><span class="p">,</span> <span class="n">mask2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sphere_points_mask</span><span class="p">[</span><span class="n">points_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                <span class="n">mask3</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sphere_points_mask</span><span class="p">[</span><span class="n">points_mask</span><span class="p">]</span>
            <span class="p">)</span></div>

<div class="viewcode-block" id="GrowIngredient.mask_sphere_points_angle"><a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.grow.GrowIngredient.mask_sphere_points_angle">[docs]</a>    <span class="k">def</span> <span class="nf">mask_sphere_points_angle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">marge_in</span><span class="p">):</span>
        <span class="c1"># mask first with angle</span>
        <span class="c1"># adjust the points to current transfomation? or normalize current vector ?</span>
        <span class="n">points_mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sphere_points_mask</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">angle_between_vectors</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">unit_vector</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">sphere_points</span><span class="p">[</span><span class="n">points_mask</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">marge_in</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">float</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">less</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">marge_in</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                <span class="n">a</span> <span class="o">&lt;</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">marge_in</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">marge_in</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sphere_points_mask</span><span class="p">[</span><span class="n">points_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
            <span class="n">mask</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sphere_points_mask</span><span class="p">[</span><span class="n">points_mask</span><span class="p">]</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="GrowIngredient.mask_sphere_points_vector"><a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.grow.GrowIngredient.mask_sphere_points_vector">[docs]</a>    <span class="k">def</span> <span class="nf">mask_sphere_points_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">pt</span><span class="p">,</span> <span class="n">alternate</span><span class="p">):</span>
        <span class="n">points_mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sphere_points_mask</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># pick the point that are close to pt2-pt3</span>
        <span class="c1"># align v to pt1-pt2, apply to pt2-pt3</span>
        <span class="c1"># mesure angle</span>
        <span class="n">pta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">partners</span><span class="p">[</span><span class="n">alternate</span><span class="p">]</span><span class="o">.</span><span class="n">get_point</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">ptb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">partners</span><span class="p">[</span><span class="n">alternate</span><span class="p">]</span><span class="o">.</span><span class="n">get_point</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">ptc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">partners</span><span class="p">[</span><span class="n">alternate</span><span class="p">]</span><span class="o">.</span><span class="n">get_point</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">toalign</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ptb</span><span class="p">)</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pta</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rotVectToVect</span><span class="p">(</span><span class="n">toalign</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
        <span class="n">m</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>  <span class="c1"># jtrans</span>
        <span class="n">pts</span> <span class="o">=</span> <span class="n">autopack</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">ApplyMatrix</span><span class="p">([</span><span class="n">pta</span><span class="p">],</span> <span class="n">m</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>  <span class="c1"># transpose ?</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span> <span class="o">-</span> <span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">m</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span> <span class="o">+</span> <span class="n">v</span>
        <span class="n">newPts</span> <span class="o">=</span> <span class="n">autopack</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">ApplyMatrix</span><span class="p">([</span><span class="n">ptb</span><span class="p">,</span> <span class="n">ptc</span><span class="p">],</span> <span class="n">m</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>  <span class="c1"># transpose ?</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">angle_between_vectors</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">unit_vector</span><span class="p">(</span><span class="n">newPts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">newPts</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sphere_points</span><span class="p">[</span><span class="n">points_mask</span><span class="p">],</span>
            <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">less</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="mf">5.0</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sphere_points_mask</span><span class="p">[</span><span class="n">points_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
            <span class="n">mask</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sphere_points_mask</span><span class="p">[</span><span class="n">points_mask</span><span class="p">]</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="GrowIngredient.mask_sphere_points"><a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.grow.GrowIngredient.mask_sphere_points">[docs]</a>    <span class="k">def</span> <span class="nf">mask_sphere_points</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">v</span><span class="p">,</span>
        <span class="n">pt</span><span class="p">,</span>
        <span class="n">marge</span><span class="p">,</span>
        <span class="n">listeclosest</span><span class="p">,</span>
        <span class="n">cutoff</span><span class="p">,</span>
        <span class="n">alternate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">pv</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">marge_diedral</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">v3</span><span class="o">=</span><span class="p">[],</span>
    <span class="p">):</span>
        <span class="c1"># self.sphere_points_mask=numpy.ones(10000,&#39;i&#39;)</span>
        <span class="k">if</span> <span class="n">marge_diedral</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mask_sphere_points_dihedral</span><span class="p">(</span><span class="n">pv</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">marge</span><span class="p">,</span> <span class="n">marge_diedral</span><span class="p">,</span> <span class="n">v3</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">alternate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mask_sphere_points_vector</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">pt</span><span class="p">,</span> <span class="n">alternate</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mask_sphere_points_angle</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">marge</span><span class="p">)</span>
                <span class="c1"># storethe mask point</span>
        <span class="n">sphere_points_mask_copy</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sphere_points_mask</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mask_sphere_points_ingredients</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">listeclosest</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sphere_points_mask</span><span class="p">)[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sphere_points_mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">sphere_points_mask_copy</span><span class="p">)</span></div>
            <span class="c1"># self.mask_sphere_points_boundary(pt)</span>
            <span class="c1">#        print (&quot;after mask2 &quot;,len( numpy.nonzero(self.sphere_points_mask)[0]))</span>

<div class="viewcode-block" id="GrowIngredient.reset"><a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.grow.GrowIngredient.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nbCurve</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">listePtLinear</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">listePtCurve</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># snake</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Ptis</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># snakePts</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">currentLength</span> <span class="o">=</span> <span class="mf">0.0</span>  <span class="c1"># snakelength</span></div>
        <span class="c1"># update he cylinder ?</span>

<div class="viewcode-block" id="GrowIngredient.getNextPtIndCyl"><a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.grow.GrowIngredient.getNextPtIndCyl">[docs]</a>    <span class="k">def</span> <span class="nf">getNextPtIndCyl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">jtrans</span><span class="p">,</span> <span class="n">rotMatj</span><span class="p">,</span> <span class="n">free_points</span><span class="p">,</span> <span class="n">histoVol</span><span class="p">):</span>
        <span class="c1">#        print jtrans, rotMatj</span>
        <span class="n">cent2T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformPoints</span><span class="p">(</span><span class="n">jtrans</span><span class="p">,</span> <span class="n">rotMatj</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">jx</span><span class="p">,</span> <span class="n">jy</span><span class="p">,</span> <span class="n">jz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_jitter</span>
        <span class="n">jitter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getMaxJitter</span><span class="p">(</span><span class="n">histoVol</span><span class="o">.</span><span class="n">smallestProteinSize</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cent2T</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">cent2T</span> <span class="o">=</span> <span class="n">cent2T</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">tx</span><span class="p">,</span> <span class="n">ty</span><span class="p">,</span> <span class="n">tz</span> <span class="o">=</span> <span class="n">cent2T</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">jx</span> <span class="o">*</span> <span class="n">jitter</span> <span class="o">*</span> <span class="n">gauss</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">)</span>
        <span class="p">)</span>  <span class="c1"># This is an incorrect jitter use the uniform random with sphereical rejection</span>
        <span class="n">dy</span> <span class="o">=</span> <span class="n">jy</span> <span class="o">*</span> <span class="n">jitter</span> <span class="o">*</span> <span class="n">gauss</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">)</span>
        <span class="n">dz</span> <span class="o">=</span> <span class="n">jz</span> <span class="o">*</span> <span class="n">jitter</span> <span class="o">*</span> <span class="n">gauss</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">)</span>
        <span class="n">nexPt</span> <span class="o">=</span> <span class="p">(</span><span class="n">tx</span> <span class="o">+</span> <span class="n">dx</span><span class="p">,</span> <span class="n">ty</span> <span class="o">+</span> <span class="n">dy</span><span class="p">,</span> <span class="n">tz</span> <span class="o">+</span> <span class="n">dz</span><span class="p">)</span>
        <span class="c1"># where is this point in the grid</span>
        <span class="c1"># ptInd = histoVol.grid.getPointFrom3D(nexPt)</span>
        <span class="n">t</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">oneJitter</span><span class="p">(</span><span class="n">histoVol</span><span class="o">.</span><span class="n">smallestProteinSize</span><span class="p">,</span> <span class="n">cent2T</span><span class="p">,</span> <span class="n">rotMatj</span><span class="p">)</span>
        <span class="n">dist</span><span class="p">,</span> <span class="n">ptInd</span> <span class="o">=</span> <span class="n">histoVol</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">getClosestGridPoint</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="n">dv</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nexPt</span><span class="p">)</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cent2T</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dv</span> <span class="o">*</span> <span class="n">dv</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ptInd</span><span class="p">,</span> <span class="n">dv</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">d</span><span class="p">)</span></div>

<div class="viewcode-block" id="GrowIngredient.getJtransRot_r"><a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.grow.GrowIngredient.getJtransRot_r">[docs]</a>    <span class="k">def</span> <span class="nf">getJtransRot_r</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pt1</span><span class="p">,</span> <span class="n">pt2</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">uLength</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pt2</span><span class="p">)</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pt1</span><span class="p">)</span>
        <span class="n">pmx</span> <span class="o">=</span> <span class="n">rotVectToVect</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">orientation</span><span class="p">)</span> <span class="o">*</span> <span class="n">length</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">i</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pmx</span><span class="p">),</span>
            <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pt1</span><span class="p">)</span> <span class="o">+</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span>
        <span class="p">)</span>  <span class="c1"># .transpose()jtrans</span></div>

<div class="viewcode-block" id="GrowIngredient.getJtransRot"><a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.grow.GrowIngredient.getJtransRot">[docs]</a>    <span class="k">def</span> <span class="nf">getJtransRot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pt1</span><span class="p">,</span> <span class="n">pt2</span><span class="p">):</span>
        <span class="n">v</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">measure_distance</span><span class="p">(</span><span class="n">pt1</span><span class="p">,</span> <span class="n">pt2</span><span class="p">,</span> <span class="n">vec</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">length</span><span class="p">,</span> <span class="n">mat</span> <span class="o">=</span> <span class="n">autopack</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">getTubePropertiesMatrix</span><span class="p">(</span><span class="n">pt1</span><span class="p">,</span> <span class="n">pt2</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mat</span><span class="p">),</span>
            <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pt1</span><span class="p">)</span> <span class="o">+</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span>
        <span class="p">)</span>  <span class="c1"># .transpose()jtrans</span>

        <span class="c1"># Start jtrans section that is new since Sept 8, 2011 version</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pt1</span><span class="p">)</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pt2</span><span class="p">)</span>
        <span class="c1"># normalize the vector n</span>
        <span class="n">nn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">unit_vector</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>  <span class="c1"># why normalize ?</span>

        <span class="c1"># get axis of rotation between the plane normal and Z</span>
        <span class="n">v1</span> <span class="o">=</span> <span class="n">nn</span>
        <span class="n">v2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">])</span>  <span class="c1"># self.orientation) #[0.,0.,1.0]</span>
        <span class="n">cr</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">)</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">unit_vector</span><span class="p">(</span><span class="n">cr</span><span class="p">)</span>

        <span class="c1"># get the angle between the plane normal and Z</span>
        <span class="n">angle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">angle_between_vectors</span><span class="p">(</span><span class="n">v2</span><span class="p">,</span> <span class="n">v1</span><span class="p">)</span>
        <span class="c1"># get the rotation matrix between plane normal and Z</span>

        <span class="n">mx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">rotation_matrix</span><span class="p">(</span><span class="o">-</span><span class="n">angle</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>  <span class="c1"># .transpose()-angle ?</span>
        <span class="c1"># End jtrans section that is new since Sept 8, 2011 version</span>
        <span class="n">matrix</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>  <span class="c1"># self.vi.ToMat(mx).transpose()#Why ToMat here ?</span>
        <span class="n">rotMatj</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">rotMatj</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span>
            <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pt1</span><span class="p">)</span> <span class="o">+</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span>
        <span class="p">)</span>  <span class="c1"># .transpose()jtrans</span></div>

<div class="viewcode-block" id="GrowIngredient.walkLatticeSurface"><a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.grow.GrowIngredient.walkLatticeSurface">[docs]</a>    <span class="k">def</span> <span class="nf">walkLatticeSurface</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">pts</span><span class="p">,</span>
        <span class="n">distance</span><span class="p">,</span>
        <span class="n">histoVol</span><span class="p">,</span>
        <span class="n">size</span><span class="p">,</span>
        <span class="n">mask</span><span class="p">,</span>
        <span class="n">marge</span><span class="o">=</span><span class="mf">999.0</span><span class="p">,</span>
        <span class="n">checkcollision</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">saw</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">,</span> <span class="n">cz</span> <span class="o">=</span> <span class="n">posc</span> <span class="o">=</span> <span class="n">pts</span>
        <span class="n">step</span> <span class="o">=</span> <span class="n">histoVol</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">gridSpacing</span> <span class="o">*</span> <span class="n">size</span>
        <span class="n">bb</span> <span class="o">=</span> <span class="p">([</span><span class="n">cx</span> <span class="o">-</span> <span class="n">step</span><span class="p">,</span> <span class="n">cy</span> <span class="o">-</span> <span class="n">step</span><span class="p">,</span> <span class="n">cz</span> <span class="o">-</span> <span class="n">step</span><span class="p">],</span> <span class="p">[</span><span class="n">cx</span> <span class="o">+</span> <span class="n">step</span><span class="p">,</span> <span class="n">cy</span> <span class="o">+</span> <span class="n">step</span><span class="p">,</span> <span class="n">cz</span> <span class="o">+</span> <span class="n">step</span><span class="p">])</span>
        <span class="n">pointsInCube</span> <span class="o">=</span> <span class="n">histoVol</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">getPointsInCube</span><span class="p">(</span><span class="n">bb</span><span class="p">,</span> <span class="n">posc</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">addSP</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">o</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">compartments</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">compNum</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">sfpts</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">surfacePointsCoords</span>

        <span class="n">found</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">attempted</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">safetycutoff</span> <span class="o">=</span> <span class="mi">200</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">runTimeDisplay</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;walking&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
            <span class="n">sp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">getObject</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">sp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">sp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mf">10.0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">found</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">attempted</span> <span class="o">&gt;</span> <span class="n">safetycutoff</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">False</span>
            <span class="n">newPtId</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">random</span><span class="p">()</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">sfpts</span><span class="p">))</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">sfpts</span><span class="p">[</span><span class="n">newPtId</span><span class="p">]</span>  <span class="c1"># histoVol.grid.masterGridPositions[newPtId]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">runTimeDisplay</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">setTranslation</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">FromVec</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">saw</span><span class="p">:</span>  <span class="c1"># check if already taken, but didnt prevent cross</span>
                <span class="k">if</span> <span class="n">pointsInCube</span><span class="p">[</span><span class="n">newPtId</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ptis</span><span class="p">:</span>
                    <span class="n">attempted</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">continue</span>
            <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">,</span> <span class="n">cz</span> <span class="o">=</span> <span class="n">posc</span> <span class="o">=</span> <span class="n">pts</span>
            <span class="n">angle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">angle_between_vectors</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">posc</span><span class="p">),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
            <span class="n">v</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">measure_distance</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">posc</span><span class="p">),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">vec</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">angle</span><span class="p">))</span> <span class="o">&lt;=</span> <span class="n">marge</span><span class="p">:</span>
                <span class="n">closeS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">far_enough_from_surfaces</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cutoff_surface</span><span class="p">)</span>
                <span class="n">inComp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_point_in_correct_region</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">closeS</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">inComp</span><span class="p">:</span>  <span class="c1"># or d &gt; self.uLength:</span>
                    <span class="n">attempted</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">checkcollision</span><span class="p">:</span>
                    <span class="n">m</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
                    <span class="n">collision</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">checkSphCollisions</span><span class="p">(</span>
                        <span class="p">[</span><span class="n">v</span><span class="p">],</span>
                        <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">uLength</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1.0</span><span class="p">],</span>
                        <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
                        <span class="n">m</span><span class="p">,</span>
                        <span class="mi">0</span><span class="p">,</span>
                        <span class="n">histoVol</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">masterGridPositions</span><span class="p">,</span>
                        <span class="n">distance</span><span class="p">,</span>
                        <span class="n">histoVol</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">collision</span><span class="p">:</span>
                        <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">Ptis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pointsInCube</span><span class="p">[</span><span class="n">newPtId</span><span class="p">])</span>
                        <span class="k">return</span> <span class="n">v</span><span class="p">,</span> <span class="kc">True</span>
                    <span class="k">else</span><span class="p">:</span>  <span class="c1"># increment the range</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">constraintMarge</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">marge</span> <span class="o">&gt;=</span> <span class="mi">180</span><span class="p">:</span>
                                <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">False</span>
                            <span class="n">marge</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="n">attempted</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">continue</span>
                <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Ptis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pointsInCube</span><span class="p">[</span><span class="n">newPtId</span><span class="p">])</span>
                <span class="k">return</span> <span class="n">v</span><span class="p">,</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">attempted</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">continue</span></div>

<div class="viewcode-block" id="GrowIngredient.walkLattice"><a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.grow.GrowIngredient.walkLattice">[docs]</a>    <span class="k">def</span> <span class="nf">walkLattice</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">pts</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">histoVol</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">marge</span><span class="o">=</span><span class="mf">999.0</span><span class="p">,</span> <span class="n">checkcollision</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">saw</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">):</span>
        <span class="c1"># take the next random point in the windows size +1 +2</span>
        <span class="c1"># extended = histoVol.getPointsInCube()</span>
        <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">,</span> <span class="n">cz</span> <span class="o">=</span> <span class="n">posc</span> <span class="o">=</span> <span class="n">pts</span>  <span class="c1"># histoVol.grid.masterGridPositions[ptId]</span>
        <span class="n">step</span> <span class="o">=</span> <span class="n">histoVol</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">gridSpacing</span> <span class="o">*</span> <span class="n">size</span>
        <span class="n">bb</span> <span class="o">=</span> <span class="p">([</span><span class="n">cx</span> <span class="o">-</span> <span class="n">step</span><span class="p">,</span> <span class="n">cy</span> <span class="o">-</span> <span class="n">step</span><span class="p">,</span> <span class="n">cz</span> <span class="o">-</span> <span class="n">step</span><span class="p">],</span> <span class="p">[</span><span class="n">cx</span> <span class="o">+</span> <span class="n">step</span><span class="p">,</span> <span class="n">cy</span> <span class="o">+</span> <span class="n">step</span><span class="p">,</span> <span class="n">cz</span> <span class="o">+</span> <span class="n">step</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">runTimeDisplay</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">box</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">getObject</span><span class="p">(</span><span class="s2">&quot;collBox&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">box</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">box</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">Box</span><span class="p">(</span><span class="s2">&quot;collBox&quot;</span><span class="p">,</span> <span class="n">cornerPoints</span><span class="o">=</span><span class="n">bb</span><span class="p">,</span> <span class="n">visible</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1">#                    self.vi.toggleDisplay(box,True)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">updateBox</span><span class="p">(</span><span class="n">box</span><span class="p">,</span> <span class="n">cornerPoints</span><span class="o">=</span><span class="n">bb</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
        <span class="n">pointsInCube</span> <span class="o">=</span> <span class="n">histoVol</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">getPointsInCube</span><span class="p">(</span><span class="n">bb</span><span class="p">,</span> <span class="n">posc</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">addSP</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">pointsInCubeCoords</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">take</span><span class="p">(</span>
            <span class="n">histoVol</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">masterGridPositions</span><span class="p">,</span> <span class="n">pointsInCube</span><span class="p">,</span> <span class="mi">0</span>
        <span class="p">)</span>
        <span class="c1"># take a random point from it OR use gradient info OR constrain by angle</span>
        <span class="n">found</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">attempted</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">safetycutoff</span> <span class="o">=</span> <span class="mi">200</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">runTimeDisplay</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;walking&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
            <span class="n">sp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">getObject</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">sp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">sp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mf">10.0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">namep</span> <span class="o">=</span> <span class="s2">&quot;latticePoints&quot;</span>
            <span class="n">pts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">getObject</span><span class="p">(</span><span class="n">namep</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">pts</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">pts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">Points</span><span class="p">(</span><span class="n">namep</span><span class="p">)</span>
            <span class="n">pts</span><span class="o">.</span><span class="n">Set</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="n">pointsInCubeCoords</span><span class="p">)</span>
            <span class="c1"># sp.SetAbsPos(self.vi.FromVec(startingPoint))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">found</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">attempted</span> <span class="o">&gt;</span> <span class="n">safetycutoff</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">False</span>
            <span class="n">newPtId</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">random</span><span class="p">()</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">pointsInCube</span><span class="p">))</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">pointsInCubeCoords</span><span class="p">[</span>
                <span class="n">newPtId</span>
            <span class="p">]</span>  <span class="c1"># histoVol.grid.masterGridPositions[newPtId]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">runTimeDisplay</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">setTranslation</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">FromVec</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">saw</span><span class="p">:</span>  <span class="c1"># check if already taken, but didnt prevent cross</span>
                <span class="k">if</span> <span class="n">pointsInCube</span><span class="p">[</span><span class="n">newPtId</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ptis</span><span class="p">:</span>
                    <span class="n">attempted</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">continue</span>
            <span class="n">angle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">angle_between_vectors</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">posc</span><span class="p">),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
            <span class="n">v</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">measure_distance</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">posc</span><span class="p">),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">vec</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">angle</span><span class="p">))</span> <span class="o">&lt;=</span> <span class="n">marge</span><span class="p">:</span>
                <span class="n">closeS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">far_enough_from_surfaces</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cutoff_surface</span><span class="p">)</span>
                <span class="n">inComp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_point_in_correct_region</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">closeS</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">inComp</span><span class="p">:</span>  <span class="c1"># or d &gt; self.uLength:</span>
                    <span class="n">attempted</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">checkcollision</span><span class="p">:</span>
                    <span class="n">m</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
                    <span class="n">collision</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">collision_jitter</span><span class="p">(</span>
                        <span class="p">[</span><span class="n">v</span><span class="p">],</span>
                        <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">uLength</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1.0</span><span class="p">],</span>
                        <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
                        <span class="n">m</span><span class="p">,</span>
                        <span class="mi">0</span><span class="p">,</span>
                        <span class="n">histoVol</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">masterGridPositions</span><span class="p">,</span>
                        <span class="n">distance</span><span class="p">,</span>
                        <span class="n">histoVol</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">collision</span><span class="p">:</span>
                        <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">Ptis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pointsInCube</span><span class="p">[</span><span class="n">newPtId</span><span class="p">])</span>
                        <span class="k">return</span> <span class="n">v</span><span class="p">,</span> <span class="kc">True</span>
                    <span class="k">else</span><span class="p">:</span>  <span class="c1"># increment the range</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">constraintMarge</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">marge</span> <span class="o">&gt;=</span> <span class="mi">180</span><span class="p">:</span>
                                <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">False</span>
                            <span class="n">marge</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="n">attempted</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">continue</span>
                <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Ptis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pointsInCube</span><span class="p">[</span><span class="n">newPtId</span><span class="p">])</span>
                <span class="k">return</span> <span class="n">v</span><span class="p">,</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">attempted</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">continue</span></div>

<div class="viewcode-block" id="GrowIngredient.walkSphere"><a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.grow.GrowIngredient.walkSphere">[docs]</a>    <span class="k">def</span> <span class="nf">walkSphere</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">pt1</span><span class="p">,</span> <span class="n">pt2</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">histoVol</span><span class="p">,</span> <span class="n">dpad</span><span class="p">,</span> <span class="n">marge</span><span class="o">=</span><span class="mf">90.0</span><span class="p">,</span> <span class="n">checkcollision</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;use a random point on a sphere of radius uLength, and useCylinder collision on the grid&quot;&quot;&quot;</span>
        <span class="n">v</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">measure_distance</span><span class="p">(</span><span class="n">pt1</span><span class="p">,</span> <span class="n">pt2</span><span class="p">,</span> <span class="n">vec</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">found</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">attempted</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">pt</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]</span>
        <span class="n">angle</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">safetycutoff</span> <span class="o">=</span> <span class="mi">10000</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">constraintMarge</span><span class="p">:</span>
            <span class="n">safetycutoff</span> <span class="o">=</span> <span class="mi">200</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">runTimeDisplay</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;walking&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
            <span class="n">sp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">getObject</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">sp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">sp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mf">2.0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># sp.SetAbsPos(self.vi.FromVec(startingPoint))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">found</span><span class="p">:</span>
            <span class="c1"># main loop thattryto found the next point (similar to jitter)</span>
            <span class="k">if</span> <span class="n">attempted</span> <span class="o">&gt;=</span> <span class="n">safetycutoff</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">False</span>  <span class="c1"># numpy.array(pt2).flatten()+numpy.array(pt),False</span>
            <span class="n">pt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">randpoint_onsphere</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">uLength</span>
            <span class="p">)</span>  <span class="c1"># *numpy.array(self.max_jitter)</span>
            <span class="c1"># the new position is the previous point (pt2) plus the random point</span>
            <span class="n">newPt</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pt2</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="o">+</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">runTimeDisplay</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">setTranslation</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">newPt</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
            <span class="c1"># compute the angle between the previous direction (pt1-&gt;pt2) and the new random one (pt)</span>
            <span class="n">angle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">angle_between_vectors</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pt</span><span class="p">))</span>
            <span class="c1"># first test angle less than the constraint angle</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">angle</span><span class="p">))</span> <span class="o">&lt;=</span> <span class="n">marge</span><span class="p">:</span>
                <span class="c1"># check if in bounding box</span>
                <span class="n">inside</span> <span class="o">=</span> <span class="n">histoVol</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">checkPointInside</span><span class="p">(</span>
                    <span class="n">newPt</span><span class="p">,</span> <span class="n">dist</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cutoff_boundary</span><span class="p">,</span> <span class="n">jitter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_jitter</span>
                <span class="p">)</span>
                <span class="n">closeS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">far_enough_from_surfaces</span><span class="p">(</span>
                    <span class="n">newPt</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cutoff_surface</span>
                <span class="p">)</span>
                <span class="n">inComp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_point_in_correct_region</span><span class="p">(</span><span class="n">newPt</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">inside</span> <span class="ow">or</span> <span class="n">closeS</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">inComp</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">constraintMarge</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">marge</span> <span class="o">&gt;=</span> <span class="mi">175</span><span class="p">:</span>
                            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">False</span>
                        <span class="n">marge</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">attempted</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">continue</span>
                <span class="c1"># optionally check for collision</span>
                <span class="k">if</span> <span class="n">checkcollision</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_type</span> <span class="o">==</span> <span class="s2">&quot;Cylinders&quot;</span><span class="p">:</span>
                        <span class="c1"># outise is consider as collision...?</span>
                        <span class="c1">#                        rotMatj,jtrans=self.getJtransRot(numpy.array(pt2).flatten(),newPt)</span>
                        <span class="n">rot_mat</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
                        <span class="c1">#                        collision = self.checkSphCollisions([newPt,],[float(self.uLength)*1.,],</span>
                        <span class="c1">#                                            [0.,0.,0.], m, 0,</span>
                        <span class="c1">#                                            histoVol.grid.masterGridPositions,</span>
                        <span class="c1">#                                            distance,</span>
                        <span class="c1">#                                            histoVol)</span>
                        <span class="c1"># use panda ?</span>
                        <span class="n">collision</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">checkCylCollisions</span><span class="p">(</span>
                            <span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pt2</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()],</span>
                            <span class="p">[</span><span class="n">newPt</span><span class="p">],</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">radii</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                            <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
                            <span class="n">rot_mat</span><span class="p">,</span>
                            <span class="n">histoVol</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">masterGridPositions</span><span class="p">,</span>
                            <span class="n">distance</span><span class="p">,</span>
                            <span class="n">histoVol</span><span class="p">,</span>
                            <span class="n">dpad</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">collision</span><span class="p">:</span>
                            <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>
                            <span class="k">return</span> <span class="n">newPt</span><span class="p">,</span> <span class="kc">True</span>
                        <span class="k">else</span><span class="p">:</span>  <span class="c1"># increment the range</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">constraintMarge</span><span class="p">:</span>
                                <span class="k">if</span> <span class="n">marge</span> <span class="o">&gt;=</span> <span class="mi">180</span><span class="p">:</span>
                                    <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">False</span>
                                <span class="n">marge</span> <span class="o">+=</span> <span class="mi">1</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">attempted</span> <span class="o">+=</span> <span class="mi">1</span>
                            <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">return</span> <span class="n">newPt</span><span class="p">,</span> <span class="kc">True</span>
                    <span class="c1">#                attempted += 1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">attempted</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">continue</span>
            <span class="n">attempted</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">newPt</span><span class="p">,</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="GrowIngredient.getInterpolatedSphere"><a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.grow.GrowIngredient.getInterpolatedSphere">[docs]</a>    <span class="k">def</span> <span class="nf">getInterpolatedSphere</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pt1</span><span class="p">,</span> <span class="n">pt2</span><span class="p">):</span>
        <span class="n">v</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">measure_distance</span><span class="p">(</span><span class="n">pt1</span><span class="p">,</span> <span class="n">pt2</span><span class="p">,</span> <span class="n">vec</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1">#        d=self.uLength</span>
        <span class="n">sps</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_radius</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">p</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">pt1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pt1</span><span class="p">)</span>
        <span class="n">pt2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pt2</span><span class="p">)</span>
        <span class="n">vn</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">/</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>  <span class="c1"># normalized</span>
        <span class="n">p</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pt1</span><span class="p">)</span>
        <span class="n">r</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_radius</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sps</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
            <span class="n">r</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_radius</span><span class="p">)</span>
            <span class="n">p</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pt1</span> <span class="o">+</span> <span class="p">(</span><span class="n">vn</span> <span class="o">*</span> <span class="n">sp</span><span class="p">))</span>
        <span class="n">p</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pt2</span><span class="p">)</span>
        <span class="n">r</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_radius</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">p</span><span class="p">]</span></div>

<div class="viewcode-block" id="GrowIngredient.addRBsegment"><a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.grow.GrowIngredient.addRBsegment">[docs]</a>    <span class="k">def</span> <span class="nf">addRBsegment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pt1</span><span class="p">,</span> <span class="n">pt2</span><span class="p">,</span> <span class="n">nodeid</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
        <span class="c1"># build a rigid body of multisphere along pt1topt2</span>
        <span class="n">r</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getInterpolatedSphere</span><span class="p">(</span><span class="n">pt1</span><span class="p">,</span> <span class="n">pt2</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;pos len&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">))</span>
        <span class="n">inodenp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_rb_multi_sphere</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;node build &quot;</span><span class="p">,</span> <span class="n">inodenp</span><span class="p">)</span>
        <span class="n">inodenp</span><span class="o">.</span><span class="n">setCollideMask</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">BitMask32</span><span class="o">.</span><span class="n">allOn</span><span class="p">())</span>
        <span class="n">inodenp</span><span class="o">.</span><span class="n">node</span><span class="p">()</span><span class="o">.</span><span class="n">setAngularDamping</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>
        <span class="n">inodenp</span><span class="o">.</span><span class="n">node</span><span class="p">()</span><span class="o">.</span><span class="n">setLinearDamping</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;attach node to world&quot;</span><span class="p">)</span>
        <span class="c1"># inodenp.setMat(pmat)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">world</span><span class="o">.</span><span class="n">attachRigidBody</span><span class="p">(</span><span class="n">inodenp</span><span class="o">.</span><span class="n">node</span><span class="p">())</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;node attached to world&quot;</span><span class="p">)</span>
        <span class="n">inodenp</span> <span class="o">=</span> <span class="n">inodenp</span><span class="o">.</span><span class="n">node</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;add msphere &quot;</span><span class="p">,</span> <span class="n">inodenp</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">rb_panda</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inodenp</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">inodenp</span></div>

<div class="viewcode-block" id="GrowIngredient.walkSpherePanda"><a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.grow.GrowIngredient.walkSpherePanda">[docs]</a>    <span class="k">def</span> <span class="nf">walkSpherePanda</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">pt1</span><span class="p">,</span> <span class="n">pt2</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">histoVol</span><span class="p">,</span> <span class="n">marge</span><span class="o">=</span><span class="mf">90.0</span><span class="p">,</span> <span class="n">checkcollision</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">usePP</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;use a random point on a sphere of radius uLength, and useCylinder collision on the grid&quot;&quot;&quot;</span>
        <span class="n">v</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">measure_distance</span><span class="p">(</span><span class="n">pt1</span><span class="p">,</span> <span class="n">pt2</span><span class="p">,</span> <span class="n">vec</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">found</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">attempted</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">pt</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]</span>
        <span class="n">safetycutoff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rejection_threshold</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">constraintMarge</span><span class="p">:</span>
            <span class="n">safetycutoff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rejection_threshold</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">runTimeDisplay</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;walking&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
            <span class="n">sp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">getObject</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">sp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">sp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mf">2.0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># sp.SetAbsPos(self.vi.FromVec(startingPoint))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
        <span class="n">liste_nodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">cutoff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">largestProteinSize</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">uLength</span>
        <span class="n">closesbody_indice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_closest_ingredients</span><span class="p">(</span><span class="n">pt2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="n">cutoff</span><span class="p">)</span>
        <span class="n">liste_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_rbNodes</span><span class="p">(</span>
            <span class="n">closesbody_indice</span><span class="p">,</span> <span class="n">pt2</span><span class="p">,</span> <span class="n">prevpoint</span><span class="o">=</span><span class="n">pt1</span><span class="p">,</span> <span class="n">getInfo</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="n">alternate</span><span class="p">,</span> <span class="n">ia</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pick_alternate</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;pick alternate&quot;</span><span class="p">,</span> <span class="n">alternate</span><span class="p">,</span> <span class="n">ia</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">prev_alt</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">prev_was_alternate</span><span class="p">:</span>
            <span class="n">alternate</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">p_alternate</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># self.partners[alternate]#self.env.getIngrFromNameInRecipe(alternate,self.recipe )</span>
        <span class="c1"># if p_alternate.getProperties(&quot;bend&quot;):</span>
        <span class="n">nextPoint</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># p_alternate.getProperties(&quot;pt2&quot;)</span>
        <span class="n">marge_in</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># p_alternate.getProperties(&quot;marge_in&quot;)</span>
        <span class="n">dihedral</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># p_alternate.getProperties(&quot;diehdral&quot;)#for next point</span>
        <span class="n">length</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># p_alternate.getProperties(&quot;length&quot;)#for next point</span>
        <span class="c1"># prepare halton if needed</span>
        <span class="n">newPt</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">newPts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">prev_alt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># and self.prev_alt_pt is not None:</span>
            <span class="n">p_alternate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">partners</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">prev_alt</span><span class="p">]</span>
            <span class="n">dihedral</span> <span class="o">=</span> <span class="n">p_alternate</span><span class="o">.</span><span class="n">dihedral</span>
            <span class="n">nextPoint</span> <span class="o">=</span> <span class="n">p_alternate</span><span class="o">.</span><span class="n">get_point</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">marge_out</span> <span class="o">=</span> <span class="n">p_alternate</span><span class="o">.</span><span class="n">margin_out</span>  <span class="c1"># marge out ?</span>
            <span class="k">if</span> <span class="n">dihedral</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mask_sphere_points</span><span class="p">(</span>
                    <span class="n">v</span><span class="p">,</span>
                    <span class="n">pt1</span><span class="p">,</span>
                    <span class="n">marge_out</span><span class="p">,</span>
                    <span class="n">liste_nodes</span><span class="p">,</span>
                    <span class="mi">0</span><span class="p">,</span>
                    <span class="n">pv</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">prev_vec</span><span class="p">,</span>
                    <span class="n">marge_diedral</span><span class="o">=</span><span class="n">dihedral</span><span class="p">,</span>
                    <span class="n">v3</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">prev_v3</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="n">alternate</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">prev_alt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">point_is_not_available</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">alternate</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">prev_was_alternate</span><span class="p">:</span>
            <span class="c1"># next point shouldnt be an alternate</span>
            <span class="n">p_alternate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">partners</span><span class="p">[</span>
                <span class="n">alternate</span>
            <span class="p">]</span>  <span class="c1"># self.env.getIngrFromNameInRecipe(alternate,self.recipe )</span>
            <span class="n">entrypoint</span> <span class="o">=</span> <span class="n">p_alternate</span><span class="o">.</span><span class="n">get_point</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">nextPoint</span> <span class="o">=</span> <span class="n">p_alternate</span><span class="o">.</span><span class="n">get_point</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">marge_in</span> <span class="o">=</span> <span class="n">p_alternate</span><span class="o">.</span><span class="n">margin_in</span>
            <span class="n">dihedral</span> <span class="o">=</span> <span class="n">p_alternate</span><span class="o">.</span><span class="n">dihedral</span>  <span class="c1"># for next point</span>
            <span class="n">length</span> <span class="o">=</span> <span class="n">p_alternate</span><span class="o">.</span><span class="n">length</span>  <span class="c1"># for next point</span>
            <span class="k">if</span> <span class="n">entrypoint</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mask_sphere_points</span><span class="p">(</span>
                    <span class="n">v</span><span class="p">,</span>
                    <span class="n">pt2</span><span class="p">,</span>
                    <span class="n">marge_in</span><span class="p">,</span>
                    <span class="n">liste_nodes</span><span class="p">,</span>
                    <span class="mi">0</span><span class="p">,</span>
                    <span class="n">pv</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">marge_diedral</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">alternate</span><span class="o">=</span><span class="n">alternate</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">marge_in</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mask_sphere_points</span><span class="p">(</span>
                    <span class="n">v</span><span class="p">,</span> <span class="n">pt2</span><span class="p">,</span> <span class="n">marge_in</span><span class="p">,</span> <span class="n">liste_nodes</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pv</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">marge_diedral</span><span class="o">=</span><span class="kc">None</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mask_sphere_points</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">pt2</span><span class="p">,</span> <span class="n">marge</span> <span class="o">+</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">liste_nodes</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">prev_was_alternate</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">useHalton</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mask_sphere_points</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">pt2</span><span class="p">,</span> <span class="n">marge</span> <span class="o">+</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">liste_nodes</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">histoVol</span><span class="o">.</span><span class="n">runTimeDisplay</span><span class="p">:</span>
            <span class="n">points_mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sphere_points_mask</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">verts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sphere_points</span><span class="p">[</span><span class="n">points_mask</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">uLength</span> <span class="o">+</span> <span class="n">pt2</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;Hcloud&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
            <span class="n">pc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">getObject</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">pc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">pc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">PointCloudObject</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">vertices</span><span class="o">=</span><span class="n">verts</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">updateMesh</span><span class="p">(</span><span class="n">pc</span><span class="p">,</span> <span class="n">vertices</span><span class="o">=</span><span class="n">verts</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>

        <span class="k">while</span> <span class="ow">not</span> <span class="n">found</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;attempt &quot;</span><span class="p">,</span> <span class="n">attempted</span><span class="p">,</span> <span class="n">marge</span><span class="p">)</span>
            <span class="c1"># main loop thattryto found the next point (similar to jitter)</span>
            <span class="k">if</span> <span class="n">attempted</span> <span class="o">&gt;=</span> <span class="n">safetycutoff</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;break too much attempt &quot;</span><span class="p">,</span> <span class="n">attempted</span><span class="p">,</span> <span class="n">safetycutoff</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">False</span>  <span class="c1"># numpy.array(pt2).flatten()+numpy.array(pt),False</span>
            <span class="c1"># pt = numpy.array(self.vi.randpoint_onsphere(self.uLength,biased=(uniform(0.,1.0)*marge)/360.0))*numpy.array([1,1,0])</span>
            <span class="n">point_is_not_available</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">newPt</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">prev_alt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">dihedral</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">newPt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pickAlternateHalton</span><span class="p">(</span><span class="n">pt1</span><span class="p">,</span> <span class="n">pt2</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">nextPoint</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">newPt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prev_alt_pt</span>
                <span class="k">if</span> <span class="n">newPt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="s2">&quot;no sphere points available with prev_alt&quot;</span><span class="p">,</span> <span class="n">dihedral</span><span class="p">,</span> <span class="n">nextPoint</span>
                    <span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">prev_alt</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">False</span>
                    <span class="n">attempted</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># ?</span>
                    <span class="k">continue</span>
            <span class="k">elif</span> <span class="n">alternate</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">marge_in</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">newPt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pickAlternateHalton</span><span class="p">(</span><span class="n">pt1</span><span class="p">,</span> <span class="n">pt2</span><span class="p">,</span> <span class="n">length</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">newPt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;no sphere points available with marge_in&quot;</span><span class="p">)</span>
                        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">False</span>
                    <span class="n">jtrans</span><span class="p">,</span> <span class="n">rotMatj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_alternate_position</span><span class="p">(</span>
                        <span class="n">alternate</span><span class="p">,</span> <span class="n">ia</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">pt2</span><span class="p">,</span> <span class="n">newPt</span>
                    <span class="p">)</span>
                <span class="k">elif</span> <span class="n">nextPoint</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">newPts</span><span class="p">,</span> <span class="n">jtrans</span><span class="p">,</span> <span class="n">rotMatj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">place_alternate</span><span class="p">(</span>
                        <span class="n">alternate</span><span class="p">,</span> <span class="n">ia</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">pt1</span><span class="p">,</span> <span class="n">pt2</span>
                    <span class="p">)</span>
                    <span class="c1"># found = self.check_alternate_collision(pt2,newPts,jtrans,rotMatj)</span>
                    <span class="n">newPt</span> <span class="o">=</span> <span class="n">newPts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="c1"># attempted should be to safetycutoff</span>
                    <span class="n">attempted</span> <span class="o">=</span> <span class="n">safetycutoff</span>
                    <span class="k">if</span> <span class="n">newPt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;no  points available place_alternate&quot;</span><span class="p">)</span>
                        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">False</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># no constraint we just place alternate relatively to the given halton new points</span>
                    <span class="n">newPt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pickAlternateHalton</span><span class="p">(</span><span class="n">pt1</span><span class="p">,</span> <span class="n">pt2</span><span class="p">,</span> <span class="n">length</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">newPt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;no sphere points available with marge_in&quot;</span><span class="p">)</span>
                        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">False</span>
                    <span class="n">jtrans</span><span class="p">,</span> <span class="n">rotMatj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_alternate_position</span><span class="p">(</span>
                        <span class="n">alternate</span><span class="p">,</span> <span class="n">ia</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">pt2</span><span class="p">,</span> <span class="n">newPt</span>
                    <span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">useHalton</span><span class="p">:</span>
                <span class="n">newPt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pickHalton</span><span class="p">(</span><span class="n">pt1</span><span class="p">,</span> <span class="n">pt2</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">newPt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;no sphere points available with marge_in&quot;</span><span class="p">)</span>
                    <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">newPt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pickRandomSphere</span><span class="p">(</span><span class="n">pt1</span><span class="p">,</span> <span class="n">pt2</span><span class="p">,</span> <span class="n">marge</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">histoVol</span><span class="o">.</span><span class="n">runTimeDisplay</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">setTranslation</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">newPt</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;picked point&quot;</span><span class="p">,</span> <span class="n">newPt</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">newPt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;no  points available&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">False</span>
            <span class="n">r</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span>
            <span class="n">point_is_not_available</span> <span class="o">=</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">point_is_available</span><span class="p">(</span><span class="n">newPt</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;point is available&quot;</span><span class="p">,</span>
                <span class="n">point_is_not_available</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">constraintMarge</span><span class="p">,</span>
                <span class="n">marge</span><span class="p">,</span>
                <span class="n">attempted</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rejection_threshold</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">point_is_not_available</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">constraintMarge</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">marge</span> <span class="o">&gt;=</span> <span class="mi">175</span><span class="p">:</span>
                        <span class="n">attempted</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="n">attempted</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rejection_threshold</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
                        <span class="ow">and</span> <span class="ow">not</span> <span class="n">alternate</span>
                    <span class="p">):</span>
                        <span class="n">marge</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="n">attempted</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="c1"># need to recompute the mask</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">alternate</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">useHalton</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">prev_alt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">sphere_points_mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">sphere_points_nb</span><span class="p">,</span> <span class="s2">&quot;i&quot;</span>
                            <span class="p">)</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">mask_sphere_points</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">pt2</span><span class="p">,</span> <span class="n">marge</span> <span class="o">+</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">liste_nodes</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">histoVol</span><span class="o">.</span><span class="n">runTimeDisplay</span><span class="p">:</span>
                                <span class="n">points_mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sphere_points_mask</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                                <span class="n">verts</span> <span class="o">=</span> <span class="p">(</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">sphere_points</span><span class="p">[</span><span class="n">points_mask</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">uLength</span> <span class="o">+</span> <span class="n">pt2</span>
                                <span class="p">)</span>
                                <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;Hcloud&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
                                <span class="n">pc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">getObject</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                                <span class="k">if</span> <span class="n">pc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                                    <span class="n">pc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">PointCloudObject</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">vertices</span><span class="o">=</span><span class="n">verts</span><span class="p">)[</span>
                                        <span class="mi">0</span>
                                    <span class="p">]</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">updateMesh</span><span class="p">(</span><span class="n">pc</span><span class="p">,</span> <span class="n">vertices</span><span class="o">=</span><span class="n">verts</span><span class="p">)</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
                <span class="n">attempted</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">checkcollision</span><span class="p">:</span>
                <span class="n">collision</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">cutoff</span> <span class="o">=</span> <span class="n">histoVol</span><span class="o">.</span><span class="n">largestProteinSize</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">uLength</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">alternate</span><span class="p">:</span>
                    <span class="n">prev</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">histoVol</span><span class="o">.</span><span class="n">rTrans</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="n">prev</span> <span class="o">=</span> <span class="n">histoVol</span><span class="o">.</span><span class="n">rTrans</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

                    <span class="n">a</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">newPt</span><span class="p">)</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pt2</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
                    <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pt2</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="o">+</span> <span class="n">a</span>
                    <span class="c1"># this s where we use panda</span>
                    <span class="n">rotMatj</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
                        <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
                        <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
                        <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span>
                    <span class="p">]</span>
                    <span class="n">jtrans</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]</span>
                    <span class="c1"># move it or generate it inplace</span>
                    <span class="c1">#                    oldpos1=self.positions</span>
                    <span class="c1">#                    oldpos2=self.positions2</span>
                    <span class="c1">#                    self.positions=[[numpy.array(pt2).flatten()],]</span>
                    <span class="c1">#                    self.positions2=[[newPt],]</span>
                    <span class="c1">#                    if self.use_rbsphere :</span>
                    <span class="c1">#                        rbnode = self.addRBsegment(numpy.array(pt2).flatten(),newPt)</span>
                    <span class="c1">#                    else :</span>
                    <span class="c1">#                        rbnode = histoVol.callFunction(histoVol.addRB,(self, numpy.array(jtrans), numpy.array(rotMatj),),{&quot;rtype&quot;:self.type},)#cylinder</span>
                    <span class="c1">#                    #histoVol.callFunction(histoVol.moveRBnode,(rbnode, jtrans, rotMatj,))</span>
                    <span class="c1"># if inside organelle check for collision with it ?</span>
                    <span class="c1">#                    self.positions=oldpos1</span>
                    <span class="c1">#                    self.positions2=oldpos2</span>
                    <span class="n">rotMatj</span><span class="p">,</span> <span class="n">jtrans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getJtransRot</span><span class="p">(</span>
                        <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pt2</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">newPt</span>
                    <span class="p">)</span>
                    <span class="n">rbnode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_rb_model</span><span class="p">()</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">callFunction</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">moveRBnode</span><span class="p">,</span>
                        <span class="p">(</span>
                            <span class="n">rbnode</span><span class="p">,</span>
                            <span class="n">jtrans</span><span class="p">,</span>
                            <span class="n">rotMatj</span><span class="p">,</span>
                        <span class="p">),</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">rTrans</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">r</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">prev</span> <span class="o">=</span> <span class="kc">None</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">rTrans</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                            <span class="n">prev</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">rTrans</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">closesbody_indice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_closest_ingredients</span><span class="p">(</span>
                            <span class="n">newPt</span><span class="p">,</span> <span class="n">histoVol</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="n">cutoff</span>
                        <span class="p">)</span>  <span class="c1"># vself.radii[0][0]*2.0</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">closesbody_indice</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No CloseBody&quot;</span><span class="p">)</span>
                            <span class="n">r</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span>  <span class="c1"># closesbody_indice[0] == -1</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;collision get RB &quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">closesbody_indice</span><span class="p">))</span>
                            <span class="n">liste_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_rbNodes</span><span class="p">(</span>
                                <span class="n">closesbody_indice</span><span class="p">,</span> <span class="n">jtrans</span><span class="p">,</span> <span class="n">prevpoint</span><span class="o">=</span><span class="n">prev</span><span class="p">,</span> <span class="n">getInfo</span><span class="o">=</span><span class="kc">True</span>
                            <span class="p">)</span>
                            <span class="k">if</span> <span class="n">usePP</span><span class="p">:</span>
                                <span class="c1"># use self.grab_cb and self.pp_server</span>
                                <span class="c1"># Divide the task or just submit job</span>
                                <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">grab_cb</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
                                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">liste_nodes</span><span class="p">)</span> <span class="o">/</span> <span class="n">autopack</span><span class="o">.</span><span class="n">ncpus</span><span class="p">):</span>
                                    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">autopack</span><span class="o">.</span><span class="n">ncpus</span><span class="p">):</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">pp_server</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">world</span><span class="o">.</span><span class="n">contactTestPair</span><span class="p">,</span>
                                            <span class="p">(</span><span class="n">rbnode</span><span class="p">,</span> <span class="n">liste_nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">0</span><span class="p">]),</span>
                                            <span class="n">callback</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">grab_cb</span><span class="o">.</span><span class="n">grab</span><span class="p">,</span>
                                        <span class="p">)</span>
                                        <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">pp_server</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
                                    <span class="n">r</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">grab_cb</span><span class="o">.</span><span class="n">collision</span><span class="p">[:])</span>
                                    <span class="k">if</span> <span class="kc">True</span> <span class="ow">in</span> <span class="n">r</span><span class="p">:</span>
                                        <span class="k">break</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">liste_nodes</span><span class="p">:</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">moveRBnode</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">node</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                                    <span class="n">col</span> <span class="o">=</span> <span class="p">(</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">world</span><span class="o">.</span><span class="n">contactTestPair</span><span class="p">(</span>
                                            <span class="n">rbnode</span><span class="p">,</span> <span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                                        <span class="p">)</span><span class="o">.</span><span class="n">getNumContacts</span><span class="p">()</span>
                                        <span class="o">&gt;</span> <span class="mi">0</span>
                                    <span class="p">)</span>
                                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;collision? &quot;</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span>
                                    <span class="n">r</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span><span class="p">]</span>
                                    <span class="k">if</span> <span class="n">col</span><span class="p">:</span>
                                        <span class="k">break</span>
                    <span class="n">collision</span> <span class="o">=</span> <span class="kc">True</span> <span class="ow">in</span> <span class="n">r</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">collision</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">alternate_interval</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">alternate_interval</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mini_interval</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">prev_was_alternate</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">prev_alt</span> <span class="o">=</span> <span class="kc">None</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">prev_vec</span> <span class="o">=</span> <span class="kc">None</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">update_data_tree</span><span class="p">(</span>
                            <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pt2</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">rotMatj</span><span class="p">,</span> <span class="n">pt1</span><span class="o">=</span><span class="n">pt2</span><span class="p">,</span> <span class="n">pt2</span><span class="o">=</span><span class="n">newPt</span>
                        <span class="p">)</span>  <span class="c1"># jtrans</span>
                        <span class="c1">#                        histoVol.callFunction(histoVol.delRB,(rbnode,))</span>
                        <span class="k">return</span> <span class="n">newPt</span><span class="p">,</span> <span class="kc">True</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;alternate collision&quot;</span><span class="p">)</span>
                    <span class="n">rotMatj1</span><span class="p">,</span> <span class="n">jtrans1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getJtransRot_r</span><span class="p">(</span>
                        <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pt2</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">newPt</span>
                    <span class="p">)</span>
                    <span class="c1"># collision,liste_nodes = self.collision_rapid(jtrans1,rotMatj1,cutoff=cutoff,usePP=usePP,point=newPt)</span>
                    <span class="c1"># the collision shouldnt look for previous cylinder</span>
                    <span class="n">collision_alternate</span><span class="p">,</span> <span class="n">liste_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">partners</span><span class="p">[</span>
                        <span class="n">alternate</span>
                    <span class="p">]</span><span class="o">.</span><span class="n">ingr</span><span class="o">.</span><span class="n">pandaBullet_collision</span><span class="p">(</span><span class="n">jtrans</span><span class="p">,</span> <span class="n">rotMatj</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">getnodes</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">collision</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">collision_alternate</span>  <span class="c1"># (collision or collision_alternate)</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">collision</span><span class="p">:</span>
                        <span class="c1"># what about point in curve and result</span>
                        <span class="c1"># self.update_data_tree(jtrans1,rotMatj1,pt1=pt2,pt2=newPt)</span>
                        <span class="c1"># self.update_data_tree(jtrans1,rotMatj1,pt1=newPt,pt2=newPts[1])</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">partners</span><span class="p">[</span><span class="n">alternate</span><span class="p">]</span><span class="o">.</span><span class="n">ingr</span><span class="o">.</span><span class="n">update_data_tree</span><span class="p">(</span><span class="n">jtrans</span><span class="p">,</span> <span class="n">rotMatj</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">compartment</span><span class="o">.</span><span class="n">molecules</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="p">[</span><span class="n">jtrans</span><span class="p">,</span> <span class="n">rotMatj</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">partners</span><span class="p">[</span><span class="n">alternate</span><span class="p">]</span><span class="o">.</span><span class="n">ingr</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                        <span class="p">)</span>  <span class="c1"># transpose ?</span>
                        <span class="n">newv</span><span class="p">,</span> <span class="n">d1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">measure_distance</span><span class="p">(</span><span class="n">pt2</span><span class="p">,</span> <span class="n">newPt</span><span class="p">,</span> <span class="n">vec</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                        <span class="c1"># v,d2 = self.vi.measure_distance(newPt,newPts[1],vec=True)</span>
                        <span class="c1"># self.currentLength += d1</span>
                        <span class="k">if</span> <span class="n">dihedral</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">prev_alt</span> <span class="o">=</span> <span class="n">alternate</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">prev_v3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getV3</span><span class="p">(</span>
                                <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pt2</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">newPt</span><span class="p">,</span> <span class="n">alternate</span>
                            <span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">prev_vec</span> <span class="o">=</span> <span class="n">v</span>
                        <span class="k">if</span> <span class="n">nextPoint</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">dihedral</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">prev_alt_pt</span> <span class="o">=</span> <span class="n">newPts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

                        <span class="bp">self</span><span class="o">.</span><span class="n">alternate_interval</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="k">return</span> <span class="n">newPt</span><span class="p">,</span> <span class="kc">True</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">prev_alt_pt</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># print (&quot; collide ?&quot;,collision)</span>
                <span class="k">if</span> <span class="n">collision</span><span class="p">:</span>  <span class="c1"># increment the range</span>
                    <span class="k">if</span> <span class="n">alternate</span><span class="p">:</span>
                        <span class="n">attempted</span> <span class="o">=</span> <span class="n">safetycutoff</span>
                    <span class="k">elif</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">constraintMarge</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">marge</span> <span class="o">&gt;=</span> <span class="mi">180</span><span class="p">:</span>  <span class="c1"># pi</span>
                            <span class="n">attempted</span> <span class="o">+=</span> <span class="mi">1</span>
                            <span class="k">continue</span>
                        <span class="k">if</span> <span class="p">(</span>
                            <span class="n">attempted</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rejection_threshold</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
                            <span class="ow">and</span> <span class="ow">not</span> <span class="n">alternate</span>
                        <span class="p">):</span>
                            <span class="n">marge</span> <span class="o">+=</span> <span class="mi">1</span>
                            <span class="n">attempted</span> <span class="o">=</span> <span class="mi">0</span>
                            <span class="c1"># need to recompute the mask</span>
                            <span class="k">if</span> <span class="p">(</span>
                                <span class="ow">not</span> <span class="n">alternate</span>
                                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">useHalton</span>
                                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">prev_alt</span> <span class="ow">is</span> <span class="kc">None</span>
                            <span class="p">):</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">sphere_points_mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">sphere_points_nb</span><span class="p">,</span> <span class="s2">&quot;i&quot;</span>
                                <span class="p">)</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">mask_sphere_points</span><span class="p">(</span>
                                    <span class="n">v</span><span class="p">,</span> <span class="n">pt2</span><span class="p">,</span> <span class="n">marge</span> <span class="o">+</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">liste_nodes</span><span class="p">,</span> <span class="mi">0</span>
                                <span class="p">)</span>
                                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">runTimeDisplay</span><span class="p">:</span>
                                    <span class="n">points_mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">sphere_points_mask</span>
                                    <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                                    <span class="n">v</span> <span class="o">=</span> <span class="p">(</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">sphere_points</span><span class="p">[</span><span class="n">points_mask</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">uLength</span>
                                        <span class="o">+</span> <span class="n">pt2</span>
                                    <span class="p">)</span>
                                    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;Hcloud&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
                                    <span class="n">sp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">getObject</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                                    <span class="k">if</span> <span class="n">sp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                                        <span class="n">pc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">PointCloudObject</span><span class="p">(</span>
                                            <span class="s2">&quot;bbpoint&quot;</span><span class="p">,</span> <span class="n">vertices</span><span class="o">=</span><span class="n">v</span>
                                        <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                                    <span class="k">else</span><span class="p">:</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">updateMesh</span><span class="p">(</span><span class="n">pc</span><span class="p">,</span> <span class="n">vertices</span><span class="o">=</span><span class="n">v</span><span class="p">)</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">attempted</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">attempted</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;rejected collision&quot;</span><span class="p">)</span>
                    <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="c1">#                histoVol.callFunction(histoVol.delRB,(rbnode,))</span>
                <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pt2</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="o">+</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pt</span><span class="p">),</span> <span class="kc">True</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;end loop add attempt &quot;</span><span class="p">,</span> <span class="n">attempted</span><span class="p">)</span>
            <span class="n">attempted</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1"># histoVol.callFunction(histoVol.delRB,(rbnode,))</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pt2</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="o">+</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pt</span><span class="p">),</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="GrowIngredient.pickHalton"><a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.grow.GrowIngredient.pickHalton">[docs]</a>    <span class="k">def</span> <span class="nf">pickHalton</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pt1</span><span class="p">,</span> <span class="n">pt2</span><span class="p">):</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getNextPoint</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">p</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>  <span class="c1"># *self.uLength</span>
        <span class="n">pt</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>  <span class="c1"># *numpy.array(self.max_jitter)#?</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pt2</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="o">+</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span></div>

<div class="viewcode-block" id="GrowIngredient.pickRandomSphere"><a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.grow.GrowIngredient.pickRandomSphere">[docs]</a>    <span class="k">def</span> <span class="nf">pickRandomSphere</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pt1</span><span class="p">,</span> <span class="n">pt2</span><span class="p">,</span> <span class="n">marge</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">advance_randpoint_onsphere</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">uLength</span><span class="p">,</span> <span class="n">marge</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">marge</span><span class="p">),</span> <span class="n">vector</span><span class="o">=</span><span class="n">v</span>
        <span class="p">)</span>
        <span class="n">pt</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_jitter</span><span class="p">)</span>
        <span class="c1"># the new position is the previous point (pt2) plus the random point</span>
        <span class="n">newPt</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pt2</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="o">+</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>
        <span class="c1"># compute the angle between the previous direction (pt1-&gt;pt2) and the new random one (pt)</span>
        <span class="c1">#        angle=self.vi.angle_between_vectors(numpy.array(v),numpy.array(pt))</span>
        <span class="c1">#        test= abs(math.degrees(angle)) &lt;= marge+2.0</span>
        <span class="k">return</span> <span class="n">newPt</span></div>

<div class="viewcode-block" id="GrowIngredient.pickAlternateHalton"><a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.grow.GrowIngredient.pickAlternateHalton">[docs]</a>    <span class="k">def</span> <span class="nf">pickAlternateHalton</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pt1</span><span class="p">,</span> <span class="n">pt2</span><span class="p">,</span> <span class="n">length</span><span class="p">):</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getNextPoint</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">p</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
            <span class="c1"># return None,False</span>
        <span class="k">if</span> <span class="n">length</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">uLength</span><span class="p">)</span> <span class="o">*</span> <span class="n">length</span>
        <span class="n">newPt</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pt2</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="o">+</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">newPt</span></div>

<div class="viewcode-block" id="GrowIngredient.resetLastPoint"><a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.grow.GrowIngredient.resetLastPoint">[docs]</a>    <span class="k">def</span> <span class="nf">resetLastPoint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">listePtCurve</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">nb_ingredient</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">rTrans</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">rTrans</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">rRot</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">rRot</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># rotMatj</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">rIngr</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">rIngr</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">result</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">result</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># rebuild kdtree</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">rTrans</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">close_ingr_bhtree</span> <span class="o">=</span> <span class="n">spatial</span><span class="o">.</span><span class="n">cKDTree</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">rTrans</span><span class="p">,</span> <span class="n">leafsize</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>

        <span class="c1"># also remove from the result ?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">currentLength</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">uLength</span>
        <span class="c1"># not enought the information is still here</span>
        <span class="n">listePtCurve</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">listePtCurve</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="GrowIngredient.grow"><a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.grow.GrowIngredient.grow">[docs]</a>    <span class="k">def</span> <span class="nf">grow</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">previousPoint</span><span class="p">,</span>
        <span class="n">startingPoint</span><span class="p">,</span>
        <span class="n">secondPoint</span><span class="p">,</span>
        <span class="n">listePtCurve</span><span class="p">,</span>
        <span class="n">listePtLinear</span><span class="p">,</span>
        <span class="n">histoVol</span><span class="p">,</span>
        <span class="n">ptInd</span><span class="p">,</span>
        <span class="n">free_points</span><span class="p">,</span>
        <span class="n">nbFreePoints</span><span class="p">,</span>
        <span class="n">distance</span><span class="p">,</span>
        <span class="n">dpad</span><span class="p">,</span>
        <span class="n">stepByStep</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">r</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">usePP</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="c1"># r is for reverse growing</span>
        <span class="n">Done</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">runTimeDisplay</span> <span class="o">=</span> <span class="n">histoVol</span><span class="o">.</span><span class="n">runTimeDisplay</span>
        <span class="n">gridPointsCoords</span> <span class="o">=</span> <span class="n">histoVol</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">masterGridPositions</span>
        <span class="k">if</span> <span class="n">runTimeDisplay</span><span class="p">:</span>
            <span class="n">parent</span> <span class="o">=</span> <span class="n">histoVol</span><span class="o">.</span><span class="n">afviewer</span><span class="o">.</span><span class="n">orgaToMasterGeom</span><span class="p">[</span><span class="bp">self</span><span class="p">]</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">success</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">safetycutoff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">safetycutoff</span>

        <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">walkingMode</span> <span class="o">==</span> <span class="s2">&quot;lattice&quot;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">compNum</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">o</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">compartments</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">compNum</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">surfacePointsCoords</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>
        <span class="n">alternate</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">secondPoint</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">previousPoint</span> <span class="o">=</span> <span class="n">startingPoint</span>
            <span class="n">startingPoint</span> <span class="o">=</span> <span class="n">secondPoint</span>

        <span class="k">while</span> <span class="ow">not</span> <span class="n">Done</span><span class="p">:</span>
            <span class="c1"># rest the mask</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sphere_points_mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">10000</span><span class="p">,</span> <span class="s2">&quot;i&quot;</span><span class="p">)</span>
            <span class="n">alternate</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;attempt K &quot;</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="n">safetycutoff</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;break safetycutoff&quot;</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">success</span><span class="p">,</span> <span class="n">nbFreePoints</span><span class="p">,</span> <span class="n">free_points</span>
            <span class="k">if</span> <span class="n">runTimeDisplay</span><span class="p">:</span>  <span class="c1"># or histoVol.afviewer.doSpheres:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">listePtLinear</span><span class="p">))</span> <span class="o">+</span> <span class="s2">&quot;sp&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">ptInd</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">r</span><span class="p">:</span>
                    <span class="n">name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">listePtLinear</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;sp&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">ptInd</span><span class="p">)</span>
                <span class="n">sp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">radii</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">parent</span><span class="o">=</span><span class="n">parent</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">setTranslation</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">startingPoint</span><span class="p">)</span>
                <span class="c1">#                sp.SetAbsPos(self.vi.FromVec(startingPoint))</span>
                <span class="c1"># sp=self.vi.newInstance(name,histoVol.afviewer.pesph,</span>
                <span class="c1">#                                       location=startingPoint,parent=parent)</span>
                <span class="c1"># self.vi.scaleObj(sp,self.radii[0][0])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
            <span class="c1"># pick next point and test collision.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">walkingMode</span> <span class="o">==</span> <span class="s2">&quot;sphere&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">place_method</span> <span class="o">==</span> <span class="s2">&quot;pandaBullet&quot;</span><span class="p">:</span>
                    <span class="n">secondPoint</span><span class="p">,</span> <span class="n">success</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">walkSpherePanda</span><span class="p">(</span>
                        <span class="n">previousPoint</span><span class="p">,</span>
                        <span class="n">startingPoint</span><span class="p">,</span>
                        <span class="n">distance</span><span class="p">,</span>
                        <span class="n">histoVol</span><span class="p">,</span>
                        <span class="n">marge</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">marge</span><span class="p">,</span>
                        <span class="n">checkcollision</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="n">usePP</span><span class="o">=</span><span class="n">usePP</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="n">secondPoint</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">nbFreePoints</span><span class="p">,</span> <span class="n">free_points</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">secondPoint</span><span class="p">,</span> <span class="n">success</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">walkSphere</span><span class="p">(</span>
                        <span class="n">previousPoint</span><span class="p">,</span>
                        <span class="n">startingPoint</span><span class="p">,</span>
                        <span class="n">distance</span><span class="p">,</span>
                        <span class="n">histoVol</span><span class="p">,</span>
                        <span class="n">dpad</span><span class="p">,</span>
                        <span class="n">marge</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">marge</span><span class="p">,</span>
                        <span class="n">checkcollision</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">walkingMode</span> <span class="o">==</span> <span class="s2">&quot;lattice&quot;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">compNum</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">secondPoint</span><span class="p">,</span> <span class="n">success</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">walkLatticeSurface</span><span class="p">(</span>
                    <span class="n">startingPoint</span><span class="p">,</span>
                    <span class="n">distance</span><span class="p">,</span>
                    <span class="n">histoVol</span><span class="p">,</span>
                    <span class="mi">2</span><span class="p">,</span>
                    <span class="n">mask</span><span class="p">,</span>
                    <span class="n">marge</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">marge</span><span class="p">,</span>
                    <span class="n">checkcollision</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">saw</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">walkingMode</span> <span class="o">==</span> <span class="s2">&quot;lattice&quot;</span><span class="p">:</span>
                <span class="n">secondPoint</span><span class="p">,</span> <span class="n">success</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">walkLattice</span><span class="p">(</span>
                    <span class="n">startingPoint</span><span class="p">,</span>
                    <span class="n">distance</span><span class="p">,</span>
                    <span class="n">histoVol</span><span class="p">,</span>
                    <span class="mi">2</span><span class="p">,</span>
                    <span class="n">marge</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">marge</span><span class="p">,</span>
                    <span class="n">checkcollision</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">saw</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">secondPoint</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">success</span><span class="p">:</span>  <span class="c1"># no available point? try again ?</span>
                <span class="c1"># secondPoint = numpy.array(previousPoint)</span>
                <span class="c1"># startingPoint = previousPoint_store</span>
                <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">secondPoint</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">alternate</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">startingPoint</span> <span class="o">=</span> <span class="n">secondPoint</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">secondPoint</span> <span class="o">=</span> <span class="n">secondPoint</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">v</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">measure_distance</span><span class="p">(</span><span class="n">startingPoint</span><span class="p">,</span> <span class="n">secondPoint</span><span class="p">,</span> <span class="n">vec</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">startingPoint</span> <span class="o">=</span> <span class="n">get_reflected_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">startingPoint</span><span class="p">)</span>
            <span class="n">secondPoint</span> <span class="o">=</span> <span class="n">get_reflected_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">secondPoint</span><span class="p">)</span>
            <span class="n">rotMatj</span><span class="p">,</span> <span class="n">jtrans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getJtransRot</span><span class="p">(</span><span class="n">startingPoint</span><span class="p">,</span> <span class="n">secondPoint</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">r</span><span class="p">:</span>
                <span class="c1"># reverse mode</span>
                <span class="n">rotMatj</span><span class="p">,</span> <span class="n">jtrans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getJtransRot</span><span class="p">(</span><span class="n">secondPoint</span><span class="p">,</span> <span class="n">startingPoint</span><span class="p">)</span>
            <span class="n">cent1T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformPoints</span><span class="p">(</span><span class="n">jtrans</span><span class="p">,</span> <span class="n">rotMatj</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">cent2T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformPoints</span><span class="p">(</span><span class="n">jtrans</span><span class="p">,</span> <span class="n">rotMatj</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">positions2</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;here is output of walk&quot;</span><span class="p">,</span>
                <span class="n">startingPoint</span><span class="p">,</span>
                <span class="n">secondPoint</span><span class="p">,</span>
                <span class="n">d</span><span class="p">,</span>
                <span class="n">success</span><span class="p">,</span>
                <span class="n">alternate</span><span class="p">,</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">secondPoint</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">success</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;success grow&quot;</span><span class="p">)</span>
                <span class="c1"># do not append if alternate was used</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">prev_alt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">jtrans</span><span class="p">,</span> <span class="n">rotMatj</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">r</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">alternate</span><span class="p">:</span>
                        <span class="n">listePtLinear</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">startingPoint</span><span class="p">)</span>
                    <span class="n">listePtLinear</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">secondPoint</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">alternate</span><span class="p">:</span>
                        <span class="n">listePtLinear</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">startingPoint</span><span class="p">)</span>
                    <span class="n">listePtLinear</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">secondPoint</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">currentLength</span> <span class="o">+=</span> <span class="n">d</span>
                <span class="k">if</span> <span class="n">runTimeDisplay</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;cylinder with&quot;</span><span class="p">,</span> <span class="n">cent1T</span><span class="p">,</span> <span class="n">cent2T</span><span class="p">)</span>
                    <span class="n">name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">listePtLinear</span><span class="p">))</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">ptInd</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;cyl&quot;</span>
                    <span class="k">if</span> <span class="n">r</span><span class="p">:</span>
                        <span class="n">name</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">listePtLinear</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">ptInd</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;cyl&quot;</span>
                        <span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">oneCylinder</span><span class="p">(</span>
                        <span class="n">name</span><span class="p">,</span>
                        <span class="n">cent1T</span><span class="p">,</span>
                        <span class="n">cent2T</span><span class="p">,</span>
                        <span class="n">parent</span><span class="o">=</span><span class="n">parent</span><span class="p">,</span>
                        <span class="n">instance</span><span class="o">=</span><span class="n">histoVol</span><span class="o">.</span><span class="n">afviewer</span><span class="o">.</span><span class="n">becyl</span><span class="p">,</span>
                        <span class="n">radius</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">radii</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                    <span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">r</span><span class="p">:</span>
                    <span class="n">listePtCurve</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">jtrans</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">listePtCurve</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">jtrans</span><span class="p">)</span>
                <span class="c1"># if success:</span>
                <span class="c1">#            for jtrans,rotMatj in self.results:</span>
                <span class="c1"># every two we update distance from the previous</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># jtrans, rotMatj = self.results[-1]</span>
                    <span class="c1">#                    print &quot;trasnfor&quot;,jtrans,rotMatj</span>
                    <span class="c1"># cent1T=self.transformPoints(jtrans, rotMatj, self.positions[-1])</span>
                    <span class="n">insidePoints</span> <span class="o">=</span> <span class="p">{}</span>
                    <span class="n">newDistPoints</span> <span class="o">=</span> <span class="p">{}</span>
                    <span class="c1">#                    rotMatj=[[ 1.,  0.,  0.,  0.],</span>
                    <span class="c1">#                       [ 0.,  1.,  0.,  0.],</span>
                    <span class="c1">#                       [ 0.,  0.,  1.,  0.],</span>
                    <span class="c1">#                       [ 0.,  0.,  0.,  1.]]</span>
                    <span class="c1">#                    jtrans = [0.,0.,0.]</span>
                    <span class="c1">#                    #move it or generate it inplace</span>
                    <span class="c1">#                    oldpos1=self.positions</span>
                    <span class="c1">#                    oldpos2=self.positions2</span>
                    <span class="c1">#                    if len(cent1T) == 1 :</span>
                    <span class="c1">#                        cent1T=cent1T[0]</span>
                    <span class="c1">#                    if len(cent2T) == 1 :</span>
                    <span class="c1">#                        cent2T=cent2T[0]</span>
                    <span class="c1">#                    self.positions=[[cent1T],]</span>
                    <span class="c1">#                    self.positions2=[[cent2T],]</span>
                    <span class="c1"># rbnode = histoVol.callFunction(histoVol.addRB,(self, numpy.array(jtrans), numpy.array(rotMatj),),{&quot;rtype&quot;:self.type},)#cylinder</span>
                    <span class="c1"># histoVol.callFunction(histoVol.moveRBnode,(rbnode, jtrans, rotMatj,))</span>
                    <span class="n">insidePoints</span><span class="p">,</span> <span class="n">newDistPoints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getInsidePoints</span><span class="p">(</span>
                        <span class="n">histoVol</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span>
                        <span class="n">gridPointsCoords</span><span class="p">,</span>
                        <span class="n">dpad</span><span class="p">,</span>
                        <span class="n">distance</span><span class="p">,</span>
                        <span class="n">centT</span><span class="o">=</span><span class="n">cent1T</span><span class="p">,</span>
                        <span class="n">jtrans</span><span class="o">=</span><span class="n">jtrans</span><span class="p">,</span>
                        <span class="n">rotMatj</span><span class="o">=</span><span class="n">rotMatj</span><span class="p">,</span>
                    <span class="p">)</span>

                    <span class="n">nbFreePoints</span> <span class="o">=</span> <span class="n">BaseGrid</span><span class="o">.</span><span class="n">updateDistances</span><span class="p">(</span>
                        <span class="n">insidePoints</span><span class="p">,</span>
                        <span class="n">newDistPoints</span><span class="p">,</span>
                        <span class="n">free_points</span><span class="p">,</span>
                        <span class="n">nbFreePoints</span><span class="p">,</span>
                        <span class="n">distance</span><span class="p">,</span>
                    <span class="p">)</span>

                <span class="k">if</span> <span class="n">histoVol</span><span class="o">.</span><span class="n">afviewer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">histoVol</span><span class="o">.</span><span class="n">afviewer</span><span class="p">,</span> <span class="s2">&quot;vi&quot;</span><span class="p">):</span>
                    <span class="n">histoVol</span><span class="o">.</span><span class="n">afviewer</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">progressBar</span><span class="p">(</span>
                        <span class="n">progress</span><span class="o">=</span><span class="nb">int</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">currentLength</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span><span class="p">),</span>
                        <span class="n">label</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span>
                        <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">currentLength</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">)</span>
                        <span class="o">+</span> <span class="s2">&quot; &quot;</span>
                        <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbCurve</span><span class="p">)</span>
                        <span class="o">+</span> <span class="s2">&quot;/&quot;</span>
                        <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left_to_place</span><span class="p">),</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">autopack</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">progressBar</span><span class="p">(</span>
                        <span class="n">progress</span><span class="o">=</span><span class="nb">int</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">currentLength</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span><span class="p">),</span>
                        <span class="n">label</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span>
                        <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">currentLength</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">)</span>
                        <span class="o">+</span> <span class="s2">&quot; &quot;</span>
                        <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbCurve</span><span class="p">)</span>
                        <span class="o">+</span> <span class="s2">&quot;/&quot;</span>
                        <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left_to_place</span><span class="p">),</span>
                    <span class="p">)</span>

                    <span class="c1"># Start Graham on 5/16/12 This progress bar doesn&#39;t work properly... compare with my version in HistoVol</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">currentLength</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">:</span>
                    <span class="n">Done</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">counter</span> <span class="o">=</span> <span class="n">counter</span> <span class="o">+</span> <span class="mi">1</span>

                <span class="n">previousPoint</span> <span class="o">=</span> <span class="n">startingPoint</span>
                <span class="n">startingPoint</span> <span class="o">=</span> <span class="n">secondPoint</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">secondPoint</span> <span class="o">=</span> <span class="n">startingPoint</span>
                <span class="k">break</span>
        <span class="k">return</span> <span class="n">success</span><span class="p">,</span> <span class="n">nbFreePoints</span><span class="p">,</span> <span class="n">free_points</span></div>

<div class="viewcode-block" id="GrowIngredient.updateGrid"><a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.grow.GrowIngredient.updateGrid">[docs]</a>    <span class="k">def</span> <span class="nf">updateGrid</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">rg</span><span class="p">,</span>
        <span class="n">histoVol</span><span class="p">,</span>
        <span class="n">dpad</span><span class="p">,</span>
        <span class="n">free_points</span><span class="p">,</span>
        <span class="n">nbFreePoints</span><span class="p">,</span>
        <span class="n">distance</span><span class="p">,</span>
        <span class="n">gridPointsCoords</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">insidePoints</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">newDistPoints</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rg</span><span class="p">):</span>  <span class="c1"># len(self.results)):</span>
            <span class="n">jtrans</span><span class="p">,</span> <span class="n">rotMatj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="o">-</span><span class="n">i</span><span class="p">]</span>
            <span class="n">cent1T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformPoints</span><span class="p">(</span><span class="n">jtrans</span><span class="p">,</span> <span class="n">rotMatj</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">new_inside_pts</span><span class="p">,</span> <span class="n">new_dist_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getInsidePoints</span><span class="p">(</span>
                <span class="n">histoVol</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span>
                <span class="n">gridPointsCoords</span><span class="p">,</span>
                <span class="n">dpad</span><span class="p">,</span>
                <span class="n">distance</span><span class="p">,</span>
                <span class="n">centT</span><span class="o">=</span><span class="n">cent1T</span><span class="p">,</span>
                <span class="n">jtrans</span><span class="o">=</span><span class="n">jtrans</span><span class="p">,</span>
                <span class="n">rotMatj</span><span class="o">=</span><span class="n">rotMatj</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">insidePoints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">merge_place_results</span><span class="p">(</span><span class="n">new_inside_pts</span><span class="p">,</span> <span class="n">insidePoints</span><span class="p">)</span>
            <span class="n">newDistPoints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">merge_place_results</span><span class="p">(</span><span class="n">new_dist_points</span><span class="p">,</span> <span class="n">newDistPoints</span><span class="p">)</span>
            <span class="c1"># update free points</span>
            <span class="n">nbFreePoints</span> <span class="o">=</span> <span class="n">BaseGrid</span><span class="o">.</span><span class="n">updateDistances</span><span class="p">(</span>
                <span class="n">new_inside_pts</span><span class="p">,</span> <span class="n">new_dist_points</span><span class="p">,</span> <span class="n">free_points</span><span class="p">,</span> <span class="n">nbFreePoints</span><span class="p">,</span> <span class="n">distance</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">insidePoints</span><span class="p">,</span> <span class="n">newDistPoints</span><span class="p">,</span> <span class="n">nbFreePoints</span><span class="p">,</span> <span class="n">free_points</span></div>

<div class="viewcode-block" id="GrowIngredient.getFirstPoint"><a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.grow.GrowIngredient.getFirstPoint">[docs]</a>    <span class="k">def</span> <span class="nf">getFirstPoint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ptInd</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">compNum</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># surfacegrowing: first point is aling to the normal:</span>
            <span class="n">v2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">compartments</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">compNum</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">surfacePointsNormals</span><span class="p">[</span>
                <span class="n">ptInd</span>
            <span class="p">]</span>
            <span class="n">secondPoint</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">startingpoint</span><span class="p">)</span> <span class="o">+</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v2</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">uLength</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># randomize the orientation in the hemisphere following the direction.</span>
            <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">rotate_about_axis</span><span class="p">(</span>
                <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">orientation</span><span class="p">),</span>
                <span class="n">random</span><span class="p">()</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">marge</span><span class="p">),</span>  <span class="c1"># or marge ?</span>
                <span class="c1"># axis=list(self.orientation).index(0),</span>
                <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>  <span class="c1"># TODO: revert to original implementation for 3D packing</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vector</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">uLength</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_jitter</span>
            <span class="p">)</span>  <span class="c1"># = (1,0,0)self.vector.flatten()</span>
            <span class="n">secondPoint</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">startingpoint</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">vector</span>
            <span class="c1"># seed=&quot;F&quot;</span>
            <span class="k">if</span> <span class="n">seed</span><span class="p">:</span>
                <span class="n">seed</span> <span class="o">=</span> <span class="s2">&quot;R&quot;</span>
                <span class="n">secondPoint</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">startingpoint</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">vector</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">seed</span> <span class="o">=</span> <span class="s2">&quot;F&quot;</span>
            <span class="n">inside</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">checkPointInside</span><span class="p">(</span>
                <span class="n">secondPoint</span><span class="p">,</span> <span class="n">dist</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cutoff_boundary</span><span class="p">,</span> <span class="n">jitter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_jitter</span>
            <span class="p">)</span>
            <span class="n">closeS</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">inside</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">compNum</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># only if not surface ingredient</span>
                <span class="n">closeS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">far_enough_from_surfaces</span><span class="p">(</span>
                    <span class="n">secondPoint</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cutoff_surface</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">inside</span> <span class="ow">or</span> <span class="n">closeS</span><span class="p">:</span>
                <span class="n">safety</span> <span class="o">=</span> <span class="mi">30</span>
                <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">while</span> <span class="ow">not</span> <span class="n">inside</span> <span class="ow">or</span> <span class="n">closeS</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="n">safety</span><span class="p">:</span>
                        <span class="c1"># print(&quot;cant find first inside point&quot;, inside, closeS)</span>
                        <span class="k">return</span> <span class="kc">None</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">advance_randpoint_onsphere</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">uLength</span><span class="p">,</span> <span class="n">marge</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">marge</span><span class="p">),</span> <span class="n">vector</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">vector</span>
                    <span class="p">)</span>
                    <span class="n">pt</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_jitter</span><span class="p">)</span>
                    <span class="n">secondPoint</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">startingpoint</span> <span class="o">+</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>
                    <span class="n">inside</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">checkPointInside</span><span class="p">(</span>
                        <span class="n">secondPoint</span><span class="p">,</span> <span class="n">dist</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cutoff_boundary</span><span class="p">,</span> <span class="n">jitter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_jitter</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">compNum</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">closeS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">far_enough_from_surfaces</span><span class="p">(</span>
                            <span class="n">secondPoint</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cutoff_surface</span>
                        <span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">runTimeDisplay</span><span class="p">:</span>
                <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">afviewer</span><span class="o">.</span><span class="n">orgaToMasterGeom</span><span class="p">[</span><span class="bp">self</span><span class="p">]</span>
                <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;Startsp&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="n">seed</span>
                <span class="c1"># sp=self.vi.Sphere(name,radius=self.radii[0][0],parent=parent)[0]</span>
                <span class="k">if</span> <span class="n">seed</span> <span class="o">==</span> <span class="s2">&quot;F&quot;</span><span class="p">:</span>
                    <span class="c1"># sp=self.vi.newInstance(name,self.env.afviewer.pesph,</span>
                    <span class="c1">#                   location=self.startingpoint,parent=parent)</span>
                    <span class="c1"># self.vi.scaleObj(sp,self.radii[0][0])</span>
                    <span class="n">sp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">radii</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">parent</span><span class="o">=</span><span class="n">parent</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">setTranslation</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">startingpoint</span><span class="p">)</span>
                    <span class="c1">#            sp.SetAbsPos(self.vi.FromVec(startingPoint))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">oneCylinder</span><span class="p">(</span>
                    <span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;cyl&quot;</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">startingpoint</span><span class="p">,</span>
                    <span class="n">secondPoint</span><span class="p">,</span>
                    <span class="n">instance</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">afviewer</span><span class="o">.</span><span class="n">becyl</span><span class="p">,</span>
                    <span class="n">parent</span><span class="o">=</span><span class="n">parent</span><span class="p">,</span>
                    <span class="n">radius</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">radii</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">secondPoint</span></div>

<div class="viewcode-block" id="GrowIngredient.add_rb_multi_sphere"><a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.grow.GrowIngredient.add_rb_multi_sphere">[docs]</a>    <span class="k">def</span> <span class="nf">add_rb_multi_sphere</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">inodenp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">worldNP</span><span class="o">.</span><span class="n">attachNewNode</span><span class="p">(</span><span class="n">BulletRigidBodyNode</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
        <span class="n">inodenp</span><span class="o">.</span><span class="n">node</span><span class="p">()</span><span class="o">.</span><span class="n">setMass</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>
        <span class="n">level</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deepest_level</span>
        <span class="n">centers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="n">level</span><span class="p">]</span>
        <span class="n">radii</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">radii</span><span class="p">[</span><span class="n">level</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">radc</span><span class="p">,</span> <span class="n">posc</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">radii</span><span class="p">,</span> <span class="n">centers</span><span class="p">):</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="n">BulletSphereShape</span><span class="p">(</span><span class="n">radc</span><span class="p">)</span>
            <span class="n">inodenp</span><span class="o">.</span><span class="n">node</span><span class="p">()</span><span class="o">.</span><span class="n">addShape</span><span class="p">(</span>
                <span class="n">shape</span><span class="p">,</span> <span class="n">TransformState</span><span class="o">.</span><span class="n">makePos</span><span class="p">(</span><span class="n">Point3</span><span class="p">(</span><span class="n">posc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">posc</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">posc</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
            <span class="p">)</span>  <span class="c1">#</span>
        <span class="k">return</span> <span class="n">inodenp</span></div>

<div class="viewcode-block" id="GrowIngredient.grow_place"><a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.grow.GrowIngredient.grow_place">[docs]</a>    <span class="k">def</span> <span class="nf">grow_place</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">env</span><span class="p">,</span>
        <span class="n">ptInd</span><span class="p">,</span>
        <span class="n">free_points</span><span class="p">,</span>
        <span class="n">nbFreePoints</span><span class="p">,</span>
        <span class="n">distance</span><span class="p">,</span>
        <span class="n">dpad</span><span class="p">,</span>
        <span class="n">usePP</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">compMask</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compMask</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">compMask</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">prepare_alternates</span><span class="p">()</span>
        <span class="n">success</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vi</span> <span class="o">=</span> <span class="n">autopack</span><span class="o">.</span><span class="n">helper</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">env</span> <span class="o">=</span> <span class="n">env</span>
        <span class="n">gridPointsCoords</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">masterGridPositions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">runTimeDisplay</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">runTimeDisplay</span>
        <span class="n">normal</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># jitter the first point</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">compNum</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">normal</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">compartments</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">compNum</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">surfacePointsNormals</span><span class="p">[</span><span class="n">ptInd</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">startingpoint</span> <span class="o">=</span> <span class="n">previousPoint</span> <span class="o">=</span> <span class="n">startingPoint</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">jitterPosition</span><span class="p">(</span>
            <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">masterGridPositions</span><span class="p">[</span><span class="n">ptInd</span><span class="p">]),</span>
            <span class="n">env</span><span class="o">.</span><span class="n">smallestProteinSize</span><span class="p">,</span>
            <span class="n">normal</span><span class="o">=</span><span class="n">normal</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">v</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">measure_distance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">positions2</span><span class="p">,</span> <span class="n">vec</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vector</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">orientation</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">uLength</span>

        <span class="c1"># if u != self.uLength:</span>
        <span class="c1">#     self.positions2 = [[self.vector]]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">compNum</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">compartment</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">compartment</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">compartments</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">compNum</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compartment</span> <span class="o">=</span> <span class="n">compartment</span>

        <span class="n">secondPoint</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getFirstPoint</span><span class="p">(</span><span class="n">ptInd</span><span class="p">)</span>

        <span class="c1"># check collision ?</span>
        <span class="c1"># if we have starting position available use it</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbCurve</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">start_positions</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">startingpoint</span> <span class="o">=</span> <span class="n">previousPoint</span> <span class="o">=</span> <span class="n">startingPoint</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_positions</span><span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nbCurve</span>
            <span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">secondPoint</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_positions</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nbCurve</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">secondPoint</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">success</span><span class="p">,</span> <span class="n">nbFreePoints</span>

        <span class="c1"># reflect points back in-plane (useful for 2D packing)</span>
        <span class="n">previousPoint</span> <span class="o">=</span> <span class="n">get_reflected_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">previousPoint</span><span class="p">)</span>
        <span class="n">startingPoint</span> <span class="o">=</span> <span class="n">get_reflected_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">startingPoint</span><span class="p">)</span>
        <span class="n">secondPoint</span> <span class="o">=</span> <span class="n">get_reflected_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">secondPoint</span><span class="p">)</span>

        <span class="n">rotMatj</span><span class="p">,</span> <span class="n">jtrans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getJtransRot</span><span class="p">(</span><span class="n">startingPoint</span><span class="p">,</span> <span class="n">secondPoint</span><span class="p">)</span>
        <span class="c1"># test for collision</span>
        <span class="c1"># return success, nbFreePoints</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">jtrans</span><span class="p">,</span> <span class="n">rotMatj</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">place_method</span> <span class="o">==</span> <span class="s2">&quot;pandaBullet&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">nb_ingredient</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">rTrans</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">startingPoint</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">rRot</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">4</span><span class="p">)))</span>  <span class="c1"># rotMatj</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">rIngr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">[[</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">startingPoint</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">secondPoint</span><span class="p">],</span> <span class="n">rotMatj</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="p">)</span>

        <span class="c1"># rebuild kdtree</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">rTrans</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">close_ingr_bhtree</span> <span class="o">=</span> <span class="n">spatial</span><span class="o">.</span><span class="n">cKDTree</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">rTrans</span><span class="p">,</span> <span class="n">leafsize</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">currentLength</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="c1">#        self.Ptis=[ptInd,histoVol.grid.getPointFrom3D(secondPoint)]</span>
        <span class="n">dist</span><span class="p">,</span> <span class="n">pid</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">getClosestGridPoint</span><span class="p">(</span><span class="n">secondPoint</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Ptis</span> <span class="o">=</span> <span class="p">[</span><span class="n">ptInd</span><span class="p">,</span> <span class="n">pid</span><span class="p">]</span>
        <span class="n">listePtCurve</span> <span class="o">=</span> <span class="p">[</span><span class="n">jtrans</span><span class="p">]</span>
        <span class="n">listePtLinear</span> <span class="o">=</span> <span class="p">[</span><span class="n">startingPoint</span><span class="p">,</span> <span class="n">secondPoint</span><span class="p">]</span>
        <span class="c1"># grow until reach self.currentLength &gt;= self.length</span>
        <span class="c1"># or attempt &gt; safety</span>
        <span class="n">success</span><span class="p">,</span> <span class="n">nbFreePoints</span><span class="p">,</span> <span class="n">free_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grow</span><span class="p">(</span>
            <span class="n">previousPoint</span><span class="p">,</span>
            <span class="n">startingPoint</span><span class="p">,</span>
            <span class="n">secondPoint</span><span class="p">,</span>
            <span class="n">listePtCurve</span><span class="p">,</span>
            <span class="n">listePtLinear</span><span class="p">,</span>
            <span class="n">env</span><span class="p">,</span>
            <span class="n">ptInd</span><span class="p">,</span>
            <span class="n">free_points</span><span class="p">,</span>
            <span class="n">nbFreePoints</span><span class="p">,</span>
            <span class="n">distance</span><span class="p">,</span>
            <span class="n">dpad</span><span class="p">,</span>
            <span class="n">stepByStep</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">usePP</span><span class="o">=</span><span class="n">usePP</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">insidePoints</span><span class="p">,</span> <span class="n">newDistPoints</span><span class="p">,</span> <span class="n">nbFreePoints</span><span class="p">,</span> <span class="n">free_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">updateGrid</span><span class="p">(</span>
            <span class="mi">2</span><span class="p">,</span>
            <span class="n">env</span><span class="p">,</span>
            <span class="n">dpad</span><span class="p">,</span>
            <span class="n">free_points</span><span class="p">,</span>
            <span class="n">nbFreePoints</span><span class="p">,</span>
            <span class="n">distance</span><span class="p">,</span>
            <span class="n">gridPointsCoords</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">seedOnMinus</span><span class="p">:</span>
            <span class="n">success</span><span class="p">,</span> <span class="n">nbFreePoints</span><span class="p">,</span> <span class="n">free_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grow</span><span class="p">(</span>
                <span class="n">previousPoint</span><span class="p">,</span>
                <span class="n">listePtLinear</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                <span class="n">listePtLinear</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="n">listePtCurve</span><span class="p">,</span>
                <span class="n">listePtLinear</span><span class="p">,</span>
                <span class="n">env</span><span class="p">,</span>
                <span class="n">ptInd</span><span class="p">,</span>
                <span class="n">free_points</span><span class="p">,</span>
                <span class="n">nbFreePoints</span><span class="p">,</span>
                <span class="n">distance</span><span class="p">,</span>
                <span class="n">dpad</span><span class="p">,</span>
                <span class="n">stepByStep</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">r</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">insidePoints</span><span class="p">,</span> <span class="n">newDistPoints</span><span class="p">,</span> <span class="n">nbFreePoints</span><span class="p">,</span> <span class="n">free_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">updateGrid</span><span class="p">(</span>
                <span class="mi">2</span><span class="p">,</span>
                <span class="n">env</span><span class="p">,</span>
                <span class="n">dpad</span><span class="p">,</span>
                <span class="n">free_points</span><span class="p">,</span>
                <span class="n">nbFreePoints</span><span class="p">,</span>
                <span class="n">distance</span><span class="p">,</span>
                <span class="n">gridPointsCoords</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="c1"># store result in molecule</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;res </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">)):</span>
            <span class="n">jtrans</span><span class="p">,</span> <span class="n">rotMatj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="o">-</span><span class="n">i</span><span class="p">]</span>
            <span class="n">dist</span><span class="p">,</span> <span class="n">ptInd</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">getClosestGridPoint</span><span class="p">(</span><span class="n">jtrans</span><span class="p">)</span>
            <span class="n">compartment</span><span class="o">.</span><span class="n">molecules</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">jtrans</span><span class="p">,</span> <span class="n">rotMatj</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">ptInd</span><span class="p">])</span>
            <span class="c1"># reset the result ?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1">#        print (&quot;After :&quot;,listePtLinear)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">listePtCurve</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">listePtCurve</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">listePtLinear</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">listePtLinear</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nbCurve</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">completion</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbCurve</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left_to_place</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;completion </span><span class="si">%r</span><span class="s2"> </span><span class="si">%r</span><span class="s2"> </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">completion</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbCurve</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">left_to_place</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">success</span><span class="p">,</span> <span class="n">jtrans</span><span class="p">,</span> <span class="n">rotMatj</span><span class="p">,</span> <span class="n">insidePoints</span><span class="p">,</span> <span class="n">newDistPoints</span></div>

<div class="viewcode-block" id="GrowIngredient.prepare_alternates"><a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.grow.GrowIngredient.prepare_alternates">[docs]</a>    <span class="k">def</span> <span class="nf">prepare_alternates</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">partners</span><span class="o">.</span><span class="n">all_partners</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">alternates_names</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">partners</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="p">)</span>  <span class="c1"># self.partners_name#[p.name for p in self.partners.values()]</span>
            <span class="c1"># self.alternates_weight = [self.partners[name].weight for name in self.partners]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">alternates_weight</span> <span class="o">=</span> <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">partners</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">ingr</span><span class="o">.</span><span class="n">weight</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">partners</span>
            <span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">alternates_proba</span> <span class="o">=</span> <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">partners</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">ingr</span><span class="o">.</span><span class="n">proba_binding</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">partners</span>
            <span class="p">]</span></div>

<div class="viewcode-block" id="GrowIngredient.prepare_alternates_proba"><a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.grow.GrowIngredient.prepare_alternates_proba">[docs]</a>    <span class="k">def</span> <span class="nf">prepare_alternates_proba</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">thw</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">tw</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alternates_proba</span>  <span class="c1"># python3?#dict.copy().keys()</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">weights</span><span class="p">):</span>
            <span class="n">tw</span> <span class="o">+=</span> <span class="n">w</span>
            <span class="n">thw</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tw</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alternates_proba</span> <span class="o">=</span> <span class="n">thw</span></div>

<div class="viewcode-block" id="GrowIngredient.pick_random_alternate"><a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.grow.GrowIngredient.pick_random_alternate">[docs]</a>    <span class="k">def</span> <span class="nf">pick_random_alternate</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alternates_names</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">0</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
        <span class="n">ar</span> <span class="o">=</span> <span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
        <span class="c1"># weights = self.alternates_weight[:]</span>
        <span class="n">proba</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alternates_proba</span><span class="p">[:]</span>
        <span class="n">alti</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">r</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alternates_names</span><span class="p">))))</span>  <span class="c1"># round?</span>
        <span class="k">if</span> <span class="n">ar</span> <span class="o">&lt;</span> <span class="n">proba</span><span class="p">[</span><span class="n">alti</span><span class="p">]:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">alternates_names</span><span class="p">[</span><span class="n">alti</span><span class="p">],</span> <span class="n">alti</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="GrowIngredient.pick_alternate"><a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.grow.GrowIngredient.pick_alternate">[docs]</a>    <span class="k">def</span> <span class="nf">pick_alternate</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="c1"># whats he current length ie number of point so far</span>
        <span class="c1"># whats are he number of alternate and theyre proba</span>
        <span class="c1"># pick an alternate according length and proba</span>
        <span class="c1"># liste_proba</span>
        <span class="c1"># liste_alternate</span>
        <span class="c1"># dice = uniform(0.0,1.0)</span>
        <span class="c1"># int(uniform(0.0,1.0)*len(self.sphere_points_mask))</span>
        <span class="n">alt_name</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># if it is the first two segment dont do it</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">currentLength</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">uLength</span> <span class="o">*</span> <span class="mf">2.0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">0</span>
        <span class="c1"># return self.pick_random_alternate()</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alternates_weight</span>  <span class="c1"># python3?#dict.copy().keys()</span>
        <span class="n">rnd</span> <span class="o">=</span> <span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">*</span> <span class="nb">sum</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>  <span class="c1"># * (self.currentLength / self.length)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">weights</span><span class="p">):</span>
            <span class="n">rnd</span> <span class="o">-=</span> <span class="n">w</span>
            <span class="k">if</span> <span class="n">rnd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
                <span class="c1">#                print (r,self.alternates_proba[i])</span>
                <span class="k">if</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">alternates_proba</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="n">alt_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alternates_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">break</span>
        <span class="c1"># alternates_names point to an ingredients id?</span>
        <span class="k">return</span> <span class="n">alt_name</span><span class="p">,</span> <span class="n">i</span></div>

<div class="viewcode-block" id="GrowIngredient.get_alternate_position"><a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.grow.GrowIngredient.get_alternate_position">[docs]</a>    <span class="k">def</span> <span class="nf">get_alternate_position</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alternate</span><span class="p">,</span> <span class="n">alti</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">pt1</span><span class="p">,</span> <span class="n">pt2</span><span class="p">):</span>
        <span class="n">length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">partners</span><span class="p">[</span><span class="n">alternate</span><span class="p">]</span><span class="o">.</span><span class="n">length</span>
        <span class="c1"># rotation that align snake orientation to current segment</span>
        <span class="n">rotMatj</span><span class="p">,</span> <span class="n">jtrans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getJtransRot_r</span><span class="p">(</span>
            <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pt1</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pt2</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">length</span><span class="o">=</span><span class="n">length</span>
        <span class="p">)</span>
        <span class="c1"># jtrans is the position between pt1 and pt2</span>
        <span class="n">prevMat</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rotMatj</span><span class="p">)</span>
        <span class="c1"># jtrans=autopack.helper.ApplyMatrix([jtrans],prevMat.transpose())[0]</span>
        <span class="n">prevMat</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pt1</span><span class="p">)</span>  <span class="c1"># jtrans</span>
        <span class="n">rotMatj</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
        <span class="c1"># oldv is v we can ether align to v or newv</span>
        <span class="n">newv</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pt2</span><span class="p">)</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pt1</span><span class="p">)</span>
        <span class="c1"># use v ? for additional point ?</span>
        <span class="n">ptb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">partners</span><span class="p">[</span><span class="n">alternate</span><span class="p">]</span><span class="o">.</span><span class="n">get_point</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">ptc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">partners</span><span class="p">[</span><span class="n">alternate</span><span class="p">]</span><span class="o">.</span><span class="n">get_point</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">toalign</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ptc</span><span class="p">)</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ptb</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rotVectToVect</span><span class="p">(</span><span class="n">toalign</span><span class="p">,</span> <span class="n">newv</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
        <span class="n">m</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pt1</span><span class="p">)</span>  <span class="c1"># jtrans</span>
        <span class="n">pts</span> <span class="o">=</span> <span class="n">autopack</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">ApplyMatrix</span><span class="p">([</span><span class="n">ptb</span><span class="p">],</span> <span class="n">m</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>  <span class="c1"># transpose ?</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pt1</span><span class="p">)</span> <span class="o">-</span> <span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">m</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pt1</span><span class="p">)</span> <span class="o">+</span> <span class="n">v</span>  <span class="c1"># - (newpt1-pts[0])</span>

        <span class="c1"># rotMatj,jt=self.getJtransRot_r(numpy.array(ptb).flatten(),</span>
        <span class="c1">#                                   numpy.array(ptc).flatten(),</span>
        <span class="c1">#                                   length = length)</span>
        <span class="c1"># rotMatj[3,:3] = -numpy.array(ptb)</span>
        <span class="c1"># globalM1 = numpy.array(matrix(rotMatj)*matrix(prevMat))</span>
        <span class="c1">#</span>
        <span class="c1"># offset = numpy.array(ptb)+toalign/2.0</span>
        <span class="c1"># npts=numpy.array([pta,ptb,offset,ptc])-numpy.array([ptb])</span>
        <span class="c1"># pts=autopack.helper.ApplyMatrix(npts,globalM1.transpose())#transpose ?</span>
        <span class="c1"># trans = numpy.array(jtrans)-1.5*pts[1]-pts[2]</span>
        <span class="c1"># now apply matrix and get the offset</span>
        <span class="c1"># prevMat = numpy.array(globalM1)</span>
        <span class="c1"># jtrans=autopack.helper.ApplyMatrix([jtrans],prevMat.transpose())[0]</span>
        <span class="c1"># prevMat[3,:3] = jtrans</span>
        <span class="c1"># npt2=autopack.helper.ApplyMatrix([ptb],prevMat.transpose())[0]</span>
        <span class="c1"># offset = numpy.array(npt2) -numpy.array(pt1)</span>
        <span class="c1"># jtrans=numpy.array(jtrans)-offset</span>
        <span class="c1"># toalign = numpy.array(ptb) -numpy.array(pta)</span>
        <span class="c1"># globalM2 = numpy.array(rotVectToVect(toalign,v))</span>
        <span class="c1"># compare to superimposition_matrix</span>
        <span class="c1"># print globalM1,quaternion_from_matrix(globalM1).tolist()</span>
        <span class="c1"># print globalM2,quaternion_from_matrix(globalM2).tolist()</span>
        <span class="c1"># center them</span>
        <span class="c1"># c1=autopack.helper.getCenter([ptb,ptc])</span>
        <span class="c1"># c2=autopack.helper.getCenter([pt1,pt2])</span>
        <span class="c1"># globalM = superimposition_matrix(numpy.array([ptb,ptc])-c1,numpy.array([pt1,pt2])-c2)</span>
        <span class="c1"># print globalM,quaternion_from_matrix(globalM).tolist()</span>
        <span class="n">rotMatj</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
        <span class="n">rotMatj</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
        <span class="n">jtrans</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span>
        <span class="c1"># print (&quot;will try to place alterate at &quot;,jtrans)</span>
        <span class="k">return</span> <span class="n">jtrans</span><span class="p">,</span> <span class="n">rotMatj</span></div>

<div class="viewcode-block" id="GrowIngredient.get_alternate_position_p"><a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.grow.GrowIngredient.get_alternate_position_p">[docs]</a>    <span class="k">def</span> <span class="nf">get_alternate_position_p</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alternate</span><span class="p">,</span> <span class="n">alti</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">pt1</span><span class="p">,</span> <span class="n">pt2</span><span class="p">):</span>
        <span class="n">length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">partners</span><span class="p">[</span><span class="n">alternate</span><span class="p">]</span><span class="o">.</span><span class="n">length</span>
        <span class="n">rotMatj</span><span class="p">,</span> <span class="n">jtrans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getJtransRot_r</span><span class="p">(</span>
            <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pt1</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pt2</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">length</span><span class="o">=</span><span class="n">length</span>
        <span class="p">)</span>
        <span class="n">prevMat</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rotMatj</span><span class="p">)</span>
        <span class="c1"># jtrans=autopack.helper.ApplyMatrix([jtrans],prevMat.transpose())[0]</span>
        <span class="n">prevMat</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">jtrans</span>
        <span class="n">rotMatj</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>

        <span class="n">localMR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">partners_position</span><span class="p">[</span><span class="n">alti</span><span class="p">]</span>
        <span class="c1"># instead use rotVectToVect from current -&gt; to local -&gt;</span>
        <span class="c1"># align  p2-&gt;p3 vector to pt1-&gt;pt2</span>
        <span class="n">globalM</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">matrix</span><span class="p">(</span><span class="n">localMR</span><span class="p">)</span> <span class="o">*</span> <span class="n">matrix</span><span class="p">(</span><span class="n">prevMat</span><span class="p">))</span>
        <span class="n">jtrans</span> <span class="o">=</span> <span class="n">globalM</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">rotMatj</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">globalM</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span>
        <span class="c1"># print (&quot;will try to place alterate at &quot;,jtrans)</span>
        <span class="k">return</span> <span class="n">jtrans</span><span class="p">,</span> <span class="n">rotMatj</span></div>

<div class="viewcode-block" id="GrowIngredient.getV3"><a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.grow.GrowIngredient.getV3">[docs]</a>    <span class="k">def</span> <span class="nf">getV3</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pt1</span><span class="p">,</span> <span class="n">pt2</span><span class="p">,</span> <span class="n">alternate</span><span class="p">):</span>
        <span class="n">length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">partners</span><span class="p">[</span><span class="n">alternate</span><span class="p">]</span><span class="o">.</span><span class="n">length</span>
        <span class="n">rotMatj</span><span class="p">,</span> <span class="n">jtrans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getJtransRot_r</span><span class="p">(</span>
            <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pt1</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pt2</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">length</span><span class="o">=</span><span class="n">length</span>
        <span class="p">)</span>
        <span class="c1"># jtrans is the position between pt1 and pt2</span>
        <span class="n">prevMat</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rotMatj</span><span class="p">)</span>
        <span class="n">prevMat</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pt1</span><span class="p">)</span>  <span class="c1"># jtrans</span>
        <span class="n">newv</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pt2</span><span class="p">)</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pt1</span><span class="p">)</span>
        <span class="n">ptb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">partners</span><span class="p">[</span><span class="n">alternate</span><span class="p">]</span><span class="o">.</span><span class="n">get_point</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">ptc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">partners</span><span class="p">[</span><span class="n">alternate</span><span class="p">]</span><span class="o">.</span><span class="n">get_point</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">ptd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">partners</span><span class="p">[</span><span class="n">alternate</span><span class="p">]</span><span class="o">.</span><span class="n">get_point</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">toalign</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ptc</span><span class="p">)</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ptb</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rotVectToVect</span><span class="p">(</span><span class="n">toalign</span><span class="p">,</span> <span class="n">newv</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
        <span class="n">m</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pt1</span><span class="p">)</span>  <span class="c1"># jtrans</span>
        <span class="n">pts</span> <span class="o">=</span> <span class="n">autopack</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">ApplyMatrix</span><span class="p">([</span><span class="n">ptb</span><span class="p">],</span> <span class="n">m</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>  <span class="c1"># transpose ?</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pt1</span><span class="p">)</span> <span class="o">-</span> <span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">m</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pt1</span><span class="p">)</span> <span class="o">+</span> <span class="n">v</span>
        <span class="n">newPts</span> <span class="o">=</span> <span class="n">autopack</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">ApplyMatrix</span><span class="p">([</span><span class="n">ptc</span><span class="p">,</span> <span class="n">ptd</span><span class="p">],</span> <span class="n">m</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>  <span class="c1"># transpose ?</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">newPts</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">newPts</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span></div>

<div class="viewcode-block" id="GrowIngredient.place_alternate"><a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.grow.GrowIngredient.place_alternate">[docs]</a>    <span class="k">def</span> <span class="nf">place_alternate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alternate</span><span class="p">,</span> <span class="n">alti</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">pt1</span><span class="p">,</span> <span class="n">pt2</span><span class="p">):</span>
        <span class="n">pta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">partners</span><span class="p">[</span><span class="n">alternate</span><span class="p">]</span><span class="o">.</span><span class="n">get_point</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">ptb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">partners</span><span class="p">[</span><span class="n">alternate</span><span class="p">]</span><span class="o">.</span><span class="n">get_point</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">ptc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">partners</span><span class="p">[</span><span class="n">alternate</span><span class="p">]</span><span class="o">.</span><span class="n">get_point</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">ptd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">partners</span><span class="p">[</span><span class="n">alternate</span><span class="p">]</span><span class="o">.</span><span class="n">get_point</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">prevMat</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ptb</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">rotMatj</span><span class="p">,</span> <span class="n">jtrans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getJtransRot_r</span><span class="p">(</span>
                <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pt1</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pt2</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
            <span class="p">)</span>
            <span class="n">toalign</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ptb</span><span class="p">)</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pta</span><span class="p">)</span>
            <span class="n">newv</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pt2</span><span class="p">)</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pt1</span><span class="p">)</span>
            <span class="n">prevMat</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rotVectToVect</span><span class="p">(</span><span class="n">toalign</span><span class="p">,</span> <span class="n">newv</span><span class="p">))</span>
            <span class="n">newPts</span> <span class="o">=</span> <span class="n">autopack</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">ApplyMatrix</span><span class="p">(</span>
                <span class="p">[</span><span class="n">ptc</span><span class="p">,</span> <span class="n">ptd</span><span class="p">],</span> <span class="n">prevMat</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
            <span class="p">)</span>  <span class="c1"># partner positions ?</span>
            <span class="n">prevMat</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">jtrans</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">newPt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pickHalton</span><span class="p">(</span><span class="n">pt1</span><span class="p">,</span> <span class="n">pt2</span><span class="p">)</span>
            <span class="n">newPts</span> <span class="o">=</span> <span class="p">[</span><span class="n">newPt</span><span class="p">]</span>
            <span class="n">rotMatj</span><span class="p">,</span> <span class="n">jtrans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getJtransRot_r</span><span class="p">(</span>
                <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pt2</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">newPt</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
            <span class="p">)</span>
            <span class="n">prevMat</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rotMatj</span><span class="p">)</span>
            <span class="c1"># jtrans=autopack.helper.ApplyMatrix([jtrans],prevMat.transpose())[0]</span>
            <span class="n">prevMat</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">jtrans</span>
        <span class="n">rotMatj</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">newPts</span><span class="p">,</span> <span class="n">jtrans</span><span class="p">,</span> <span class="n">rotMatj</span></div>

<div class="viewcode-block" id="GrowIngredient.place_alternate_p"><a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.grow.GrowIngredient.place_alternate_p">[docs]</a>    <span class="k">def</span> <span class="nf">place_alternate_p</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alternate</span><span class="p">,</span> <span class="n">alti</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">pt1</span><span class="p">,</span> <span class="n">pt2</span><span class="p">):</span>
        <span class="c1"># previou transformation</span>
        <span class="c1">#        distance,mat = autopack.helper.getTubePropertiesMatrix(pt1,pt2)</span>
        <span class="c1">#        prevMat = numpy.array(mat)</span>
        <span class="c1"># rotMatj,jtrans=self.getJtransRot(numpy.array(pt2).flatten(),numpy.array(pt1).flatten())</span>
        <span class="c1"># should apply first to get the new list of point, and length</span>
        <span class="n">p_alternate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">partners</span><span class="p">[</span>
            <span class="n">alternate</span>
        <span class="p">]</span>  <span class="c1"># self.env.getIngrFromNameInRecipe(alternate,self.recipe )</span>
        <span class="n">out1</span> <span class="o">=</span> <span class="n">p_alternate</span><span class="o">.</span><span class="n">get_point</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">out2</span> <span class="o">=</span> <span class="n">p_alternate</span><span class="o">.</span><span class="n">get_point</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">out1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">rotMatj</span><span class="p">,</span> <span class="n">jtrans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getJtransRot_r</span><span class="p">(</span>
                <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pt1</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pt2</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
            <span class="p">)</span>
            <span class="n">prevMat</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rotMatj</span><span class="p">)</span>
            <span class="c1"># jtrans=autopack.helper.ApplyMatrix([jtrans],prevMat.transpose())[0]</span>
            <span class="n">prevMat</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">jtrans</span>
            <span class="n">newPts</span> <span class="o">=</span> <span class="n">autopack</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">ApplyMatrix</span><span class="p">(</span>
                <span class="p">[</span><span class="n">out1</span><span class="p">,</span> <span class="n">out2</span><span class="p">],</span> <span class="n">prevMat</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
            <span class="p">)</span>  <span class="c1"># partner positions ?</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">newPt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pickHalton</span><span class="p">(</span><span class="n">pt1</span><span class="p">,</span> <span class="n">pt2</span><span class="p">)</span>
            <span class="n">newPts</span> <span class="o">=</span> <span class="p">[</span><span class="n">newPt</span><span class="p">]</span>
            <span class="n">rotMatj</span><span class="p">,</span> <span class="n">jtrans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getJtransRot_r</span><span class="p">(</span>
                <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pt2</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">newPt</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
            <span class="p">)</span>
            <span class="n">prevMat</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rotMatj</span><span class="p">)</span>
            <span class="c1"># jtrans=autopack.helper.ApplyMatrix([jtrans],prevMat.transpose())[0]</span>
            <span class="n">prevMat</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">jtrans</span>
        <span class="n">rotMatj</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
        <span class="c1"># print (&quot;som math&quot;,out1,out2,newPts)</span>
        <span class="c1"># need also to get the alternate_ingredint new position and add it.</span>
        <span class="n">localMR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">partners_position</span><span class="p">[</span><span class="n">alti</span><span class="p">]</span>
        <span class="n">globalM</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">matrix</span><span class="p">(</span><span class="n">localMR</span><span class="p">)</span> <span class="o">*</span> <span class="n">matrix</span><span class="p">(</span><span class="n">prevMat</span><span class="p">))</span>
        <span class="n">jtrans</span> <span class="o">=</span> <span class="n">globalM</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">rotMatj</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">globalM</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span>
        <span class="c1">#        print (&quot;will try to place alterate at &quot;,jtrans)</span>
        <span class="k">return</span> <span class="n">newPts</span><span class="p">,</span> <span class="n">jtrans</span><span class="p">,</span> <span class="n">rotMatj</span></div></div>
        <span class="c1"># we need to add this guy a new mol and tak in account his molarity ?</span>
        <span class="c1"># should actually the partner system and the step/step</span>


<div class="viewcode-block" id="ActinIngredient"><a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.grow.ActinIngredient">[docs]</a><span class="k">class</span> <span class="nc">ActinIngredient</span><span class="p">(</span><span class="n">GrowIngredient</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">molarity</span><span class="p">,</span>
        <span class="n">radii</span><span class="o">=</span><span class="p">[[</span><span class="mf">50.0</span><span class="p">]],</span>
        <span class="n">positions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">positions2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">priority</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">pdb</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">color</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">jitter_attempts</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
        <span class="n">max_jitter</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
        <span class="n">perturb_axis_amplitude</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
        <span class="n">length</span><span class="o">=</span><span class="mf">10.0</span><span class="p">,</span>
        <span class="n">closed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">modelType</span><span class="o">=</span><span class="s2">&quot;Cylinders&quot;</span><span class="p">,</span>
        <span class="n">biased</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;Actine&quot;</span><span class="p">,</span>
        <span class="n">principal_vector</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
        <span class="n">meshFile</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">packing</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">place_method</span><span class="o">=</span><span class="s2">&quot;jitter&quot;</span><span class="p">,</span>
        <span class="n">marge</span><span class="o">=</span><span class="mf">35.0</span><span class="p">,</span>
        <span class="n">influenceRad</span><span class="o">=</span><span class="mf">100.0</span><span class="p">,</span>
        <span class="n">meshObject</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">orientation</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
        <span class="n">count</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kw</span>
    <span class="p">):</span>
        <span class="n">GrowIngredient</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">molarity</span><span class="p">,</span>
            <span class="n">radii</span><span class="p">,</span>
            <span class="n">positions</span><span class="p">,</span>
            <span class="n">positions2</span><span class="p">,</span>
            <span class="n">priority</span><span class="p">,</span>
            <span class="n">name</span><span class="p">,</span>
            <span class="n">pdb</span><span class="p">,</span>
            <span class="n">color</span><span class="p">,</span>
            <span class="n">jitter_attempts</span><span class="p">,</span>
            <span class="n">max_jitter</span><span class="p">,</span>
            <span class="n">perturb_axis_amplitude</span><span class="p">,</span>
            <span class="n">length</span><span class="p">,</span>
            <span class="n">closed</span><span class="p">,</span>
            <span class="n">modelType</span><span class="p">,</span>
            <span class="n">biased</span><span class="p">,</span>
            <span class="n">principal_vector</span><span class="p">,</span>
            <span class="n">meshFile</span><span class="p">,</span>
            <span class="n">packing</span><span class="p">,</span>
            <span class="n">place_method</span><span class="p">,</span>
            <span class="n">marge</span><span class="p">,</span>
            <span class="n">meshObject</span><span class="p">,</span>
            <span class="n">orientation</span><span class="p">,</span>
            <span class="n">count</span><span class="p">,</span>
            <span class="nb">type</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kw</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;Actine_</span><span class="si">%s</span><span class="s2">_</span><span class="si">%f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">radii</span><span class="p">),</span> <span class="n">molarity</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_attractor</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">constraintMarge</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seedOnMinus</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">influenceRad</span> <span class="o">=</span> <span class="n">influenceRad</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">oneSuperTurn</span> <span class="o">=</span> <span class="mf">825.545</span>  <span class="c1"># cm from c4d graham file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">oneDimerSize</span> <span class="o">=</span> <span class="mf">100.0</span>  <span class="c1"># 200 =2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cutoff_surface</span> <span class="o">=</span> <span class="mf">50.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cutoff_boundary</span> <span class="o">=</span> <span class="mf">1.0</span>

<div class="viewcode-block" id="ActinIngredient.updateFromBB"><a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.grow.ActinIngredient.updateFromBB">[docs]</a>    <span class="k">def</span> <span class="nf">updateFromBB</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">):</span>
        <span class="k">return</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">getRadius</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">positions</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">positions2</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">principal_vector</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">uLength</span> <span class="o">=</span> <span class="n">r</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">r</span></div></div>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">cellPack 1.0.3 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../../cellpack.html" >cellpack</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="../../autopack.html" >cellpack.autopack</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">cellpack.autopack.ingredient.grow</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2021, Megan Riel-Mehan.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.0.1.
    </div>
  </body>
</html>