<!DOCTYPE html>

<html lang="en" data-content_root="../../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>cellpack.autopack.ingredient.Ingredient &#8212; cellPack 1.0.7 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/classic.css?v=514cf933" />
    
    <script src="../../../../_static/documentation_options.js?v=46dfa7f5"></script>
    <script src="../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">cellPack 1.0.7 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../../cellpack.html" >cellpack</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="../../autopack.html" accesskey="U">cellpack.autopack</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">cellpack.autopack.ingredient.Ingredient</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for cellpack.autopack.ingredient.Ingredient</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1">############################################################################</span>
<span class="c1">#</span>
<span class="c1"># autoPACK Authors: Graham T. Johnson, Mostafa Al-Alusi, Ludovic Autin,</span>
<span class="c1">#   and Michel Sanner</span>
<span class="c1">#   Based on COFFEE Script developed by Graham Johnson</span>
<span class="c1">#    between 2005 and 2010</span>
<span class="c1">#   with assistance from Mostafa Al-Alusi in 2009 and periodic input</span>
<span class="c1">#   from Arthur Olson&#39;s Molecular Graphics Lab</span>
<span class="c1">#</span>
<span class="c1"># Ingredient.py Authors: Graham Johnson &amp; Michel Sanner with</span>
<span class="c1">#  editing/enhancement from Ludovic Autin</span>
<span class="c1">#</span>
<span class="c1"># Translation to Python initiated March 1, 2010 by Michel Sanner</span>
<span class="c1">#  with Graham Johnson</span>
<span class="c1">#</span>
<span class="c1"># Class restructuring and organization: Michel Sanner</span>
<span class="c1">#</span>
<span class="c1"># Copyright: Graham Johnson Â©2010</span>
<span class="c1">#</span>
<span class="c1"># This file &quot;Ingredient.py&quot; is part of autoPACK, cellPACK.</span>
<span class="c1">#</span>
<span class="c1">#    autoPACK is free software: you can redistribute it and/or modify</span>
<span class="c1">#    it under the terms of the GNU General Public License as published by</span>
<span class="c1">#    the Free Software Foundation, either version 3 of the License, or</span>
<span class="c1">#    (at your option) any later version.</span>
<span class="c1">#</span>
<span class="c1">#    autoPACK is distributed in the hope that it will be useful,</span>
<span class="c1">#    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c1">#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c1">#    GNU General Public License for more details.</span>
<span class="c1">#</span>
<span class="c1">#    You should have received a copy of the GNU General Public License</span>
<span class="c1">#    along with autoPACK (See &quot;CopyingGNUGPL&quot; in the installation.</span>
<span class="c1">#    If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="c1">#</span>
<span class="c1">############################################################################</span>
<span class="c1"># @author: Graham Johnson, Ludovic Autin, &amp; Michel Sanner</span>


<span class="c1"># Hybrid version merged from Graham&#39;s Sept 2011 and Ludo&#39;s April 2012</span>
<span class="c1"># version on May 16, 2012</span>
<span class="c1"># Updated with Correct Sept 25, 2011 thesis version on July 5, 2012</span>

<span class="c1"># TODO: Describe Ingredient class here at high level</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">spatial</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">collada</span>
<span class="kn">from</span> <span class="nn">scipy.spatial.transform</span> <span class="kn">import</span> <span class="n">Rotation</span> <span class="k">as</span> <span class="n">R</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">pi</span>
<span class="kn">from</span> <span class="nn">random</span> <span class="kn">import</span> <span class="n">uniform</span><span class="p">,</span> <span class="n">gauss</span><span class="p">,</span> <span class="n">random</span>
<span class="kn">from</span> <span class="nn">time</span> <span class="kn">import</span> <span class="n">time</span>
<span class="kn">import</span> <span class="nn">math</span>

<span class="kn">from</span> <span class="nn">cellpack.autopack.interface_objects.ingredient_types</span> <span class="kn">import</span> <span class="n">INGREDIENT_TYPE</span>
<span class="kn">from</span> <span class="nn">cellpack.autopack.interface_objects.packed_objects</span> <span class="kn">import</span> <span class="n">PackedObject</span>
<span class="kn">from</span> <span class="nn">cellpack.autopack.utils</span> <span class="kn">import</span> <span class="n">get_distance</span><span class="p">,</span> <span class="n">get_value_from_distribution</span>

<span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">ApplyMatrix</span><span class="p">,</span>
    <span class="n">getNormedVectorOnes</span><span class="p">,</span>
    <span class="n">rotVectToVect</span><span class="p">,</span>
    <span class="n">rotax</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">from</span> <span class="nn">cellpack.autopack.upy.simularium.simularium_helper</span> <span class="kn">import</span> <span class="n">simulariumHelper</span>
<span class="kn">import</span> <span class="nn">cellpack.autopack</span> <span class="k">as</span> <span class="nn">autopack</span>
<span class="kn">from</span> <span class="nn">cellpack.autopack.ingredient.agent</span> <span class="kn">import</span> <span class="n">Agent</span>
<span class="kn">from</span> <span class="nn">cellpack.autopack.interface_objects.meta_enum</span> <span class="kn">import</span> <span class="n">MetaEnum</span>

<span class="n">helper</span> <span class="o">=</span> <span class="n">autopack</span><span class="o">.</span><span class="n">helper</span>
<span class="n">reporthook</span> <span class="o">=</span> <span class="kc">None</span>
<span class="k">if</span> <span class="n">helper</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">reporthook</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="n">reporthook</span>


<div class="viewcode-block" id="DistributionTypes">
<a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.Ingredient.DistributionTypes">[docs]</a>
<span class="k">class</span> <span class="nc">DistributionTypes</span><span class="p">(</span><span class="n">MetaEnum</span><span class="p">):</span>
    <span class="c1"># All available distribution types</span>
    <span class="n">UNIFORM</span> <span class="o">=</span> <span class="s2">&quot;uniform&quot;</span>
    <span class="n">NORMAL</span> <span class="o">=</span> <span class="s2">&quot;normal&quot;</span>
    <span class="n">LIST</span> <span class="o">=</span> <span class="s2">&quot;list&quot;</span></div>



<div class="viewcode-block" id="DistributionOptions">
<a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.Ingredient.DistributionOptions">[docs]</a>
<span class="k">class</span> <span class="nc">DistributionOptions</span><span class="p">(</span><span class="n">MetaEnum</span><span class="p">):</span>
    <span class="c1"># All available distribution options</span>
    <span class="n">MIN</span> <span class="o">=</span> <span class="s2">&quot;min&quot;</span>
    <span class="n">MAX</span> <span class="o">=</span> <span class="s2">&quot;max&quot;</span>
    <span class="n">MEAN</span> <span class="o">=</span> <span class="s2">&quot;mean&quot;</span>
    <span class="n">STD</span> <span class="o">=</span> <span class="s2">&quot;std&quot;</span>
    <span class="n">LIST_VALUES</span> <span class="o">=</span> <span class="s2">&quot;list_values&quot;</span></div>



<span class="n">REQUIRED_DISTRIBUTION_OPTIONS</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">DistributionTypes</span><span class="o">.</span><span class="n">UNIFORM</span><span class="p">:</span> <span class="p">[</span><span class="n">DistributionOptions</span><span class="o">.</span><span class="n">MIN</span><span class="p">,</span> <span class="n">DistributionOptions</span><span class="o">.</span><span class="n">MAX</span><span class="p">],</span>
    <span class="n">DistributionTypes</span><span class="o">.</span><span class="n">NORMAL</span><span class="p">:</span> <span class="p">[</span><span class="n">DistributionOptions</span><span class="o">.</span><span class="n">MEAN</span><span class="p">,</span> <span class="n">DistributionOptions</span><span class="o">.</span><span class="n">STD</span><span class="p">],</span>
    <span class="n">DistributionTypes</span><span class="o">.</span><span class="n">LIST</span><span class="p">:</span> <span class="p">[</span><span class="n">DistributionOptions</span><span class="o">.</span><span class="n">LIST_VALUES</span><span class="p">],</span>
<span class="p">}</span>


<div class="viewcode-block" id="IngredientInstanceDrop">
<a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.Ingredient.IngredientInstanceDrop">[docs]</a>
<span class="k">class</span> <span class="nc">IngredientInstanceDrop</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ptId</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">rotation</span><span class="p">,</span> <span class="n">ingredient</span><span class="p">,</span> <span class="n">rb</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ptId</span> <span class="o">=</span> <span class="n">ptId</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">position</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rotation</span> <span class="o">=</span> <span class="n">rotation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ingredient</span> <span class="o">=</span> <span class="n">ingredient</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rigid_body</span> <span class="o">=</span> <span class="n">rb</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">ingredient</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">ptId</span><span class="p">)</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">position</span>
        <span class="n">rad</span> <span class="o">=</span> <span class="n">ingredient</span><span class="o">.</span><span class="n">encapsulating_radius</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bb</span> <span class="o">=</span> <span class="p">([</span><span class="n">x</span> <span class="o">-</span> <span class="n">rad</span><span class="p">,</span> <span class="n">y</span> <span class="o">-</span> <span class="n">rad</span><span class="p">,</span> <span class="n">z</span> <span class="o">-</span> <span class="n">rad</span><span class="p">],</span> <span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="n">rad</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="n">rad</span><span class="p">,</span> <span class="n">z</span> <span class="o">+</span> <span class="n">rad</span><span class="p">])</span>
        <span class="c1"># maybe get bb from mesh if any ?</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ingredient</span><span class="o">.</span><span class="n">mesh</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bb</span> <span class="o">=</span> <span class="n">autopack</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">getBoundingBox</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ingredient</span><span class="o">.</span><span class="n">mesh</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bb</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bb</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bb</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bb</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="n">i</span><span class="p">]</span></div>



<span class="c1"># the ingredient should derive from a class of Agent</span>
<div class="viewcode-block" id="Ingredient">
<a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.Ingredient.Ingredient">[docs]</a>
<span class="k">class</span> <span class="nc">Ingredient</span><span class="p">(</span><span class="n">Agent</span><span class="p">):</span>
    <span class="n">static_id</span> <span class="o">=</span> <span class="mi">0</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for Ingredients that can be added to a Recipe.</span>
<span class="sd">    Ingredients provide:</span>
<span class="sd">        - a molarity used to compute how many to place</span>
<span class="sd">        - a generic density value</span>
<span class="sd">        - a unit associated with the density value</span>
<span class="sd">        - a jitter amplitude vector specifying by how much the jittering</span>
<span class="sd">        algorithm can move from the grid position.</span>
<span class="sd">        - a number of jitter attempts</span>
<span class="sd">        - an optional color used to draw the ingredient default (white)</span>
<span class="sd">        - an optional name</span>
<span class="sd">        - an optional pdb ID</span>
<span class="sd">        - an optional packing priority. If omitted the priority will be based</span>
<span class="sd">        on the radius with larger radii first</span>
<span class="sd">        ham here: (-)priority object will pack from high to low one at a time</span>
<span class="sd">        (+)priority will be weighted by assigned priority value</span>
<span class="sd">        (0)packignPriority will be weighted by complexity and appended to what is left</span>
<span class="sd">        of the (+) values</span>
<span class="sd">        - an optional principal vector used to align the ingredient</span>
<span class="sd">        - recipe will be a weakref to the Recipe this Ingredient belongs to</span>
<span class="sd">        - compartment_id is the compartment number (0 for cytoplasm, positive for compartment</span>
<span class="sd">        surface and negative compartment interior</span>
<span class="sd">        - Attributes used by the filling algorithm:</span>
<span class="sd">        - count counts the number of placed ingredients during a fill</span>
<span class="sd">        - counter is the target number of ingredients to place</span>
<span class="sd">        - completion is the ratio of placed/target</span>
<span class="sd">        - rejectionCounter is used to eliminate ingredients after too many failed</span>
<span class="sd">        attempts</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">ARGUMENTS</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;color&quot;</span><span class="p">,</span>
        <span class="s2">&quot;count&quot;</span><span class="p">,</span>
        <span class="s2">&quot;count_options&quot;</span><span class="p">,</span>
        <span class="s2">&quot;cutoff_boundary&quot;</span><span class="p">,</span>
        <span class="s2">&quot;cutoff_surface&quot;</span><span class="p">,</span>
        <span class="s2">&quot;distance_expression&quot;</span><span class="p">,</span>
        <span class="s2">&quot;distance_function&quot;</span><span class="p">,</span>
        <span class="s2">&quot;force_random&quot;</span><span class="p">,</span>
        <span class="s2">&quot;gradient&quot;</span><span class="p">,</span>
        <span class="s2">&quot;is_attractor&quot;</span><span class="p">,</span>
        <span class="s2">&quot;max_jitter&quot;</span><span class="p">,</span>
        <span class="s2">&quot;molarity&quot;</span><span class="p">,</span>
        <span class="s2">&quot;name&quot;</span><span class="p">,</span>
        <span class="s2">&quot;jitter_attempts&quot;</span><span class="p">,</span>
        <span class="s2">&quot;offset&quot;</span><span class="p">,</span>
        <span class="s2">&quot;orient_bias_range&quot;</span><span class="p">,</span>
        <span class="s2">&quot;overwrite_distance_function&quot;</span><span class="p">,</span>
        <span class="s2">&quot;packing_mode&quot;</span><span class="p">,</span>
        <span class="s2">&quot;priority&quot;</span><span class="p">,</span>
        <span class="s2">&quot;partners&quot;</span><span class="p">,</span>
        <span class="s2">&quot;perturb_axis_amplitude&quot;</span><span class="p">,</span>
        <span class="s2">&quot;place_method&quot;</span><span class="p">,</span>
        <span class="s2">&quot;principal_vector&quot;</span><span class="p">,</span>
        <span class="s2">&quot;rejection_threshold&quot;</span><span class="p">,</span>
        <span class="s2">&quot;representations&quot;</span><span class="p">,</span>
        <span class="s2">&quot;resolution_dictionary&quot;</span><span class="p">,</span>
        <span class="s2">&quot;rotation_axis&quot;</span><span class="p">,</span>
        <span class="s2">&quot;rotation_range&quot;</span><span class="p">,</span>
        <span class="s2">&quot;size_options&quot;</span><span class="p">,</span>
        <span class="s2">&quot;type&quot;</span><span class="p">,</span>
        <span class="s2">&quot;use_orient_bias&quot;</span><span class="p">,</span>
        <span class="s2">&quot;use_rotation_axis&quot;</span><span class="p">,</span>
        <span class="s2">&quot;weight&quot;</span><span class="p">,</span>
    <span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;single_sphere&quot;</span><span class="p">,</span>
        <span class="n">color</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">count</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">count_options</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">cutoff_boundary</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">cutoff_surface</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
        <span class="n">distance_expression</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">distance_function</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">force_random</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>  <span class="c1"># avoid any binding</span>
        <span class="n">gradient</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">is_attractor</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">max_jitter</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
        <span class="n">molarity</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
        <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">jitter_attempts</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
        <span class="n">object_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">offset</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
        <span class="n">orient_bias_range</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="n">pi</span><span class="p">,</span> <span class="n">pi</span><span class="p">],</span>
        <span class="n">overwrite_distance_function</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>  <span class="c1"># overWrite</span>
        <span class="n">packing_mode</span><span class="o">=</span><span class="s2">&quot;random&quot;</span><span class="p">,</span>
        <span class="n">priority</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">partners</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">perturb_axis_amplitude</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
        <span class="n">place_method</span><span class="o">=</span><span class="s2">&quot;jitter&quot;</span><span class="p">,</span>
        <span class="n">principal_vector</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
        <span class="n">rejection_threshold</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span>
        <span class="n">representations</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">resolution_dictionary</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">rotation_axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">rotation_range</span><span class="o">=</span><span class="mf">6.2831</span><span class="p">,</span>
        <span class="n">size_options</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">use_orient_bias</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">use_rotation_axis</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">weight</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">name</span><span class="p">,</span>
            <span class="n">molarity</span><span class="p">,</span>
            <span class="n">distance_expression</span><span class="o">=</span><span class="n">distance_expression</span><span class="p">,</span>
            <span class="n">distance_function</span><span class="o">=</span><span class="n">distance_function</span><span class="p">,</span>
            <span class="n">force_random</span><span class="o">=</span><span class="n">force_random</span><span class="p">,</span>
            <span class="n">gradient</span><span class="o">=</span><span class="n">gradient</span><span class="p">,</span>
            <span class="n">is_attractor</span><span class="o">=</span><span class="n">is_attractor</span><span class="p">,</span>
            <span class="n">overwrite_distance_function</span><span class="o">=</span><span class="n">overwrite_distance_function</span><span class="p">,</span>
            <span class="n">packing_mode</span><span class="o">=</span><span class="n">packing_mode</span><span class="p">,</span>
            <span class="n">partners</span><span class="o">=</span><span class="n">partners</span><span class="p">,</span>
            <span class="n">place_method</span><span class="o">=</span><span class="n">place_method</span><span class="p">,</span>
            <span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s2">&quot;ingredient&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">propagate</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">molarity</span> <span class="o">=</span> <span class="n">molarity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="n">count</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count_options</span> <span class="o">=</span> <span class="n">count_options</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size_options</span> <span class="o">=</span> <span class="n">size_options</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">priority</span> <span class="o">=</span> <span class="n">priority</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;priority </span><span class="si">%d</span><span class="s2">,  self.priority </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="n">priority</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">priority</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">molarity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;CREATE INGREDIENT </span><span class="si">%s</span><span class="s2"> </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="n">rejection_threshold</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">composition_name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">object_name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">object_name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">representations</span> <span class="o">=</span> <span class="n">representations</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">color</span>  <span class="c1"># color used for sphere display</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">color</span> <span class="o">==</span> <span class="s2">&quot;None&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model_type</span> <span class="o">=</span> <span class="s2">&quot;Spheres&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rRot</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tTrans</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">htrans</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">moving</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">moving_geom</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rb_nodes</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># store rbnode. no more than X ?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bullet_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>  <span class="c1"># try only store 2, and move them when needd</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">limit_nb_nodes</span> <span class="o">=</span> <span class="mi">50</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vi</span> <span class="o">=</span> <span class="n">autopack</span><span class="o">.</span><span class="n">helper</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_radius</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_distance</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deepest_level</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_previous</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">faces</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vnormals</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># self._place = self.place</span>
        <span class="n">children</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="n">children</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rbnode</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># keep the rbnode if any</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">collisionLevel</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># self.deepest_level</span>
        <span class="c1"># first level used for collision detection</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_jitter</span> <span class="o">=</span> <span class="n">max_jitter</span>
        <span class="c1"># (1,1,1) means 1/2 grid spacing in all directions</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">perturb_axis_amplitude</span> <span class="o">=</span> <span class="n">perturb_axis_amplitude</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">principal_vector</span> <span class="o">=</span> <span class="n">principal_vector</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">recipe</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># will be set when added to a recipe</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compartment_id</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compId_accepted</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">[]</span>
        <span class="p">)</span>  <span class="c1"># if this list is defined, point picked outise the list are rejected</span>

        <span class="c1"># added to a compartment</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left_to_place</span> <span class="o">=</span> <span class="n">count</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vol_nbmol</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Packing tracking values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">jitter_attempts</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">jitter_attempts</span>  <span class="c1"># number of jitter attempts for translation</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nbPts</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">allIngrPts</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">[]</span>
        <span class="p">)</span>  <span class="c1"># the list of available grid points for this ingredient to pack</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># target number of molecules for a fill</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">completion</span> <span class="o">=</span> <span class="mf">0.0</span>  <span class="c1"># ratio of counter/count</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rejectionCounter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verts</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rad</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rapid_model</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># TODO : geometry : 3d object or procedural from PDB</span>
        <span class="c1"># TODO : usekeyword resolution-&gt;options dictionary of res :</span>
        <span class="c1"># TODO : {&quot;simple&quot;:{&quot;cms&quot;:{&quot;parameters&quot;:{&quot;gridres&quot;:12}},</span>
        <span class="c1"># TODO :            &quot;obj&quot;:{&quot;parameters&quot;:{&quot;name&quot;:&quot;&quot;,&quot;filename&quot;:&quot;&quot;}}</span>
        <span class="c1"># TODO :            }</span>
        <span class="c1"># TODO : &quot;med&quot;:{&quot;method&quot;:&quot;cms&quot;,&quot;parameters&quot;:{&quot;gridres&quot;:30}}</span>
        <span class="c1"># TODO : &quot;high&quot;:{&quot;method&quot;:&quot;msms&quot;,&quot;parameters&quot;:{&quot;gridres&quot;:30}}</span>
        <span class="c1"># TODO : etc...</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rejection_threshold</span> <span class="o">=</span> <span class="n">rejection_threshold</span>

        <span class="c1"># need to build the basic shape if one provided</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_resolution</span> <span class="o">=</span> <span class="s2">&quot;Low&quot;</span>  <span class="c1"># should come from data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">available_resolution</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Low&quot;</span><span class="p">,</span> <span class="s2">&quot;Med&quot;</span><span class="p">,</span> <span class="s2">&quot;High&quot;</span><span class="p">]</span>  <span class="c1"># 0,1,2</span>

        <span class="k">if</span> <span class="n">resolution_dictionary</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">resolution_dictionary</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Low&quot;</span><span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="s2">&quot;Med&quot;</span><span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="s2">&quot;High&quot;</span><span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resolution_dictionary</span> <span class="o">=</span> <span class="n">resolution_dictionary</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">use_rotation_axis</span> <span class="o">=</span> <span class="n">use_rotation_axis</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rotation_axis</span> <span class="o">=</span> <span class="n">rotation_axis</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rotation_range</span> <span class="o">=</span> <span class="n">rotation_range</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_orient_bias</span> <span class="o">=</span> <span class="n">use_orient_bias</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">orientBiasRotRangeMin</span> <span class="o">=</span> <span class="n">orient_bias_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">orientBiasRotRangeMax</span> <span class="o">=</span> <span class="n">orient_bias_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># cutoff are used for picking point far from surface and boundary</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cutoff_boundary</span> <span class="o">=</span> <span class="n">cutoff_boundary</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cutoff_surface</span> <span class="o">=</span> <span class="n">cutoff_surface</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">compareCompartment</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compareCompartmentTolerance</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compareCompartmentThreshold</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">updateOwnFreePts</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># work for rer python not ??</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">haveBeenRejected</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">distances_temp</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">centT</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># transformed position</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">unique_id</span> <span class="o">=</span> <span class="n">Ingredient</span><span class="o">.</span><span class="n">static_id</span>
        <span class="n">Ingredient</span><span class="o">.</span><span class="n">static_id</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">score</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">organism</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="c1"># add tiling property ? as any ingredient coud tile as hexagon. It is just the packing type</span>

<div class="viewcode-block" id="Ingredient.validate_distribution_options">
<a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.Ingredient.Ingredient.validate_distribution_options">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">validate_distribution_options</span><span class="p">(</span><span class="n">distribution_options</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Validates distribution options and returns validated distribution options</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;distribution&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">distribution_options</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Ingredient count options must contain a distribution&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">DistributionTypes</span><span class="o">.</span><span class="n">is_member</span><span class="p">(</span><span class="n">distribution_options</span><span class="p">[</span><span class="s2">&quot;distribution&quot;</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">distribution_options</span><span class="p">[</span><span class="s1">&#39;distribution&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> is not a valid distribution&quot;</span>
            <span class="p">)</span>
        <span class="k">for</span> <span class="n">required_option</span> <span class="ow">in</span> <span class="n">REQUIRED_DISTRIBUTION_OPTIONS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
            <span class="n">distribution_options</span><span class="p">[</span><span class="s2">&quot;distribution&quot;</span><span class="p">],</span> <span class="p">[]</span>
        <span class="p">):</span>
            <span class="k">if</span> <span class="n">required_option</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">distribution_options</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Missing option &#39;</span><span class="si">{</span><span class="n">required_option</span><span class="si">}</span><span class="s2">&#39; for </span><span class="si">{</span><span class="n">distribution_options</span><span class="p">[</span><span class="s1">&#39;distribution&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> distribution&quot;</span>
                <span class="p">)</span>
        <span class="k">return</span> <span class="n">distribution_options</span></div>


<div class="viewcode-block" id="Ingredient.validate_ingredient_info">
<a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.Ingredient.Ingredient.validate_ingredient_info">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">validate_ingredient_info</span><span class="p">(</span><span class="n">ingredient_info</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Validates ingredient info and returns validated ingredient info</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;count&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ingredient_info</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Ingredient info must contain a count&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ingredient_info</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Ingredient count must be greater than or equal to 0&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="s2">&quot;count_options&quot;</span> <span class="ow">in</span> <span class="n">ingredient_info</span><span class="p">:</span>
            <span class="n">ingredient_info</span><span class="p">[</span><span class="s2">&quot;count_options&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Ingredient</span><span class="o">.</span><span class="n">validate_distribution_options</span><span class="p">(</span>
                <span class="n">ingredient_info</span><span class="p">[</span><span class="s2">&quot;count_options&quot;</span><span class="p">]</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="s2">&quot;size_options&quot;</span> <span class="ow">in</span> <span class="n">ingredient_info</span><span class="p">:</span>
            <span class="n">ingredient_info</span><span class="p">[</span><span class="s2">&quot;size_options&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Ingredient</span><span class="o">.</span><span class="n">validate_distribution_options</span><span class="p">(</span>
                <span class="n">ingredient_info</span><span class="p">[</span><span class="s2">&quot;size_options&quot;</span><span class="p">]</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">ingredient_info</span></div>


<div class="viewcode-block" id="Ingredient.reset">
<a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.Ingredient.Ingredient.reset">[docs]</a>
    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;reset the states of an ingredient&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left_to_place</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">completion</span> <span class="o">=</span> <span class="mf">0.0</span></div>


<div class="viewcode-block" id="Ingredient.has_pdb">
<a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.Ingredient.Ingredient.has_pdb">[docs]</a>
    <span class="k">def</span> <span class="nf">has_pdb</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">representations</span><span class="o">.</span><span class="n">has_pdb</span><span class="p">()</span></div>


<div class="viewcode-block" id="Ingredient.has_mesh">
<a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.Ingredient.Ingredient.has_mesh">[docs]</a>
    <span class="k">def</span> <span class="nf">has_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">representations</span><span class="o">.</span><span class="n">has_mesh</span><span class="p">()</span></div>


<div class="viewcode-block" id="Ingredient.use_mesh">
<a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.Ingredient.Ingredient.use_mesh">[docs]</a>
    <span class="k">def</span> <span class="nf">use_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">representations</span><span class="o">.</span><span class="n">set_active</span><span class="p">(</span><span class="s2">&quot;mesh&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">representations</span><span class="o">.</span><span class="n">get_mesh_path</span><span class="p">()</span></div>


<div class="viewcode-block" id="Ingredient.use_pdb">
<a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.Ingredient.Ingredient.use_pdb">[docs]</a>
    <span class="k">def</span> <span class="nf">use_pdb</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">representations</span><span class="o">.</span><span class="n">set_active</span><span class="p">(</span><span class="s2">&quot;atomic&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">representations</span><span class="o">.</span><span class="n">get_pdb_path</span><span class="p">()</span></div>


<div class="viewcode-block" id="Ingredient.setTilling">
<a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.Ingredient.Ingredient.setTilling">[docs]</a>
    <span class="k">def</span> <span class="nf">setTilling</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">comp</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">packing_mode</span> <span class="o">==</span> <span class="s2">&quot;hexatile&quot;</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">cellpack.autopack.hexagonTile</span> <span class="kn">import</span> <span class="n">tileHexaIngredient</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">tilling</span> <span class="o">=</span> <span class="n">tileHexaIngredient</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span> <span class="n">comp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">encapsulating_radius</span><span class="p">,</span> <span class="n">init_seed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">seed_used</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">packing_mode</span> <span class="o">==</span> <span class="s2">&quot;squaretile&quot;</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">cellpack.autopack.hexagonTile</span> <span class="kn">import</span> <span class="n">tileSquareIngredient</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">tilling</span> <span class="o">=</span> <span class="n">tileSquareIngredient</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span> <span class="n">comp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">encapsulating_radius</span><span class="p">,</span> <span class="n">init_seed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">seed_used</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">packing_mode</span> <span class="o">==</span> <span class="s2">&quot;triangletile&quot;</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">cellpack.autopack.hexagonTile</span> <span class="kn">import</span> <span class="n">tileTriangleIngredient</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">tilling</span> <span class="o">=</span> <span class="n">tileTriangleIngredient</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span> <span class="n">comp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">encapsulating_radius</span><span class="p">,</span> <span class="n">init_seed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">seed_used</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="Ingredient.initialize_mesh">
<a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.Ingredient.Ingredient.initialize_mesh">[docs]</a>
    <span class="k">def</span> <span class="nf">initialize_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mesh_store</span><span class="p">):</span>
        <span class="c1"># get the collision mesh</span>
        <span class="n">mesh_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">representations</span><span class="o">.</span><span class="n">get_mesh_path</span><span class="p">()</span>
        <span class="n">meshName</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">representations</span><span class="o">.</span><span class="n">get_mesh_name</span><span class="p">()</span>
        <span class="n">meshType</span> <span class="o">=</span> <span class="s2">&quot;file&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">mesh_path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">meshType</span> <span class="o">==</span> <span class="s2">&quot;file&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getMesh</span><span class="p">(</span><span class="n">mesh_path</span><span class="p">,</span> <span class="n">meshName</span><span class="p">,</span> <span class="n">mesh_store</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;OK got </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># display a message ?</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;no geometries for ingredient &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="c1"># TODO: add back in raw option</span>
            <span class="k">elif</span> <span class="n">meshType</span> <span class="o">==</span> <span class="s2">&quot;raw&quot;</span><span class="p">:</span>
                <span class="c1"># need to build the mesh from v,f,n</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">buildMesh</span><span class="p">(</span><span class="n">mesh_store</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">getEncapsulatingRadius</span><span class="p">()</span></div>


<div class="viewcode-block" id="Ingredient.DecomposeMesh">
<a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.Ingredient.Ingredient.DecomposeMesh">[docs]</a>
    <span class="k">def</span> <span class="nf">DecomposeMesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">poly</span><span class="p">,</span> <span class="n">edit</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">tri</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">helper</span> <span class="o">=</span> <span class="n">autopack</span><span class="o">.</span><span class="n">helper</span>
        <span class="n">m</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">helper</span><span class="o">.</span><span class="n">host</span> <span class="o">==</span> <span class="s2">&quot;dejavu&quot;</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="n">getMesh</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span>
            <span class="n">tr</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="n">getMesh</span><span class="p">(</span><span class="n">helper</span><span class="o">.</span><span class="n">getName</span><span class="p">(</span><span class="n">poly</span><span class="p">))</span>
            <span class="n">tr</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Decompose Mesh ingredient </span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">helper</span><span class="o">.</span><span class="n">getName</span><span class="p">(</span><span class="n">poly</span><span class="p">),</span> <span class="n">m</span><span class="p">)</span>
        <span class="c1"># what about empty, hierarchical, should merged all the data?</span>
        <span class="n">faces</span><span class="p">,</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">vnormals</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="n">DecomposeMesh</span><span class="p">(</span>
            <span class="n">m</span><span class="p">,</span> <span class="n">edit</span><span class="o">=</span><span class="n">edit</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">tri</span><span class="o">=</span><span class="n">tri</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">tr</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">faces</span><span class="p">,</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">vnormals</span></div>


<div class="viewcode-block" id="Ingredient.getEncapsulatingRadius">
<a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.Ingredient.Ingredient.getEncapsulatingRadius">[docs]</a>
    <span class="k">def</span> <span class="nf">getEncapsulatingRadius</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">:</span>
                <span class="n">helper</span> <span class="o">=</span> <span class="n">autopack</span><span class="o">.</span><span class="n">helper</span>
                <span class="k">if</span> <span class="n">helper</span><span class="o">.</span><span class="n">host</span> <span class="o">==</span> <span class="s2">&quot;3dsmax&quot;</span><span class="p">:</span>
                    <span class="k">return</span>
                <span class="k">if</span> <span class="n">mesh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">mesh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;getEncapsulatingRadius </span><span class="si">%r</span><span class="s2"> </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="n">mesh</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">faces</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="n">vnormals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">DecomposeMesh</span><span class="p">(</span>
                    <span class="n">mesh</span><span class="p">,</span> <span class="n">edit</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">tri</span><span class="o">=</span><span class="kc">True</span>
                <span class="p">)</span>
        <span class="c1"># encapsulating radius ?</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="s2">&quot;f&quot;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">length</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
                <span class="p">(</span><span class="n">v</span> <span class="o">*</span> <span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="p">)</span>  <span class="c1"># FloatingPointError: underflow encountered in multiply</span>
            <span class="n">r</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">length</span><span class="p">))</span> <span class="o">+</span> <span class="mf">15.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s2">&quot;self.encapsulating_radius </span><span class="si">%r</span><span class="s2"> </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">encapsulating_radius</span><span class="p">,</span> <span class="n">r</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">encapsulating_radius</span> <span class="o">=</span> <span class="n">r</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">pass</span></div>


<div class="viewcode-block" id="Ingredient.getData">
<a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.Ingredient.Ingredient.getData">[docs]</a>
    <span class="k">def</span> <span class="nf">getData</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertex_normals</span></div>


<div class="viewcode-block" id="Ingredient.get_rb_model">
<a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.Ingredient.Ingredient.get_rb_model">[docs]</a>
    <span class="k">def</span> <span class="nf">get_rb_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alt</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">alt</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bullet_nodes</span><span class="p">[</span><span class="n">ret</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bullet_nodes</span><span class="p">[</span><span class="n">ret</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">addRB</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="n">numpy</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">rtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bullet_nodes</span><span class="p">[</span><span class="n">ret</span><span class="p">]</span></div>


<div class="viewcode-block" id="Ingredient.getMesh">
<a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.Ingredient.Ingredient.getMesh">[docs]</a>
    <span class="k">def</span> <span class="nf">getMesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">geomname</span><span class="p">,</span> <span class="n">mesh_store</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a mesh representation from a filename for the ingredient</span>

<span class="sd">        @type  filename: string</span>
<span class="sd">        @param filename: the name of the input file</span>
<span class="sd">        @type  geomname: string</span>
<span class="sd">        @param geomname: the name of the output geometry</span>

<span class="sd">        @rtype:   DejaVu.IndexedPolygons/HostObjec</span>
<span class="sd">        @return:  the created mesh</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># depending the extension of the filename, can be eitherdejaVu file, fbx or wavefront</span>
        <span class="c1"># no extension is DejaVu</span>
        <span class="c1"># should we try to see if it already exist in the scene</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh_store</span><span class="o">.</span><span class="n">get_object</span><span class="p">(</span><span class="n">geomname</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mesh</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;retrieve </span><span class="si">%s</span><span class="s2"> </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">geomname</span><span class="p">,</span> <span class="n">mesh</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">mesh</span>
        <span class="c1"># identify extension</span>
        <span class="n">file_name</span><span class="p">,</span> <span class="n">file_extension</span> <span class="o">=</span> <span class="n">mesh_store</span><span class="o">.</span><span class="n">get_mesh_filepath_and_extension</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">file_extension</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;.fbx&quot;</span><span class="p">:</span>
            <span class="c1"># use the host helper if any to read</span>
            <span class="k">if</span> <span class="n">helper</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># neeed the helper</span>
                <span class="n">helper</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">file_extension</span> <span class="o">==</span> <span class="s2">&quot;.dae&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;read dae withHelper&quot;</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">helper</span><span class="p">,</span> <span class="n">autopack</span><span class="o">.</span><span class="n">helper</span><span class="p">)</span>
            <span class="c1"># use the host helper if any to read</span>
            <span class="k">return</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">helper</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># need to get the mesh directly. Only possible if dae or dejavu format</span>
                <span class="c1"># get the dejavu heper but without the View, and in nogui mode</span>
                <span class="n">h</span> <span class="o">=</span> <span class="n">simulariumHelper</span><span class="p">(</span><span class="n">vi</span><span class="o">=</span><span class="s2">&quot;nogui&quot;</span><span class="p">)</span>
                <span class="n">dgeoms</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
                <span class="c1"># v,vn,f = dgeoms.values()[0][&quot;mesh&quot;]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vnormals</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">faces</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="n">combineDaeMeshData</span><span class="p">(</span>
                    <span class="n">dgeoms</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vnormals</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="p">[]</span>
                <span class="p">)</span>  <span class="c1"># helper.normal_array(self.vertices,numpy.array(self.faces))</span>
                <span class="n">geom</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">createsNmesh</span><span class="p">(</span><span class="n">geomname</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">faces</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">return</span> <span class="n">geom</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># if helper is not None:#neeed the helper</span>
                <span class="k">if</span> <span class="n">helper</span><span class="o">.</span><span class="n">host</span> <span class="o">==</span> <span class="s2">&quot;dejavu&quot;</span> <span class="ow">and</span> <span class="n">helper</span><span class="o">.</span><span class="n">nogui</span><span class="p">:</span>
                    <span class="n">dgeoms</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
                    <span class="n">v</span><span class="p">,</span> <span class="n">vn</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dgeoms</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;mesh&quot;</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;vertices nb is </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vnormals</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">faces</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">v</span><span class="p">,</span>
                        <span class="n">vn</span><span class="p">,</span>
                        <span class="n">f</span><span class="p">,</span>
                    <span class="p">)</span>  <span class="c1"># helper.combineDaeMeshData(dgeoms.values())</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">vnormals</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="p">[]</span>
                    <span class="p">)</span>  <span class="c1"># helper.normal_array(self.vertices,numpy.array(self.faces))</span>
                    <span class="n">geom</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="n">createsNmesh</span><span class="p">(</span>
                        <span class="n">geomname</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vnormals</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">faces</span>
                    <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">return</span> <span class="n">geom</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">helper</span><span class="o">.</span><span class="n">host</span> <span class="o">!=</span> <span class="s2">&quot;dejavu&quot;</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">collada</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="c1"># need to get the mesh directly. Only possible if dae or dejavu format</span>
                            <span class="c1"># get the dejavu heper but without the View, and in nogui mode</span>
                            <span class="n">h</span> <span class="o">=</span> <span class="n">simulariumHelper</span><span class="p">(</span><span class="n">vi</span><span class="o">=</span><span class="s2">&quot;nogui&quot;</span><span class="p">)</span>
                            <span class="n">dgeoms</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">read_mesh_file</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
                            <span class="c1"># should combine both</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="n">vnormals</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">faces</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">combineDaeMeshData</span><span class="p">(</span>
                                <span class="n">dgeoms</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
                            <span class="p">)</span>  <span class="c1"># dgeoms.values()[0][&quot;mesh&quot;]</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">vnormals</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="n">normal_array</span><span class="p">(</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span>
                            <span class="p">)</span>
                <span class="n">helper</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
                <span class="n">geom</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="n">getObject</span><span class="p">(</span><span class="n">geomname</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">geom</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">geom</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="n">getObject</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdb</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="c1"># rename it</span>
                    <span class="k">if</span> <span class="n">geom</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">return</span> <span class="kc">None</span>
                <span class="c1"># rotate ?</span>
                <span class="k">if</span> <span class="n">helper</span><span class="o">.</span><span class="n">host</span> <span class="o">==</span> <span class="s2">&quot;3dsmax&quot;</span><span class="p">:</span>  <span class="c1"># or helper.host.find(&quot;blender&quot;) != -1:</span>
                    <span class="n">helper</span><span class="o">.</span><span class="n">resetTransformation</span><span class="p">(</span>
                        <span class="n">geom</span>
                    <span class="p">)</span>  <span class="c1"># remove rotation and scale from importing??maybe not?</span>
                <span class="k">if</span> <span class="n">helper</span><span class="o">.</span><span class="n">host</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;blender&quot;</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">helper</span><span class="o">.</span><span class="n">resetTransformation</span><span class="p">(</span><span class="n">geom</span><span class="p">)</span>
                <span class="c1"># if self.coordsystem == &quot;left&quot; :</span>
                <span class="c1">#                        mA = helper.rotation_matrix(-math.pi/2.0,[1.0,0.0,0.0])</span>
                <span class="c1">#                        mB = helper.rotation_matrix(math.pi/2.0,[0.0,0.0,1.0])</span>
                <span class="c1">#                        m=matrix(mA)*matrix(mB)</span>
                <span class="c1">#                        helper.setObjectMatrix(geom,matrice=m)</span>
                <span class="c1">#                if helper.host != &quot;c4d&quot;  and helper.host != &quot;dejavu&quot; and self.coordsystem == &quot;left&quot; and helper.host != &quot;softimage&quot; and helper.host.find(&quot;blender&quot;) == -1:</span>
                <span class="c1"># what about softimage</span>
                <span class="c1"># need to rotate the transform that carry the shape, maya ? or not ?</span>
                <span class="c1">#                    helper.rotateObj(geom,[0.0,-math.pi/2.0,0.0])#wayfront as well euler angle</span>
                <span class="c1"># swicth the axe?</span>
                <span class="c1">#                    oldv = self.principal_vector[:]</span>
                <span class="c1">#                    self.principal_vector = [oldv[2],oldv[1],oldv[0]]</span>
                <span class="k">if</span> <span class="n">helper</span><span class="o">.</span><span class="n">host</span> <span class="o">==</span> <span class="s2">&quot;softimage&quot;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordsystem</span> <span class="o">==</span> <span class="s2">&quot;left&quot;</span><span class="p">:</span>
                    <span class="n">helper</span><span class="o">.</span><span class="n">rotateObj</span><span class="p">(</span>
                        <span class="n">geom</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="o">-</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="n">primitive</span><span class="o">=</span><span class="kc">True</span>
                    <span class="p">)</span>  <span class="c1"># need to rotate the primitive</span>
                <span class="k">if</span> <span class="n">helper</span><span class="o">.</span><span class="n">host</span> <span class="o">==</span> <span class="s2">&quot;c4d&quot;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordsystem</span> <span class="o">==</span> <span class="s2">&quot;right&quot;</span><span class="p">:</span>
                    <span class="n">helper</span><span class="o">.</span><span class="n">resetTransformation</span><span class="p">(</span><span class="n">geom</span><span class="p">)</span>
                    <span class="n">helper</span><span class="o">.</span><span class="n">rotateObj</span><span class="p">(</span>
                        <span class="n">geom</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">],</span> <span class="n">primitive</span><span class="o">=</span><span class="kc">True</span>
                    <span class="p">)</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="n">getObject</span><span class="p">(</span><span class="s2">&quot;autopackHider&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">p</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="n">newEmpty</span><span class="p">(</span><span class="s2">&quot;autopackHider&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">helper</span><span class="o">.</span><span class="n">host</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;blender&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">helper</span><span class="o">.</span><span class="n">toggleDisplay</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
                <span class="n">helper</span><span class="o">.</span><span class="n">reParent</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">geom</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># host specific file</span>
            <span class="k">if</span> <span class="n">helper</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># neeed the helper</span>
                <span class="n">helper</span><span class="o">.</span><span class="n">read</span><span class="p">(</span>
                    <span class="n">filename</span>
                <span class="p">)</span>  <span class="c1"># doesnt get the regular file ? conver state to object</span>
                <span class="n">geom</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="n">getObject</span><span class="p">(</span><span class="n">geomname</span><span class="p">)</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="n">getObject</span><span class="p">(</span><span class="s2">&quot;autopackHider&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">p</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="n">newEmpty</span><span class="p">(</span><span class="s2">&quot;autopackHider&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">helper</span><span class="o">.</span><span class="n">host</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;blender&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">helper</span><span class="o">.</span><span class="n">toggleDisplay</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
                <span class="n">helper</span><span class="o">.</span><span class="n">reParent</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">geom</span>
            <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="Ingredient.buildMesh">
<a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.Ingredient.Ingredient.buildMesh">[docs]</a>
    <span class="k">def</span> <span class="nf">buildMesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mesh_store</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a polygon mesh object from a dictionary verts,faces,normals</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">geom</span><span class="p">,</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">faces</span><span class="p">,</span> <span class="n">vnormals</span> <span class="o">=</span> <span class="n">mesh_store</span><span class="o">.</span><span class="n">build_mesh</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh_info</span><span class="p">[</span><span class="s2">&quot;file&quot;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh_info</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span> <span class="o">=</span> <span class="n">vertices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">faces</span> <span class="o">=</span> <span class="n">faces</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">geom</span>
        <span class="k">return</span> <span class="n">geom</span></div>


<div class="viewcode-block" id="Ingredient.jitterPosition">
<a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.Ingredient.Ingredient.jitterPosition">[docs]</a>
    <span class="k">def</span> <span class="nf">jitterPosition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">spacing</span><span class="p">,</span> <span class="n">normal</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        position are the 3d coordiantes of the grid point</span>
<span class="sd">        spacing is the grid spacing</span>
<span class="sd">        this will jitter gauss(0., 0.3) * Ingredient.max_jitter</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">compartment_id</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">vx</span><span class="p">,</span> <span class="n">vy</span><span class="p">,</span> <span class="n">vz</span> <span class="o">=</span> <span class="n">v1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">principal_vector</span>
            <span class="c1"># surfacePointsNormals problem here</span>
            <span class="n">v2</span> <span class="o">=</span> <span class="n">normal</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">rotMat</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rotVectToVect</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">),</span> <span class="s2">&quot;f&quot;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                <span class="n">rotMat</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>

        <span class="n">jx</span><span class="p">,</span> <span class="n">jy</span><span class="p">,</span> <span class="n">jz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_jitter</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">jx</span> <span class="o">*</span> <span class="n">spacing</span> <span class="o">*</span> <span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
        <span class="p">)</span>  <span class="c1"># This needs to use the same rejection if outside of the sphere that the uniform cartesian jitters have.  Shoiuld use oneJitter instead?</span>
        <span class="n">dy</span> <span class="o">=</span> <span class="n">jy</span> <span class="o">*</span> <span class="n">spacing</span> <span class="o">*</span> <span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
        <span class="n">dz</span> <span class="o">=</span> <span class="n">jz</span> <span class="o">*</span> <span class="n">spacing</span> <span class="o">*</span> <span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
        <span class="c1">#        d2 = dx*dx + dy*dy + dz*dz</span>
        <span class="c1">#        if d2 &lt; jitter2:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">compartment_id</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># jitter less among normal</span>
            <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">,</span> <span class="n">dz</span><span class="p">,</span> <span class="n">dum</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">rotMat</span><span class="p">,</span> <span class="p">(</span><span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">,</span> <span class="n">dz</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="n">position</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dx</span>
        <span class="n">position</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dy</span>
        <span class="n">position</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dz</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">position</span><span class="p">)</span></div>


<div class="viewcode-block" id="Ingredient.getMaxJitter">
<a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.Ingredient.Ingredient.getMaxJitter">[docs]</a>
    <span class="k">def</span> <span class="nf">getMaxJitter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spacing</span><span class="p">):</span>
        <span class="c1"># self.max_jitter: each value is the max it can move</span>
        <span class="c1"># along that axis, but not cocurrently, ie, can&#39;t move</span>
        <span class="c1"># in the max x AND max y direction at the same time</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_jitter</span><span class="p">)</span> <span class="o">*</span> <span class="n">spacing</span></div>


<div class="viewcode-block" id="Ingredient.swap">
<a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.Ingredient.Ingredient.swap">[docs]</a>
    <span class="k">def</span> <span class="nf">swap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="n">d</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="o">-</span><span class="n">n</span><span class="p">)</span>
        <span class="n">d</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
        <span class="n">d</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">n</span><span class="p">)</span></div>


<div class="viewcode-block" id="Ingredient.deleteblist">
<a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.Ingredient.Ingredient.deleteblist">[docs]</a>
    <span class="k">def</span> <span class="nf">deleteblist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="k">del</span> <span class="n">d</span><span class="p">[</span><span class="n">n</span><span class="p">]</span></div>


<div class="viewcode-block" id="Ingredient.get_cuttoff_value">
<a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.Ingredient.Ingredient.get_cuttoff_value">[docs]</a>
    <span class="k">def</span> <span class="nf">get_cuttoff_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spacing</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the min value a grid point needs to be away from a surfance</span>
<span class="sd">        in order for this ingredient to pack. Only needs to be calculated once</span>
<span class="sd">        per ingredient once the jitter is set.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_distance</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_distance</span>
        <span class="n">radius</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_radius</span>
        <span class="n">jitter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getMaxJitter</span><span class="p">(</span><span class="n">spacing</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">packing_mode</span> <span class="o">==</span> <span class="s2">&quot;close&quot;</span><span class="p">:</span>
            <span class="n">cut</span> <span class="o">=</span> <span class="n">radius</span> <span class="o">-</span> <span class="n">jitter</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cut</span> <span class="o">=</span> <span class="n">radius</span> <span class="o">-</span> <span class="n">jitter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_distance</span> <span class="o">=</span> <span class="n">cut</span>
        <span class="k">return</span> <span class="n">cut</span></div>


<div class="viewcode-block" id="Ingredient.checkIfUpdate">
<a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.Ingredient.Ingredient.checkIfUpdate">[docs]</a>
    <span class="k">def</span> <span class="nf">checkIfUpdate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nbFreePoints</span><span class="p">,</span> <span class="n">threshold</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if we need to update the distance array. Part of the hack free points&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;nbPts&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;firstTimeUpdate&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">firstTimeUpdate</span><span class="p">:</span>
                <span class="c1"># if it has been updated before</span>
                <span class="c1"># check the number of inside points for this ingredient over the total</span>
                <span class="c1"># number of free points left</span>
                <span class="n">ratio</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbPts</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">nbFreePoints</span><span class="p">)</span>
                <span class="c1"># threshold defaults to zero. It&#39;s set by the env, `freePtsUpdateThreshold`</span>
                <span class="k">if</span> <span class="n">ratio</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">haveBeenRejected</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">rejectionCounter</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">haveBeenRejected</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="k">return</span> <span class="kc">True</span>
                    <span class="c1"># do we check to total freepts? or crowded state ?</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">return</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">firstTimeUpdate</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="Ingredient.get_list_of_free_indices">
<a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.Ingredient.Ingredient.get_list_of_free_indices">[docs]</a>
    <span class="k">def</span> <span class="nf">get_list_of_free_indices</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">distances</span><span class="p">,</span>
        <span class="n">free_points</span><span class="p">,</span>
        <span class="n">nbFreePoints</span><span class="p">,</span>
        <span class="n">spacing</span><span class="p">,</span>
        <span class="n">comp_ids</span><span class="p">,</span>
        <span class="n">threshold</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">allIngrPts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">allIngrDist</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">current_comp_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compartment_id</span>
        <span class="c1"># gets min distance an object has to be away to allow packing for this object</span>
        <span class="n">cuttoff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cuttoff_value</span><span class="p">(</span><span class="n">spacing</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">packing_mode</span> <span class="o">==</span> <span class="s2">&quot;close&quot;</span><span class="p">:</span>
            <span class="c1"># Get an array of free points where the distance is greater than half the cuttoff value</span>
            <span class="c1"># and less than the cutoff. Ie an array where the distances are all very small.</span>
            <span class="c1"># this also masks the array to only include points in the current commpartment</span>
            <span class="n">all_distances</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">distances</span><span class="p">)[</span><span class="n">free_points</span><span class="p">]</span>
            <span class="n">distance_mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                <span class="n">numpy</span><span class="o">.</span><span class="n">less_equal</span><span class="p">(</span><span class="n">all_distances</span><span class="p">,</span> <span class="n">cuttoff</span><span class="p">),</span>
                <span class="n">numpy</span><span class="o">.</span><span class="n">greater_equal</span><span class="p">(</span><span class="n">all_distances</span><span class="p">,</span> <span class="n">cuttoff</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="c1"># mask compartments Id as well</span>
            <span class="n">compartment_mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">comp_ids</span><span class="p">)[</span><span class="n">free_points</span><span class="p">]</span> <span class="o">==</span> <span class="n">current_comp_id</span>
            <span class="n">mask_ind</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span>
                <span class="n">numpy</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">distance_mask</span><span class="p">,</span> <span class="n">compartment_mask</span><span class="p">)</span>
            <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">allIngrPts</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">free_points</span><span class="p">)[</span><span class="n">mask_ind</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">allIngrDist</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">distances</span><span class="p">)[</span><span class="n">mask_ind</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">starting_array</span> <span class="o">=</span> <span class="n">free_points</span>
            <span class="n">array_length</span> <span class="o">=</span> <span class="n">nbFreePoints</span>
            <span class="c1"># if this ingredient has a grid point array already from a previous pass, and it&#39;s shorter</span>
            <span class="c1"># than the total number of free points, start there for picking points, because it means</span>
            <span class="c1"># we&#39;ve already filtered out some points that are too close to surfaces for this ingredient to</span>
            <span class="c1"># pack and we don&#39;t want to have to filter them out again.</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">allIngrPts</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">allIngrPts</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">nbFreePoints</span><span class="p">:</span>
                <span class="n">starting_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">allIngrPts</span>
                <span class="n">array_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">allIngrPts</span><span class="p">)</span>

            <span class="c1"># use periodic update according size ratio grid</span>
            <span class="n">update</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">checkIfUpdate</span><span class="p">(</span><span class="n">nbFreePoints</span><span class="p">,</span> <span class="n">threshold</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;check if update: </span><span class="si">{</span><span class="n">update</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">update</span><span class="p">:</span>
                <span class="c1"># Only return points that aren&#39;t so close to a surface that we know the</span>
                <span class="c1"># ingredient won&#39;t fit</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">array_length</span><span class="p">):</span>
                    <span class="n">pt_index</span> <span class="o">=</span> <span class="n">starting_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="n">distances</span><span class="p">[</span><span class="n">pt_index</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">comp_ids</span><span class="p">[</span><span class="n">pt_index</span><span class="p">]</span> <span class="o">==</span> <span class="n">current_comp_id</span> <span class="ow">and</span> <span class="n">d</span> <span class="o">&gt;=</span> <span class="n">cuttoff</span><span class="p">:</span>
                        <span class="n">allIngrPts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pt_index</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">allIngrPts</span> <span class="o">=</span> <span class="n">allIngrPts</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">allIngrPts</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">allIngrPts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">allIngrPts</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">allIngrPts</span> <span class="o">=</span> <span class="n">free_points</span><span class="p">[:</span><span class="n">nbFreePoints</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">allIngrPts</span> <span class="o">=</span> <span class="n">allIngrPts</span>
        <span class="k">return</span> <span class="n">allIngrPts</span><span class="p">,</span> <span class="n">allIngrDist</span></div>


<div class="viewcode-block" id="Ingredient.perturbAxis">
<a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.Ingredient.Ingredient.perturbAxis">[docs]</a>
    <span class="k">def</span> <span class="nf">perturbAxis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">amplitude</span><span class="p">):</span>
        <span class="c1"># modify axis using gaussian distribution but clamp</span>
        <span class="c1"># at amplitutde</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">principal_vector</span>
        <span class="n">stddev</span> <span class="o">=</span> <span class="n">amplitude</span> <span class="o">*</span> <span class="mf">0.5</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="n">gauss</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">stddev</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dx</span> <span class="o">&gt;</span> <span class="n">amplitude</span><span class="p">:</span>
            <span class="n">dx</span> <span class="o">=</span> <span class="n">amplitude</span>
        <span class="k">elif</span> <span class="n">dx</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">amplitude</span><span class="p">:</span>
            <span class="n">dx</span> <span class="o">=</span> <span class="o">-</span><span class="n">amplitude</span>
        <span class="n">dy</span> <span class="o">=</span> <span class="n">gauss</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">stddev</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dy</span> <span class="o">&gt;</span> <span class="n">amplitude</span><span class="p">:</span>
            <span class="n">dy</span> <span class="o">=</span> <span class="n">amplitude</span>
        <span class="k">elif</span> <span class="n">dy</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">amplitude</span><span class="p">:</span>
            <span class="n">dy</span> <span class="o">=</span> <span class="o">-</span><span class="n">amplitude</span>
        <span class="n">dz</span> <span class="o">=</span> <span class="n">gauss</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">stddev</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dz</span> <span class="o">&gt;</span> <span class="n">amplitude</span><span class="p">:</span>
            <span class="n">dz</span> <span class="o">=</span> <span class="n">amplitude</span>
        <span class="k">elif</span> <span class="n">dz</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">amplitude</span><span class="p">:</span>
            <span class="n">dz</span> <span class="o">=</span> <span class="o">-</span><span class="n">amplitude</span>
        <span class="c1"># if self.name==&#39;2bg9 ION CHANNEL/RECEPTOR&#39;:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">dx</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="n">dy</span><span class="p">,</span> <span class="n">z</span> <span class="o">+</span> <span class="n">dz</span><span class="p">)</span></div>


<div class="viewcode-block" id="Ingredient.transformPoints">
<a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.Ingredient.Ingredient.transformPoints">[docs]</a>
    <span class="k">def</span> <span class="nf">transformPoints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">rot</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
        <span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">rot</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rot</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">points</span><span class="p">:</span>
            <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">rot</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">],</span> <span class="n">point</span><span class="p">)</span> <span class="o">+</span> <span class="n">trans</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">output</span></div>


<div class="viewcode-block" id="Ingredient.transformPoints_mult">
<a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.Ingredient.Ingredient.transformPoints_mult">[docs]</a>
    <span class="k">def</span> <span class="nf">transformPoints_mult</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">rot</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
        <span class="n">tx</span><span class="p">,</span> <span class="n">ty</span><span class="p">,</span> <span class="n">tz</span> <span class="o">=</span> <span class="n">trans</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="n">zs</span> <span class="ow">in</span> <span class="n">points</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">rot</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">xs</span> <span class="o">+</span> <span class="n">rot</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">ys</span> <span class="o">+</span> <span class="n">rot</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">zs</span> <span class="o">+</span> <span class="n">tx</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">rot</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">xs</span> <span class="o">+</span> <span class="n">rot</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">ys</span> <span class="o">+</span> <span class="n">rot</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">zs</span> <span class="o">+</span> <span class="n">ty</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">rot</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">xs</span> <span class="o">+</span> <span class="n">rot</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">ys</span> <span class="o">+</span> <span class="n">rot</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">zs</span> <span class="o">+</span> <span class="n">tz</span>
            <span class="n">pos</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span></div>


<div class="viewcode-block" id="Ingredient.apply_rotation">
<a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.Ingredient.Ingredient.apply_rotation">[docs]</a>
    <span class="k">def</span> <span class="nf">apply_rotation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rot</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]):</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_matrix</span><span class="p">([</span><span class="n">rot</span><span class="p">[</span><span class="mi">0</span><span class="p">][:</span><span class="mi">3</span><span class="p">],</span> <span class="n">rot</span><span class="p">[</span><span class="mi">1</span><span class="p">][:</span><span class="mi">3</span><span class="p">],</span> <span class="n">rot</span><span class="p">[</span><span class="mi">2</span><span class="p">][:</span><span class="mi">3</span><span class="p">]])</span>
        <span class="n">new_pos</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_pos</span> <span class="o">+</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">origin</span><span class="p">)</span></div>


<div class="viewcode-block" id="Ingredient.alignRotation">
<a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.Ingredient.Ingredient.alignRotation">[docs]</a>
    <span class="k">def</span> <span class="nf">alignRotation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">jtrans</span><span class="p">,</span> <span class="n">gradients</span><span class="p">):</span>
        <span class="c1"># for surface points we compute the rotation which</span>
        <span class="c1"># aligns the principal_vector with the surface normal</span>
        <span class="n">vx</span><span class="p">,</span> <span class="n">vy</span><span class="p">,</span> <span class="n">vz</span> <span class="o">=</span> <span class="n">v1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">principal_vector</span>
        <span class="c1"># surfacePointsNormals problem here</span>
        <span class="n">gradient_center</span> <span class="o">=</span> <span class="n">gradients</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">gradient</span><span class="p">]</span><span class="o">.</span><span class="n">direction</span>
        <span class="n">v2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">gradient_center</span><span class="p">)</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">jtrans</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">rotMat</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rotVectToVect</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">),</span> <span class="s2">&quot;f&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">rotMat</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rotMat</span></div>


<div class="viewcode-block" id="Ingredient.getAxisRotation">
<a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.Ingredient.Ingredient.getAxisRotation">[docs]</a>
    <span class="k">def</span> <span class="nf">getAxisRotation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rot</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        combines a rotation about axis to incoming rot.</span>
<span class="sd">        rot aligns the principal_vector with the surface normal</span>
<span class="sd">        rot aligns the principal_vector with the biased diretion</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">perturb_axis_amplitude</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">perturbAxis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">perturb_axis_amplitude</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">principal_vector</span>
        <span class="n">tau</span> <span class="o">=</span> <span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="n">pi</span><span class="p">,</span> <span class="n">pi</span><span class="p">)</span>
        <span class="n">rrot</span> <span class="o">=</span> <span class="n">rotax</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">axis</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">transpose</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">rot</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">rot</span><span class="p">,</span> <span class="n">rrot</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rot</span></div>


<div class="viewcode-block" id="Ingredient.getBiasedRotation">
<a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.Ingredient.Ingredient.getBiasedRotation">[docs]</a>
    <span class="k">def</span> <span class="nf">getBiasedRotation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rot</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        combines a rotation about axis to incoming rot</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># -30,+30 ?</span>
        <span class="k">if</span> <span class="n">weight</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tau</span> <span class="o">=</span> <span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="n">pi</span> <span class="o">*</span> <span class="n">weight</span><span class="p">,</span> <span class="n">pi</span> <span class="o">*</span> <span class="n">weight</span><span class="p">)</span>  <span class="c1"># (-pi, pi)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tau</span> <span class="o">=</span> <span class="n">gauss</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">orientBiasRotRangeMin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">orientBiasRotRangeMax</span>
            <span class="p">)</span>  <span class="c1"># (-pi, pi)</span>
        <span class="n">rrot</span> <span class="o">=</span> <span class="n">rotax</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotation_axis</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">transpose</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">rot</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">rot</span><span class="p">,</span> <span class="n">rrot</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rot</span></div>


<div class="viewcode-block" id="Ingredient.correctBB">
<a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.Ingredient.Ingredient.correctBB">[docs]</a>
    <span class="k">def</span> <span class="nf">correctBB</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">radc</span><span class="p">):</span>
        <span class="c1"># unprecised</span>
        <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">z1</span> <span class="o">=</span> <span class="n">p1</span>
        <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">z2</span> <span class="o">=</span> <span class="n">p2</span>
        <span class="c1">#        bb = ( [x1-radc, y1-radc, z1-radc], [x2+radc, y2+radc, z2+radc] )</span>
        <span class="n">mini</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">maxi</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="n">mini</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">p1</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">p2</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">-</span> <span class="n">radc</span><span class="p">)</span>
            <span class="n">maxi</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">p1</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">p2</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="n">radc</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mini</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">maxi</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()])</span></div>

        <span class="c1"># precised:</span>

<div class="viewcode-block" id="Ingredient.getListCompFromMask">
<a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.Ingredient.Ingredient.getListCompFromMask">[docs]</a>
    <span class="k">def</span> <span class="nf">getListCompFromMask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cId</span><span class="p">,</span> <span class="n">ptsInSphere</span><span class="p">):</span>
        <span class="c1"># cID ie [-2,-1,-2,0...], ptsinsph = [519,300,etc]</span>
        <span class="n">current</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compartment_id</span>
        <span class="k">if</span> <span class="n">current</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># inside</span>
            <span class="n">ins</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cId</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">current</span><span class="p">]</span>
            <span class="c1"># surf=[i for i,x in enumerate(cId) if x == -current]</span>
            <span class="n">liste</span> <span class="o">=</span> <span class="n">ins</span>  <span class="c1"># +surf</span>
        <span class="k">if</span> <span class="n">current</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># surface</span>
            <span class="n">ins</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cId</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">current</span><span class="p">]</span>
            <span class="n">surf</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cId</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="o">-</span><span class="n">current</span><span class="p">]</span>
            <span class="n">extra</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cId</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">liste</span> <span class="o">=</span> <span class="n">ins</span> <span class="o">+</span> <span class="n">surf</span> <span class="o">+</span> <span class="n">extra</span>
        <span class="k">elif</span> <span class="n">current</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># extracellular</span>
            <span class="n">liste</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cId</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">current</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">liste</span></div>


<div class="viewcode-block" id="Ingredient.get_new_distances_and_inside_points">
<a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.Ingredient.Ingredient.get_new_distances_and_inside_points">[docs]</a>
    <span class="k">def</span> <span class="nf">get_new_distances_and_inside_points</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">env</span><span class="p">,</span>
        <span class="n">packing_location</span><span class="p">,</span>
        <span class="n">rotation_matrix</span><span class="p">,</span>
        <span class="n">grid_point_index</span><span class="p">,</span>
        <span class="n">grid_distance_values</span><span class="p">,</span>
        <span class="n">new_dist_points</span><span class="p">,</span>
        <span class="n">inside_points</span><span class="p">,</span>
        <span class="n">signed_distance_to_surface</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="n">signed_distance_to_surface</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">grid_point_location</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">masterGridPositions</span><span class="p">[</span><span class="n">grid_point_index</span><span class="p">]</span>
            <span class="n">signed_distance_to_surface</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_signed_distance</span><span class="p">(</span>
                <span class="n">packing_location</span><span class="p">,</span>
                <span class="n">grid_point_location</span><span class="p">,</span>
                <span class="n">rotation_matrix</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">signed_distance_to_surface</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># point is inside dropped ingredient</span>
            <span class="k">if</span> <span class="n">grid_point_index</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">inside_points</span> <span class="ow">or</span> <span class="nb">abs</span><span class="p">(</span>
                <span class="n">signed_distance_to_surface</span>
            <span class="p">)</span> <span class="o">&lt;</span> <span class="nb">abs</span><span class="p">(</span><span class="n">inside_points</span><span class="p">[</span><span class="n">grid_point_index</span><span class="p">]):</span>
                <span class="n">inside_points</span><span class="p">[</span><span class="n">grid_point_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">signed_distance_to_surface</span>
        <span class="k">elif</span> <span class="p">(</span>
            <span class="n">signed_distance_to_surface</span> <span class="o">&lt;</span> <span class="n">grid_distance_values</span><span class="p">[</span><span class="n">grid_point_index</span><span class="p">]</span>
        <span class="p">):</span>  <span class="c1"># point in region of influence</span>
            <span class="c1"># need to update the distances of the master grid with new smaller distance</span>
            <span class="k">if</span> <span class="n">grid_point_index</span> <span class="ow">in</span> <span class="n">new_dist_points</span><span class="p">:</span>
                <span class="n">new_dist_points</span><span class="p">[</span><span class="n">grid_point_index</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                    <span class="n">signed_distance_to_surface</span><span class="p">,</span> <span class="n">new_dist_points</span><span class="p">[</span><span class="n">grid_point_index</span><span class="p">]</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_dist_points</span><span class="p">[</span><span class="n">grid_point_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">signed_distance_to_surface</span>
        <span class="k">return</span> <span class="n">inside_points</span><span class="p">,</span> <span class="n">new_dist_points</span></div>


<div class="viewcode-block" id="Ingredient.is_point_in_correct_region">
<a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.Ingredient.Ingredient.is_point_in_correct_region">[docs]</a>
    <span class="k">def</span> <span class="nf">is_point_in_correct_region</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point</span><span class="p">):</span>
        <span class="c1"># crude location check (using nearest grid point)</span>
        <span class="n">nearest_grid_point_compartment_id</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">compartment_id_for_nearest_grid_point</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
        <span class="p">)</span>  <span class="c1"># offset ?</span>
        <span class="n">compartment_ingr_belongs_in</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compartment_id</span>
        <span class="k">if</span> <span class="n">compartment_ingr_belongs_in</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">compartment</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># env isn&#39;t included in the compartment list</span>
            <span class="c1"># getting the compartment, regardless of the region</span>
            <span class="n">compartment</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">compartments</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">compartment_ingr_belongs_in</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">compartment_ingr_belongs_in</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># surface ingredient</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;Grow&quot;</span><span class="p">:</span>
                <span class="c1"># need a list of accepted compartment_id</span>
                <span class="n">check</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">compMask</span><span class="p">):</span>
                    <span class="n">check</span> <span class="o">=</span> <span class="n">nearest_grid_point_compartment_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">compMask</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">check</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">return</span> <span class="n">check</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">elif</span> <span class="n">compartment_ingr_belongs_in</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># check if point is inside the compartment this ingr belongs in</span>
            <span class="c1"># more detailed check that just the nearest grid point</span>
            <span class="n">inside</span> <span class="o">=</span> <span class="n">compartment</span><span class="o">.</span><span class="n">is_point_inside_mesh</span><span class="p">(</span>
                <span class="n">point</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">diag</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">mesh_store</span><span class="p">,</span> <span class="n">ray</span><span class="o">=</span><span class="mi">3</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">inside</span>
        <span class="k">elif</span> <span class="n">compartment_ingr_belongs_in</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># shouldnt be in any compartments</span>
            <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">compartments</span><span class="p">:</span>
                <span class="n">inside</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">is_point_inside_mesh</span><span class="p">(</span>
                    <span class="n">point</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">diag</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">mesh_store</span><span class="p">,</span> <span class="n">ray</span><span class="o">=</span><span class="mi">3</span>
                <span class="p">)</span>
                <span class="c1"># if inside a compartment, we can&#39;t pack here.</span>
                <span class="k">if</span> <span class="n">inside</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
            <span class="k">return</span> <span class="n">compartment_ingr_belongs_in</span> <span class="o">==</span> <span class="n">nearest_grid_point_compartment_id</span></div>


<div class="viewcode-block" id="Ingredient.far_enough_from_surfaces">
<a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.Ingredient.Ingredient.far_enough_from_surfaces">[docs]</a>
    <span class="k">def</span> <span class="nf">far_enough_from_surfaces</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">):</span>
        <span class="c1"># check if clear of all other compartment surfaces</span>
        <span class="n">ingredient_compartment</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_compartment</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="p">)</span>
        <span class="n">ingredient_compartment_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compartment_id</span>
        <span class="k">for</span> <span class="n">compartment</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">compartments</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">ingredient_compartment_id</span> <span class="o">&gt;</span> <span class="mi">0</span>
                <span class="ow">and</span> <span class="n">ingredient_compartment</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">compartment</span><span class="o">.</span><span class="n">name</span>
            <span class="p">):</span>
                <span class="k">continue</span>
            <span class="c1"># checking compartments I don&#39;t belong to</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">compartment</span><span class="o">.</span><span class="n">OGsrfPtsBht</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="n">cutoff</span><span class="p">:</span>
                    <span class="c1"># too close to a surface</span>
                    <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="Ingredient.point_is_available">
<a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.Ingredient.Ingredient.point_is_available">[docs]</a>
    <span class="k">def</span> <span class="nf">point_is_available</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newPt</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Takes in a vector returns a boolean&quot;&quot;&quot;</span>
        <span class="n">point_in_correct_region</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">far_from_surfaces</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">on_grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">is_point_inside_bb</span><span class="p">(</span>
            <span class="n">newPt</span><span class="p">,</span>
            <span class="n">dist</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cutoff_boundary</span><span class="p">,</span>
            <span class="n">jitter</span><span class="o">=</span><span class="n">getNormedVectorOnes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_jitter</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">on_grid</span><span class="p">:</span>
            <span class="n">point_in_correct_region</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_point_in_correct_region</span><span class="p">(</span><span class="n">newPt</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">point_in_correct_region</span><span class="p">:</span>
                <span class="c1"># check how far from surface ?</span>
                <span class="n">far_from_surfaces</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">far_enough_from_surfaces</span><span class="p">(</span>
                    <span class="n">newPt</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cutoff_surface</span>
                <span class="p">)</span>

                <span class="k">return</span> <span class="n">far_from_surfaces</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="Ingredient.oneJitter">
<a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.Ingredient.Ingredient.oneJitter">[docs]</a>
    <span class="k">def</span> <span class="nf">oneJitter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">env</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">rotMat</span><span class="p">):</span>
        <span class="n">jtrans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">randomize_translation</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">rotMat</span><span class="p">)</span>
        <span class="n">rotMatj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">randomize_rotation</span><span class="p">(</span><span class="n">rotMat</span><span class="p">,</span> <span class="n">env</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">jtrans</span><span class="p">,</span> <span class="n">rotMatj</span></div>


<div class="viewcode-block" id="Ingredient.get_new_jitter_location_and_rotation">
<a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.Ingredient.Ingredient.get_new_jitter_location_and_rotation">[docs]</a>
    <span class="k">def</span> <span class="nf">get_new_jitter_location_and_rotation</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">env</span><span class="p">,</span> <span class="n">starting_pos</span><span class="p">,</span> <span class="n">starting_rotation</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">packing_mode</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">:]</span> <span class="o">==</span> <span class="s2">&quot;tile&quot;</span><span class="p">:</span>
            <span class="n">packing_location</span> <span class="o">=</span> <span class="n">starting_pos</span>
            <span class="n">packing_rotation</span> <span class="o">=</span> <span class="n">starting_rotation</span><span class="p">[:]</span>
            <span class="k">return</span> <span class="n">packing_location</span><span class="p">,</span> <span class="n">packing_rotation</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">oneJitter</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">starting_pos</span><span class="p">,</span> <span class="n">starting_rotation</span><span class="p">)</span></div>


<div class="viewcode-block" id="Ingredient.getIngredientsInBox">
<a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.Ingredient.Ingredient.getIngredientsInBox">[docs]</a>
    <span class="k">def</span> <span class="nf">getIngredientsInBox</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">env</span><span class="p">,</span> <span class="n">jtrans</span><span class="p">,</span> <span class="n">rotMat</span><span class="p">,</span> <span class="n">compartment</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">env</span><span class="o">.</span><span class="n">windowsSize_overwrite</span><span class="p">:</span>
            <span class="n">radius</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">windowsSize</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">radius</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">min_radius</span>
                <span class="o">+</span> <span class="n">env</span><span class="o">.</span><span class="n">largestProteinSize</span>
                <span class="o">+</span> <span class="n">env</span><span class="o">.</span><span class="n">smallestProteinSize</span>
                <span class="o">+</span> <span class="n">env</span><span class="o">.</span><span class="n">windowsSize</span>
            <span class="p">)</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">jtrans</span>
        <span class="n">bb</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">[</span><span class="n">x</span> <span class="o">-</span> <span class="n">radius</span><span class="p">,</span> <span class="n">y</span> <span class="o">-</span> <span class="n">radius</span><span class="p">,</span> <span class="n">z</span> <span class="o">-</span> <span class="n">radius</span><span class="p">],</span>
            <span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="n">radius</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="n">radius</span><span class="p">,</span> <span class="n">z</span> <span class="o">+</span> <span class="n">radius</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_type</span> <span class="o">==</span> <span class="s2">&quot;Cylinders&quot;</span><span class="p">:</span>
            <span class="n">cent1T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformPoints</span><span class="p">(</span>
                <span class="n">jtrans</span><span class="p">,</span> <span class="n">rotMat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">deepest_level</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">cent2T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformPoints</span><span class="p">(</span>
                <span class="n">jtrans</span><span class="p">,</span> <span class="n">rotMat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">positions2</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">deepest_level</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">bbs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">radc</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">radii</span><span class="p">,</span> <span class="n">cent1T</span><span class="p">,</span> <span class="n">cent2T</span><span class="p">):</span>
                <span class="n">bb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">correctBB</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">radc</span><span class="p">)</span>
                <span class="n">bbs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bb</span><span class="p">)</span>
            <span class="c1"># get min and max from all bbs</span>
            <span class="n">maxBB</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">minBB</span> <span class="o">=</span> <span class="p">[</span><span class="mi">9999</span><span class="p">,</span> <span class="mi">9999</span><span class="p">,</span> <span class="mi">9999</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">bb</span> <span class="ow">in</span> <span class="n">bbs</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">bb</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">minBB</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                        <span class="n">minBB</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">bb</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">bb</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">maxBB</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                        <span class="n">maxBB</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">bb</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">bb</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">minBB</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                        <span class="n">minBB</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">bb</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">bb</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">maxBB</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                        <span class="n">maxBB</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">bb</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
            <span class="n">bb</span> <span class="o">=</span> <span class="p">[</span><span class="n">minBB</span><span class="p">,</span> <span class="n">maxBB</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">env</span><span class="o">.</span><span class="n">runTimeDisplay</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">box</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">getObject</span><span class="p">(</span><span class="s2">&quot;partBox&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">box</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">box</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">Box</span><span class="p">(</span><span class="s2">&quot;partBox&quot;</span><span class="p">,</span> <span class="n">cornerPoints</span><span class="o">=</span><span class="n">bb</span><span class="p">,</span> <span class="n">visible</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">toggleDisplay</span><span class="p">(</span><span class="n">box</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">updateBox</span><span class="p">(</span><span class="n">box</span><span class="p">,</span> <span class="n">cornerPoints</span><span class="o">=</span><span class="n">bb</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
                <span class="c1">#            sleep(1.0)</span>
        <span class="c1"># pointsInCube = env.grid.getPointsInCube(bb, jtrans, radius)</span>
        <span class="c1"># should we got all ingre from all recipes?</span>
        <span class="c1"># can use the kdtree for it...</span>
        <span class="c1"># maybe just add the surface if its not already the surface</span>
        <span class="n">ingredients</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">compartment</span><span class="o">.</span><span class="n">packed_objects</span><span class="o">.</span><span class="n">get</span><span class="p">():</span>
            <span class="n">ingredients</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">obj</span><span class="p">,</span> <span class="n">get_distance</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">position</span><span class="p">,</span> <span class="n">jtrans</span><span class="p">)])</span>

        <span class="k">return</span> <span class="n">ingredients</span></div>


<div class="viewcode-block" id="Ingredient.get_partners">
<a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.Ingredient.Ingredient.get_partners">[docs]</a>
    <span class="k">def</span> <span class="nf">get_partners</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">env</span><span class="p">,</span> <span class="n">jtrans</span><span class="p">,</span> <span class="n">rotMat</span><span class="p">,</span> <span class="n">organelle</span><span class="p">):</span>
        <span class="n">closest_ingredients</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">get_closest_ingredients</span><span class="p">(</span><span class="n">jtrans</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">diag</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">closest_ingredients</span><span class="p">[</span><span class="s2">&quot;indices&quot;</span><span class="p">]):</span>
            <span class="n">near_by_ingredients</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getIngredientsInBox</span><span class="p">(</span>
                <span class="n">env</span><span class="p">,</span> <span class="n">jtrans</span><span class="p">,</span> <span class="n">rotMat</span><span class="p">,</span> <span class="n">organelle</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">near_by_ingredients</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">get_ingredients_in_tree</span><span class="p">(</span><span class="n">closest_ingredients</span><span class="p">)</span>
        <span class="n">placed_partners</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">near_by_ingredients</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;no close ingredient found&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;nb close ingredient </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">near_by_ingredients</span><span class="p">)):</span>
            <span class="n">packed_ingredient</span> <span class="o">=</span> <span class="n">near_by_ingredients</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ingredient</span>
            <span class="n">distance</span> <span class="o">=</span> <span class="n">near_by_ingredients</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">packing_mode</span> <span class="o">==</span> <span class="s2">&quot;closePartner&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">partners</span><span class="o">.</span><span class="n">is_partner</span><span class="p">(</span><span class="n">packed_ingredient</span><span class="o">.</span><span class="n">name</span><span class="p">):</span>
                    <span class="n">placed_partners</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="p">[</span>
                            <span class="n">i</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">partners</span><span class="o">.</span><span class="n">get_partner_by_ingr_name</span><span class="p">(</span>
                                <span class="n">packed_ingredient</span><span class="o">.</span><span class="n">name</span>
                            <span class="p">),</span>
                            <span class="n">distance</span><span class="p">,</span>
                        <span class="p">]</span>
                    <span class="p">)</span>
            <span class="k">if</span> <span class="n">packed_ingredient</span><span class="o">.</span><span class="n">is_attractor</span><span class="p">:</span>
                <span class="c1"># add all ingredients as possible partners</span>
                <span class="c1"># attractors are universal attractors</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">partners</span><span class="o">.</span><span class="n">is_partner</span><span class="p">(</span><span class="n">packed_ingredient</span><span class="o">.</span><span class="n">name</span><span class="p">):</span>
                    <span class="n">part</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">partners</span><span class="o">.</span><span class="n">get_partner_by_ingr_name</span><span class="p">(</span>
                        <span class="n">packed_ingredient</span><span class="o">.</span><span class="n">name</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="n">part</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">part</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">partners</span><span class="o">.</span><span class="n">add_partner</span><span class="p">(</span>
                            <span class="n">packed_ingredient</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="n">packed_ingredient</span><span class="o">.</span><span class="n">weight</span>
                        <span class="p">)</span>
                    <span class="k">if</span> <span class="n">packed_ingredient</span><span class="o">.</span><span class="n">distance_expression</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">part</span><span class="o">.</span><span class="n">distance_expression</span> <span class="o">=</span> <span class="n">packed_ingredient</span><span class="o">.</span><span class="n">distance_expression</span>
                    <span class="n">placed_partners</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="n">part</span><span class="p">,</span> <span class="n">distance</span><span class="p">])</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">placed_partners</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;no partner found in close ingredient </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">packing_mode</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">near_by_ingredients</span><span class="p">,</span> <span class="n">placed_partners</span></div>


<div class="viewcode-block" id="Ingredient.get_new_pos">
<a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.Ingredient.Ingredient.get_new_pos">[docs]</a>
    <span class="k">def</span> <span class="nf">get_new_pos</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ingr</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">rot</span><span class="p">,</span> <span class="n">positions_to_adjust</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Takes positions_to_adjust, such as an array of spheres at a level in a</span>
<span class="sd">        sphere tree, and adjusts them relative to the given position and rotation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">positions_to_adjust</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">positions_to_adjust</span> <span class="o">=</span> <span class="n">ingr</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformPoints</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">rot</span><span class="p">,</span> <span class="n">positions_to_adjust</span><span class="p">)</span></div>


<div class="viewcode-block" id="Ingredient.check_against_one_packed_ingr">
<a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.Ingredient.Ingredient.check_against_one_packed_ingr">[docs]</a>
    <span class="k">def</span> <span class="nf">check_against_one_packed_ingr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">search_tree</span><span class="p">):</span>
        <span class="n">ingredient_instance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">packed_objects</span><span class="o">.</span><span class="n">get_ingredients</span><span class="p">()[</span><span class="n">index</span><span class="p">]</span>
        <span class="n">ingredient_class</span> <span class="o">=</span> <span class="n">ingredient_instance</span><span class="o">.</span><span class="n">ingredient</span>
        <span class="n">positions_of_packed_ingr_spheres</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_new_pos</span><span class="p">(</span>
            <span class="n">ingredient_class</span><span class="p">,</span>
            <span class="n">ingredient_instance</span><span class="o">.</span><span class="n">position</span><span class="p">,</span>
            <span class="n">ingredient_instance</span><span class="o">.</span><span class="n">rotation</span><span class="p">,</span>
            <span class="n">ingredient_class</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="n">level</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="c1"># check distances between the spheres at this level in the ingr we are packing</span>
        <span class="c1"># to the spheres at this level in the ingr already placed</span>
        <span class="c1"># return the number of distances for the spheres we are trying to place</span>
        <span class="n">dist_from_packed_spheres_to_new_spheres</span><span class="p">,</span> <span class="n">ind</span> <span class="o">=</span> <span class="n">search_tree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
            <span class="n">positions_of_packed_ingr_spheres</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="n">level</span><span class="p">])</span>
        <span class="p">)</span>
        <span class="c1"># return index of sph1 closest to pos of packed ingr</span>
        <span class="n">cradii</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">radii</span><span class="p">[</span><span class="n">level</span><span class="p">])[</span><span class="n">ind</span><span class="p">]</span>
        <span class="n">oradii</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">packed_objects</span><span class="o">.</span><span class="n">get_ingredients</span><span class="p">()[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">ingredient</span><span class="o">.</span><span class="n">radii</span><span class="p">[</span><span class="n">level</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">sumradii</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">cradii</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span> <span class="n">oradii</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
        <span class="n">sD</span> <span class="o">=</span> <span class="n">dist_from_packed_spheres_to_new_spheres</span> <span class="o">-</span> <span class="n">sumradii</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">sD</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">0</span></div>


<div class="viewcode-block" id="Ingredient.np_check_collision">
<a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.Ingredient.Ingredient.np_check_collision">[docs]</a>
    <span class="k">def</span> <span class="nf">np_check_collision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">packing_location</span><span class="p">,</span> <span class="n">rotation</span><span class="p">):</span>
        <span class="n">has_collision</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># no ingredients packed yet</span>
        <span class="n">packed_objects</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">packed_objects</span><span class="o">.</span><span class="n">get_ingredients</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">packed_objects</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">has_collision</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">close_ingr_bhtree</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">close_ingr_bhtree</span> <span class="o">=</span> <span class="n">spatial</span><span class="o">.</span><span class="n">cKDTree</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">packed_objects</span><span class="o">.</span><span class="n">get_positions</span><span class="p">(),</span> <span class="n">leafsize</span><span class="o">=</span><span class="mi">10</span>
                <span class="p">)</span>
        <span class="c1"># starting at level 0, check encapsulating radii</span>
        <span class="n">level</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">total_levels</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;positions&quot;</span><span class="p">)</span> <span class="k">else</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">positions</span><span class="p">)</span>
        <span class="p">(</span>
            <span class="n">distances_from_packing_location_to_all_ingr</span><span class="p">,</span>
            <span class="n">ingr_indexes</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">close_ingr_bhtree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">packing_location</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">packed_objects</span><span class="p">))</span>
        <span class="n">radii_of_placed_ingr</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">packed_objects</span><span class="o">.</span><span class="n">get_encapsulating_radii</span><span class="p">()</span>
        <span class="p">)[</span><span class="n">ingr_indexes</span><span class="p">]</span>
        <span class="n">overlap_distance</span> <span class="o">=</span> <span class="n">distances_from_packing_location_to_all_ingr</span> <span class="o">-</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">encapsulating_radius</span> <span class="o">+</span> <span class="n">radii_of_placed_ingr</span>
        <span class="p">)</span>
        <span class="c1"># if overlap_distance is negative, the encapsualting radii are overlapping</span>
        <span class="n">overlap_indexes</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">overlap_distance</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">overlap_indexes</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">level</span> <span class="o">=</span> <span class="n">level</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="c1"># single sphere ingr will exit here.</span>
            <span class="k">if</span> <span class="n">level</span> <span class="o">&gt;=</span> <span class="n">total_levels</span><span class="p">:</span>
                <span class="n">has_collision</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="c1"># for each packed ingredient that had a collision, we want to check the more</span>
            <span class="c1"># detailed geometry, ie walk down the sphere tree file.</span>
            <span class="k">while</span> <span class="n">level</span> <span class="o">&lt;</span> <span class="n">total_levels</span><span class="p">:</span>
                <span class="n">pos_of_attempting_ingr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_new_pos</span><span class="p">(</span>
                    <span class="bp">self</span><span class="p">,</span> <span class="n">packing_location</span><span class="p">,</span> <span class="n">rotation</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="n">level</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="n">search_tree_for_new_ingr</span> <span class="o">=</span> <span class="n">spatial</span><span class="o">.</span><span class="n">cKDTree</span><span class="p">(</span><span class="n">pos_of_attempting_ingr</span><span class="p">)</span>
                <span class="n">collision_at_this_level</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="c1"># NOTE: At certain lengths of overlap_indices, it might help to remove items from the list</span>
                <span class="c1"># if they dont have a collision at a non max level, but for short arrays, removing indices</span>
                <span class="c1"># takes longer than not checking it.</span>
                <span class="k">for</span> <span class="n">overlap_index</span> <span class="ow">in</span> <span class="n">overlap_indexes</span><span class="p">:</span>
                    <span class="n">index</span> <span class="o">=</span> <span class="n">ingr_indexes</span><span class="p">[</span><span class="n">overlap_index</span><span class="p">]</span>
                    <span class="n">collision_at_this_level</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_against_one_packed_ingr</span><span class="p">(</span>
                        <span class="n">index</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">search_tree_for_new_ingr</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="n">collision_at_this_level</span><span class="p">:</span>
                        <span class="k">break</span>
                <span class="n">level</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">collision_at_this_level</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">level</span> <span class="o">==</span> <span class="n">total_levels</span><span class="p">:</span>
                        <span class="c1"># found collision at lowest level, break all the way out</span>
                        <span class="k">return</span> <span class="kc">True</span>
                <span class="k">del</span> <span class="n">search_tree_for_new_ingr</span>
        <span class="k">return</span> <span class="n">has_collision</span></div>


<div class="viewcode-block" id="Ingredient.checkDistance">
<a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.Ingredient.Ingredient.checkDistance">[docs]</a>
    <span class="k">def</span> <span class="nf">checkDistance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">liste_nodes</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">liste_nodes</span><span class="p">:</span>
            <span class="n">rTrans</span><span class="p">,</span> <span class="n">rRot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">getRotTransRB</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">measure_distance</span><span class="p">(</span><span class="n">rTrans</span><span class="p">,</span> <span class="n">point</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;checkDistance&quot;</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="n">cutoff</span><span class="p">)</span></div>


<div class="viewcode-block" id="Ingredient.get_rbNodes">
<a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.Ingredient.Ingredient.get_rbNodes">[docs]</a>
    <span class="k">def</span> <span class="nf">get_rbNodes</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">close_indice</span><span class="p">,</span> <span class="n">currentpt</span><span class="p">,</span> <span class="n">removelast</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">prevpoint</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">getInfo</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>
        <span class="c1"># move around the rbnode and return it</span>
        <span class="c1"># self.env.loopThroughIngr( self.env.reset_rbnode )</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">compartment_id</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">organelle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">organelle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">compartments</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">compartment_id</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1">#        a=numpy.asarray(self.env.rTrans)[close_indice[&quot;indices&quot;]]</span>
        <span class="c1">#        b=numpy.array([currentpt,])</span>
        <span class="n">distances</span> <span class="o">=</span> <span class="n">close_indice</span><span class="p">[</span>
            <span class="s2">&quot;distances&quot;</span>
        <span class="p">]</span>  <span class="c1"># spatial.distance.cdist(a,b)#close_indice[&quot;distance&quot;]</span>
        <span class="k">for</span> <span class="n">nid</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">close_indice</span><span class="p">[</span><span class="s2">&quot;indices&quot;</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="c1"># if n == len(close_indice[&quot;indices&quot;]):</span>
            <span class="c1">#                continue</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">rIngr</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="n">ingr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">rIngr</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">distances</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">distances</span><span class="p">[</span><span class="n">nid</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="n">distances</span><span class="p">[</span><span class="n">nid</span><span class="p">]</span>
                    <span class="o">&gt;</span> <span class="p">(</span><span class="n">ingr</span><span class="o">.</span><span class="n">encapsulating_radius</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">encapsulating_radius</span><span class="p">)</span>
                    <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">scaleER</span>
                <span class="p">):</span>
                    <span class="k">continue</span>

            <span class="n">jtrans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">rTrans</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
            <span class="n">rotMat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">rRot</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">prevpoint</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># if prevpoint == jtrans : continue</span>
                <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">measure_distance</span><span class="p">(</span>
                    <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">jtrans</span><span class="p">),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">prevpoint</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># same point</span>
                    <span class="k">continue</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;Grow&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">ingr</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                    <span class="n">c</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">rIngr</span><span class="p">)</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="n">c</span><span class="p">)</span> <span class="ow">or</span> <span class="n">n</span> <span class="o">==</span> <span class="p">(</span><span class="n">c</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>  <span class="c1"># or  (n==(c-2)):</span>
                        <span class="k">continue</span>
            <span class="k">if</span> <span class="n">ingr</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">partners</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;Grow&quot;</span><span class="p">:</span>
                <span class="n">c</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">rIngr</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="n">c</span><span class="p">)</span> <span class="ow">or</span> <span class="n">n</span> <span class="o">==</span> <span class="p">(</span><span class="n">c</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>  <span class="c1"># or (n==c-2):</span>
                    <span class="k">continue</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">ingr</span><span class="o">.</span><span class="n">partners</span> <span class="ow">and</span> <span class="n">ingr</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;Grow&quot;</span><span class="p">:</span>
                <span class="n">c</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">rIngr</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="n">c</span><span class="p">)</span> <span class="ow">or</span> <span class="n">n</span> <span class="o">==</span> <span class="p">(</span><span class="n">c</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>  <span class="c1"># or (n==c-2):</span>
                    <span class="k">continue</span>
                    <span class="c1">#            if self.packing_mode == &#39;hexatile&#39; :</span>
                    <span class="c1">#                #no self collition for testing</span>
                    <span class="c1">#                if self.name == ingr.name :</span>
                    <span class="c1">#                    continue</span>
            <span class="n">rbnode</span> <span class="o">=</span> <span class="n">ingr</span><span class="o">.</span><span class="n">get_rb_model</span><span class="p">(</span><span class="n">alt</span><span class="o">=</span><span class="p">(</span><span class="n">ingr</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">getInfo</span><span class="p">:</span>
                <span class="n">nodes</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">rbnode</span><span class="p">,</span> <span class="n">jtrans</span><span class="p">,</span> <span class="n">rotMat</span><span class="p">,</span> <span class="n">ingr</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rbnode</span><span class="p">)</span>
        <span class="c1"># append organelle rb nodes</span>
        <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">compartments</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">compartment_id</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">o</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">organelle</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                <span class="c1"># this i notworking for growing ingredient like hair.</span>
                <span class="c1"># should had after second segments</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="s2">&quot;Grow&quot;</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># whats the current length</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="k">continue</span>
            <span class="n">orbnode</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">get_rb_model</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">orbnode</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># test distance to surface ?</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">OGsrfPtsBht</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">currentpt</span><span class="p">])))</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">encapsulating_radius</span><span class="p">:</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">getInfo</span><span class="p">:</span>
                            <span class="n">nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">orbnode</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">nodes</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">orbnode</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">numpy</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">o</span><span class="p">])</span>
                            <span class="c1">#        if self.compartment_id &lt; 0 or self.compartment_id == 0 :</span>
                            <span class="c1">#            for o in self.env.compartments:</span>
                            <span class="c1">#                if o.rbnode is not None :</span>
                            <span class="c1">#                    if not getInfo :</span>
                            <span class="c1">#                        nodes.append(o.rbnode)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="n">nodes</span>
        <span class="k">return</span> <span class="n">nodes</span></div>


<div class="viewcode-block" id="Ingredient.update_data_tree">
<a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.Ingredient.Ingredient.update_data_tree">[docs]</a>
    <span class="k">def</span> <span class="nf">update_data_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">packed_objects</span><span class="o">.</span><span class="n">get_ingredients</span><span class="p">())</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">close_ingr_bhtree</span> <span class="o">=</span> <span class="n">spatial</span><span class="o">.</span><span class="n">cKDTree</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">packed_objects</span><span class="o">.</span><span class="n">get_positions</span><span class="p">(),</span> <span class="n">leafsize</span><span class="o">=</span><span class="mi">10</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="Ingredient.pack_at_grid_pt_location">
<a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.Ingredient.Ingredient.pack_at_grid_pt_location">[docs]</a>
    <span class="k">def</span> <span class="nf">pack_at_grid_pt_location</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">env</span><span class="p">,</span>
        <span class="n">jtrans</span><span class="p">,</span>
        <span class="n">rotation_matrix</span><span class="p">,</span>
        <span class="n">dpad</span><span class="p">,</span>
        <span class="n">grid_point_distances</span><span class="p">,</span>
        <span class="n">inside_points</span><span class="p">,</span>
        <span class="n">new_dist_points</span><span class="p">,</span>
        <span class="n">pt_index</span><span class="p">,</span>
    <span class="p">):</span>

        <span class="n">packing_location</span> <span class="o">=</span> <span class="n">jtrans</span>
        <span class="n">radius_of_area_to_check</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">encapsulating_radius</span> <span class="o">+</span> <span class="n">dpad</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">store_packed_object</span><span class="p">(</span><span class="n">packing_location</span><span class="p">,</span> <span class="n">rotation_matrix</span><span class="p">,</span> <span class="n">pt_index</span><span class="p">)</span>

        <span class="n">bounding_points_to_check</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_all_positions_to_check</span><span class="p">(</span><span class="n">packing_location</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">bounding_point_position</span> <span class="ow">in</span> <span class="n">bounding_points_to_check</span><span class="p">:</span>
            <span class="n">grid_points_to_update</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">getPointsInSphere</span><span class="p">(</span>
                <span class="n">bounding_point_position</span><span class="p">,</span> <span class="n">radius_of_area_to_check</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">grid_point_index</span> <span class="ow">in</span> <span class="n">grid_points_to_update</span><span class="p">:</span>
                <span class="p">(</span>
                    <span class="n">inside_points</span><span class="p">,</span>
                    <span class="n">new_dist_points</span><span class="p">,</span>
                <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_new_distances_and_inside_points</span><span class="p">(</span>
                    <span class="n">env</span><span class="p">,</span>
                    <span class="n">bounding_point_position</span><span class="p">,</span>
                    <span class="n">rotation_matrix</span><span class="p">,</span>
                    <span class="n">grid_point_index</span><span class="p">,</span>
                    <span class="n">grid_point_distances</span><span class="p">,</span>
                    <span class="n">new_dist_points</span><span class="p">,</span>
                    <span class="n">inside_points</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">return</span> <span class="n">inside_points</span><span class="p">,</span> <span class="n">new_dist_points</span></div>


<div class="viewcode-block" id="Ingredient.remove_from_realtime_display">
<a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.Ingredient.Ingredient.remove_from_realtime_display">[docs]</a>
    <span class="k">def</span> <span class="nf">remove_from_realtime_display</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">moving</span><span class="p">):</span>
        <span class="k">pass</span></div>

        <span class="c1"># env.afvi.vi.deleteObject(moving)</span>

<div class="viewcode-block" id="Ingredient.reject">
<a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.Ingredient.Ingredient.reject">[docs]</a>
    <span class="k">def</span> <span class="nf">reject</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="c1"># got rejected</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">haveBeenRejected</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rejectionCounter</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Failed ingr:</span><span class="si">%s</span><span class="s2"> rejections:</span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rejectionCounter</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rejectionCounter</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rejection_threshold</span>
        <span class="p">):</span>  <span class="c1"># Graham set this to 6000 for figure 13b (Results Fig 3 Test1) otehrwise it fails to fill small guys</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;PREMATURE ENDING of ingredient </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">completion</span> <span class="o">=</span> <span class="mf">1.0</span></div>


<div class="viewcode-block" id="Ingredient.store_packed_object">
<a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.Ingredient.Ingredient.store_packed_object">[docs]</a>
    <span class="k">def</span> <span class="nf">store_packed_object</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">rotation</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="n">packed_object</span> <span class="o">=</span> <span class="n">PackedObject</span><span class="p">(</span>
            <span class="n">position</span><span class="o">=</span><span class="n">position</span><span class="p">,</span>
            <span class="n">rotation</span><span class="o">=</span><span class="n">rotation</span><span class="p">,</span>
            <span class="n">radius</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_radius</span><span class="p">(),</span>
            <span class="n">pt_index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span>
            <span class="n">ingredient</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">packed_objects</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">packed_object</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">compartment_id</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">compartment</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_compartment</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="p">)</span>
            <span class="n">compartment</span><span class="o">.</span><span class="n">packed_objects</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">packed_object</span><span class="p">)</span></div>


<div class="viewcode-block" id="Ingredient.place">
<a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.Ingredient.Ingredient.place">[docs]</a>
    <span class="k">def</span> <span class="nf">place</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">env</span><span class="p">,</span>
        <span class="n">dropped_position</span><span class="p">,</span>
        <span class="n">dropped_rotation</span><span class="p">,</span>
        <span class="n">grid_point_index</span><span class="p">,</span>
        <span class="n">new_inside_points</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nbPts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbPts</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_inside_points</span><span class="p">)</span>

        <span class="n">env</span><span class="o">.</span><span class="n">update_after_place</span><span class="p">(</span><span class="n">grid_point_index</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">packing_mode</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">:]</span> <span class="o">==</span> <span class="s2">&quot;tile&quot;</span><span class="p">:</span>
            <span class="n">nexthexa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tilling</span><span class="o">.</span><span class="n">dropTile</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tilling</span><span class="o">.</span><span class="n">idc</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tilling</span><span class="o">.</span><span class="n">edge_id</span><span class="p">,</span>
                <span class="n">dropped_position</span><span class="p">,</span>
                <span class="n">dropped_rotation</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;drop next hexa </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">nexthexa</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="c1"># add one to molecule counter for this ingredient</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">completion</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">counter</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left_to_place</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rejectionCounter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_data_tree</span><span class="p">()</span></div>


<div class="viewcode-block" id="Ingredient.update_ingredient_size">
<a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.Ingredient.Ingredient.update_ingredient_size">[docs]</a>
    <span class="k">def</span> <span class="nf">update_ingredient_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># update the size of the ingredient based on input options</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;size_options&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">size_options</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">INGREDIENT_TYPE</span><span class="o">.</span><span class="n">SINGLE_SPHERE</span><span class="p">:</span>
                <span class="n">radius</span> <span class="o">=</span> <span class="n">get_value_from_distribution</span><span class="p">(</span>
                    <span class="n">distribution_options</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">size_options</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">radius</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">radius</span> <span class="o">=</span> <span class="n">radius</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">encapsulating_radius</span> <span class="o">=</span> <span class="n">radius</span></div>


<div class="viewcode-block" id="Ingredient.attempt_to_pack_at_grid_location">
<a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.Ingredient.Ingredient.attempt_to_pack_at_grid_location">[docs]</a>
    <span class="k">def</span> <span class="nf">attempt_to_pack_at_grid_location</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">env</span><span class="p">,</span>
        <span class="n">ptInd</span><span class="p">,</span>
        <span class="n">grid_point_distances</span><span class="p">,</span>
        <span class="n">max_radius</span><span class="p">,</span>
        <span class="n">spacing</span><span class="p">,</span>
        <span class="n">usePP</span><span class="p">,</span>
        <span class="n">collision_possible</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">success</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">jitter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getMaxJitter</span><span class="p">(</span><span class="n">spacing</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_ingredient_size</span><span class="p">()</span>

        <span class="n">dpad</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_radius</span> <span class="o">+</span> <span class="n">max_radius</span> <span class="o">+</span> <span class="n">jitter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vi</span> <span class="o">=</span> <span class="n">autopack</span><span class="o">.</span><span class="n">helper</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">env</span> <span class="o">=</span> <span class="n">env</span>  <span class="c1"># NOTE: do we need to store the env on the ingredient?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;PLACING INGREDIENT </span><span class="si">%s</span><span class="s2">, place_method=</span><span class="si">%s</span><span class="s2">, index=</span><span class="si">%d</span><span class="s2">, position=</span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">place_method</span><span class="p">,</span>
            <span class="n">ptInd</span><span class="p">,</span>
            <span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">masterGridPositions</span><span class="p">[</span><span class="n">ptInd</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="n">compartment</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_compartment</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
        <span class="n">gridPointsCoords</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">masterGridPositions</span>
        <span class="n">rotation_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_rotation</span><span class="p">(</span><span class="n">ptInd</span><span class="p">,</span> <span class="n">env</span><span class="p">,</span> <span class="n">compartment</span><span class="p">)</span>
        <span class="n">target_grid_point_position</span> <span class="o">=</span> <span class="n">gridPointsCoords</span><span class="p">[</span>
            <span class="n">ptInd</span>
        <span class="p">]</span>  <span class="c1"># drop point, surface points.</span>
        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">offset</span><span class="p">)</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="n">target_grid_point_position</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">target_grid_point_position</span><span class="p">)</span>
                <span class="o">+</span> <span class="n">ApplyMatrix</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">offset</span><span class="p">],</span> <span class="n">rotation_matrix</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="n">target_grid_point_position</span> <span class="o">=</span> <span class="n">gridPointsCoords</span><span class="p">[</span>
            <span class="n">ptInd</span>
        <span class="p">]</span>  <span class="c1"># drop point, surface points.</span>

        <span class="n">current_visual_instance</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">env</span><span class="o">.</span><span class="n">runTimeDisplay</span><span class="p">:</span>
            <span class="n">current_visual_instance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">handle_real_time_visualization</span><span class="p">(</span>
                <span class="n">autopack</span><span class="o">.</span><span class="n">helper</span><span class="p">,</span> <span class="n">ptInd</span><span class="p">,</span> <span class="n">target_grid_point_position</span><span class="p">,</span> <span class="n">rotation_matrix</span>
            <span class="p">)</span>
        <span class="n">is_realtime</span> <span class="o">=</span> <span class="n">current_visual_instance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="c1"># NOTE: move the target point for close partner check.</span>
        <span class="c1"># I think this should be done ealier, when we&#39;re getting the point index</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">packing_mode</span> <span class="o">==</span> <span class="s2">&quot;closePartner&quot;</span><span class="p">:</span>
            <span class="n">target_grid_point_position</span><span class="p">,</span> <span class="n">rotation_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">close_partner_check</span><span class="p">(</span>
                <span class="n">env</span><span class="p">,</span>
                <span class="n">target_grid_point_position</span><span class="p">,</span>
                <span class="n">rotation_matrix</span><span class="p">,</span>
                <span class="n">compartment</span><span class="p">,</span>
                <span class="n">env</span><span class="o">.</span><span class="n">afviewer</span><span class="p">,</span>
                <span class="n">current_visual_instance</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">target_grid_point_position</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="p">{},</span> <span class="p">{}</span>
        <span class="n">is_fiber</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;Grow&quot;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;Actine&quot;</span>
        <span class="n">collision_possible</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">collision_possible</span> <span class="ow">or</span> <span class="n">is_fiber</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">is_fiber</span><span class="p">:</span>
                <span class="n">success</span><span class="p">,</span> <span class="n">jtrans</span><span class="p">,</span> <span class="n">rotMatj</span><span class="p">,</span> <span class="n">insidePoints</span><span class="p">,</span> <span class="n">newDistPoints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grow_place</span><span class="p">(</span>
                    <span class="n">env</span><span class="p">,</span>
                    <span class="n">ptInd</span><span class="p">,</span>
                    <span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">free_points</span><span class="p">,</span>
                    <span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">nbFreePoints</span><span class="p">,</span>
                    <span class="n">grid_point_distances</span><span class="p">,</span>
                    <span class="n">dpad</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">place_method</span> <span class="o">==</span> <span class="s2">&quot;jitter&quot;</span><span class="p">:</span>
                <span class="p">(</span>
                    <span class="n">success</span><span class="p">,</span>
                    <span class="n">jtrans</span><span class="p">,</span>
                    <span class="n">rotMatj</span><span class="p">,</span>
                    <span class="n">insidePoints</span><span class="p">,</span>
                    <span class="n">newDistPoints</span><span class="p">,</span>
                <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">jitter_place</span><span class="p">(</span>
                    <span class="n">env</span><span class="p">,</span>
                    <span class="n">target_grid_point_position</span><span class="p">,</span>
                    <span class="n">rotation_matrix</span><span class="p">,</span>
                    <span class="n">current_visual_instance</span><span class="p">,</span>
                    <span class="n">grid_point_distances</span><span class="p">,</span>
                    <span class="n">dpad</span><span class="p">,</span>
                    <span class="n">ptInd</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">place_method</span> <span class="o">==</span> <span class="s2">&quot;spheresSST&quot;</span><span class="p">:</span>
                <span class="p">(</span>
                    <span class="n">success</span><span class="p">,</span>
                    <span class="n">jtrans</span><span class="p">,</span>
                    <span class="n">rotMatj</span><span class="p">,</span>
                    <span class="n">insidePoints</span><span class="p">,</span>
                    <span class="n">newDistPoints</span><span class="p">,</span>
                <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spheres_SST_place</span><span class="p">(</span>
                    <span class="n">env</span><span class="p">,</span>
                    <span class="n">compartment</span><span class="p">,</span>
                    <span class="n">ptInd</span><span class="p">,</span>
                    <span class="n">target_grid_point_position</span><span class="p">,</span>
                    <span class="n">rotation_matrix</span><span class="p">,</span>
                    <span class="n">current_visual_instance</span><span class="p">,</span>
                    <span class="n">grid_point_distances</span><span class="p">,</span>
                    <span class="n">dpad</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Can&#39;t pack using this method </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">place_method</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">reject</span><span class="p">()</span>
                <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="p">{},</span> <span class="p">{}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># blind packing without further collision checks</span>
            <span class="c1"># TODO: make this work for ingredients other than single spheres</span>

            <span class="n">success</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="p">(</span><span class="n">jtrans</span><span class="p">,</span> <span class="n">rotMatj</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_new_jitter_location_and_rotation</span><span class="p">(</span>
                <span class="n">env</span><span class="p">,</span> <span class="n">target_grid_point_position</span><span class="p">,</span> <span class="n">rotation_matrix</span>
            <span class="p">)</span>
            <span class="p">(</span><span class="n">insidePoints</span><span class="p">,</span> <span class="n">newDistPoints</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pack_at_grid_pt_location</span><span class="p">(</span>
                <span class="n">env</span><span class="p">,</span>
                <span class="n">jtrans</span><span class="p">,</span>
                <span class="n">rotMatj</span><span class="p">,</span>
                <span class="n">dpad</span><span class="p">,</span>
                <span class="n">grid_point_distances</span><span class="p">,</span>
                <span class="n">insidePoints</span><span class="p">,</span>
                <span class="n">newDistPoints</span><span class="p">,</span>
                <span class="n">ptInd</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">success</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">is_realtime</span><span class="p">:</span>
                <span class="n">autopack</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">set_object_static</span><span class="p">(</span>
                    <span class="n">current_visual_instance</span><span class="p">,</span> <span class="n">jtrans</span><span class="p">,</span> <span class="n">rotMatj</span>
                <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">place</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">jtrans</span><span class="p">,</span> <span class="n">rotMatj</span><span class="p">,</span> <span class="n">ptInd</span><span class="p">,</span> <span class="n">insidePoints</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">is_realtime</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remove_from_realtime_display</span><span class="p">(</span><span class="n">current_visual_instance</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reject</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">success</span><span class="p">,</span> <span class="n">insidePoints</span><span class="p">,</span> <span class="n">newDistPoints</span></div>


<div class="viewcode-block" id="Ingredient.get_rotation">
<a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.Ingredient.Ingredient.get_rotation">[docs]</a>
    <span class="k">def</span> <span class="nf">get_rotation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pt_ind</span><span class="p">,</span> <span class="n">env</span><span class="p">,</span> <span class="n">compartment</span><span class="p">):</span>
        <span class="c1"># compute rotation matrix rotMat</span>
        <span class="n">comp_num</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compartment_id</span>

        <span class="n">rot_mat</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">comp_num</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># for surface points we compute the rotation which</span>
            <span class="c1"># aligns the principal_vector with the surface normal</span>
            <span class="n">v1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">principal_vector</span>
            <span class="n">v2</span> <span class="o">=</span> <span class="n">compartment</span><span class="o">.</span><span class="n">get_normal_for_point</span><span class="p">(</span>
                <span class="n">pt_ind</span><span class="p">,</span> <span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">masterGridPositions</span><span class="p">[</span><span class="n">pt_ind</span><span class="p">],</span> <span class="n">env</span><span class="o">.</span><span class="n">mesh_store</span>
            <span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">rot_mat</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rotVectToVect</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">),</span> <span class="s2">&quot;f&quot;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;PROBLEM: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">rot_mat</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># this is where we could apply biased rotation ie gradient/attractor</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_rotation_axis</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rotation_axis</span><span class="p">)</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
                    <span class="n">rot_mat</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
                <span class="k">elif</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">use_orient_bias</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">packing_mode</span> <span class="o">==</span> <span class="s2">&quot;gradient&quot;</span>
                <span class="p">):</span>  <span class="c1"># you need a gradient here</span>
                    <span class="n">rot_mat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alignRotation</span><span class="p">(</span>
                        <span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">masterGridPositions</span><span class="p">[</span><span class="n">pt_ind</span><span class="p">],</span> <span class="n">env</span><span class="o">.</span><span class="n">gradients</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">rot_mat</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">rotation_matrix</span><span class="p">(</span>
                        <span class="n">random</span><span class="p">()</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotation_range</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotation_axis</span>
                    <span class="p">)</span>
            <span class="c1"># for other points we get a random rotation</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">rot_mat</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">randomRot</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">rot_mat</span></div>


<div class="viewcode-block" id="Ingredient.randomize_rotation">
<a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.Ingredient.Ingredient.randomize_rotation">[docs]</a>
    <span class="k">def</span> <span class="nf">randomize_rotation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rotation</span><span class="p">,</span> <span class="n">env</span><span class="p">):</span>
        <span class="c1"># randomize rotation about axis</span>
        <span class="n">jitter_rotation</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">compartment_id</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">jitter_rotation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getAxisRotation</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_rotation_axis</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rotation_axis</span><span class="p">)</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
                    <span class="n">jitter_rotation</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
                    <span class="c1"># Graham Oct 16,2012 Turned on always rotate below as default.  If you want no rotation</span>
                    <span class="c1"># set use_rotation_axis = 1 and set rotation_axis = 0, 0, 0 for that ingredient</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_orient_bias</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">packing_mode</span> <span class="o">==</span> <span class="s2">&quot;gradient&quot;</span><span class="p">:</span>
                    <span class="n">jitter_rotation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getBiasedRotation</span><span class="p">(</span><span class="n">rotation</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># should we align to this rotation_axis ?</span>
                    <span class="n">jitter_rotation</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">rotation_matrix</span><span class="p">(</span>
                        <span class="n">random</span><span class="p">()</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotation_range</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotation_axis</span>
                    <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">env</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">jitter_rotation</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">randomRot</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotation_range</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">jitter_rotation</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">rotation</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">jitter_rotation</span> <span class="o">=</span> <span class="n">rotation</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">jitter_rotation</span></div>


<div class="viewcode-block" id="Ingredient.randomize_translation">
<a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.Ingredient.Ingredient.randomize_translation">[docs]</a>
    <span class="k">def</span> <span class="nf">randomize_translation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">env</span><span class="p">,</span> <span class="n">translation</span><span class="p">,</span> <span class="n">rotation</span><span class="p">):</span>
        <span class="c1"># jitter points location</span>
        <span class="n">spacing</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">gridSpacing</span>
        <span class="n">jitter</span> <span class="o">=</span> <span class="n">spacing</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="n">jitter_sq</span> <span class="o">=</span> <span class="n">jitter</span> <span class="o">*</span> <span class="n">jitter</span>
        <span class="n">jx</span><span class="p">,</span> <span class="n">jy</span><span class="p">,</span> <span class="n">jz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_jitter</span>
        <span class="n">tx</span><span class="p">,</span> <span class="n">ty</span><span class="p">,</span> <span class="n">tz</span> <span class="o">=</span> <span class="n">translation</span>
        <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">,</span> <span class="n">dz</span><span class="p">,</span> <span class="n">d2</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]</span>
        <span class="n">jitter_trans</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">jitter_sq</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="n">found</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="c1"># NOTE: making sure it hasn&#39;t picked a jitter point outside of the</span>
            <span class="c1"># sphere created by the half way point to the next grid points</span>
            <span class="c1"># TODO: Try seeing if this can be calculated more efficently using</span>
            <span class="c1"># polar coordinates</span>
            <span class="k">while</span> <span class="ow">not</span> <span class="n">found</span><span class="p">:</span>
                <span class="n">dx</span> <span class="o">=</span> <span class="n">jx</span> <span class="o">*</span> <span class="n">jitter</span> <span class="o">*</span> <span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
                <span class="n">dy</span> <span class="o">=</span> <span class="n">jy</span> <span class="o">*</span> <span class="n">jitter</span> <span class="o">*</span> <span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
                <span class="n">dz</span> <span class="o">=</span> <span class="n">jz</span> <span class="o">*</span> <span class="n">jitter</span> <span class="o">*</span> <span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
                <span class="n">d2</span> <span class="o">=</span> <span class="n">dx</span> <span class="o">*</span> <span class="n">dx</span> <span class="o">+</span> <span class="n">dy</span> <span class="o">*</span> <span class="n">dy</span> <span class="o">+</span> <span class="n">dz</span> <span class="o">*</span> <span class="n">dz</span>
                <span class="k">if</span> <span class="n">d2</span> <span class="o">&lt;</span> <span class="n">jitter_sq</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">compartment_id</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># jitter less among normal</span>
                        <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">,</span> <span class="n">dz</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">rotation</span><span class="p">,</span> <span class="p">(</span><span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">,</span> <span class="n">dz</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
                    <span class="n">jitter_trans</span> <span class="o">=</span> <span class="p">(</span><span class="n">tx</span> <span class="o">+</span> <span class="n">dx</span><span class="p">,</span> <span class="n">ty</span> <span class="o">+</span> <span class="n">dy</span><span class="p">,</span> <span class="n">tz</span> <span class="o">+</span> <span class="n">dz</span><span class="p">)</span>
                    <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">jitter_trans</span> <span class="o">=</span> <span class="n">translation</span>
        <span class="k">return</span> <span class="n">jitter_trans</span></div>


<div class="viewcode-block" id="Ingredient.update_display_rt">
<a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.Ingredient.Ingredient.update_display_rt">[docs]</a>
    <span class="k">def</span> <span class="nf">update_display_rt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">current_instance</span><span class="p">,</span> <span class="n">translation</span><span class="p">,</span> <span class="n">rotation</span><span class="p">):</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="n">rotation</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">mat</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">translation</span>
        <span class="n">autopack</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">move_object</span><span class="p">(</span><span class="n">current_instance</span><span class="p">,</span> <span class="n">translation</span><span class="p">,</span> <span class="n">mat</span><span class="p">)</span>

        <span class="n">autopack</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">update</span><span class="p">()</span></div>


<div class="viewcode-block" id="Ingredient.rigid_place">
<a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.Ingredient.Ingredient.rigid_place">[docs]</a>
    <span class="k">def</span> <span class="nf">rigid_place</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">env</span><span class="p">,</span>
        <span class="n">ptInd</span><span class="p">,</span>
        <span class="n">compartment</span><span class="p">,</span>
        <span class="n">target_grid_point_position</span><span class="p">,</span>
        <span class="n">rotation_matrix</span><span class="p">,</span>
        <span class="n">nbFreePoints</span><span class="p">,</span>
        <span class="n">distance</span><span class="p">,</span>
        <span class="n">dpad</span><span class="p">,</span>
        <span class="n">moving</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        drop the ingredient on grid point ptInd</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">afvi</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">afviewer</span>
        <span class="n">simulationTimes</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">simulationTimes</span>
        <span class="n">runTimeDisplay</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">runTimeDisplay</span>
        <span class="n">springOptions</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">springOptions</span>
        <span class="n">is_realtime</span> <span class="o">=</span> <span class="n">moving</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

        <span class="n">jtrans</span><span class="p">,</span> <span class="n">rotMatj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">oneJitter</span><span class="p">(</span>
            <span class="n">env</span><span class="p">,</span> <span class="n">target_grid_point_position</span><span class="p">,</span> <span class="n">rotation_matrix</span>
        <span class="p">)</span>

        <span class="c1"># here should go the simulation</span>
        <span class="c1"># 1- we build the ingredient if not already and place the ingredient at jtrans, rotMatj</span>
        <span class="n">moving</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">static</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">target</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">targetPoint</span> <span class="o">=</span> <span class="n">jtrans</span>
        <span class="c1">#        import c4d</span>
        <span class="c1"># c4d.documents.RunAnimation(c4d.documents.GetActiveDocument(), True)</span>

        <span class="k">if</span> <span class="n">is_realtime</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_display_rt</span><span class="p">(</span><span class="n">moving</span><span class="p">,</span> <span class="n">jtrans</span><span class="p">,</span> <span class="n">rotMatj</span><span class="p">)</span>
        <span class="c1"># 2- get the neighboring object from ptInd</span>
        <span class="n">near_by_ingredients</span><span class="p">,</span> <span class="n">placed_partners</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_partners</span><span class="p">(</span>
            <span class="n">env</span><span class="p">,</span> <span class="n">jtrans</span><span class="p">,</span> <span class="n">rotation_matrix</span><span class="p">,</span> <span class="n">compartment</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">elem</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">near_by_ingredients</span><span class="p">):</span>
            <span class="n">ing</span> <span class="o">=</span> <span class="n">elem</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="n">elem</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
            <span class="c1"># print &quot;neighbour&quot;,ing.name</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">ing</span><span class="p">,</span> <span class="s2">&quot;mesh_3d&quot;</span><span class="p">):</span>
                <span class="c1"># create an instance of mesh3d and place it</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">ing</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ing</span><span class="o">.</span><span class="n">mesh_3d</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">ipoly</span> <span class="o">=</span> <span class="n">afvi</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span>
                        <span class="n">name</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">radii</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">parent</span><span class="o">=</span><span class="n">afvi</span><span class="o">.</span><span class="n">staticMesh</span>
                    <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">afvi</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">setTranslation</span><span class="p">(</span><span class="n">ipoly</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">t</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ipoly</span> <span class="o">=</span> <span class="n">afvi</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">newInstance</span><span class="p">(</span>
                        <span class="n">name</span><span class="p">,</span>
                        <span class="n">ing</span><span class="o">.</span><span class="n">mesh_3d</span><span class="p">,</span>
                        <span class="n">matrice</span><span class="o">=</span><span class="n">r</span><span class="p">,</span>  <span class="c1"># .GetDown()</span>
                        <span class="n">location</span><span class="o">=</span><span class="n">t</span><span class="p">,</span>
                        <span class="n">parent</span><span class="o">=</span><span class="n">afvi</span><span class="o">.</span><span class="n">staticMesh</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="n">static</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ipoly</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">ing</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;Grow&quot;</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">ing</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
                <span class="n">ipoly</span> <span class="o">=</span> <span class="n">afvi</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">newInstance</span><span class="p">(</span>
                    <span class="n">name</span><span class="p">,</span> <span class="n">afvi</span><span class="o">.</span><span class="n">orgaToMasterGeom</span><span class="p">[</span><span class="n">ing</span><span class="p">],</span> <span class="n">parent</span><span class="o">=</span><span class="n">afvi</span><span class="o">.</span><span class="n">staticMesh</span>
                <span class="p">)</span>
                <span class="n">static</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ipoly</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">placed_partners</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">force_random</span><span class="p">:</span>
                <span class="n">targetPoint</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pick_partner_grid_index</span><span class="p">(</span>
                    <span class="n">near_by_ingredients</span><span class="p">,</span>
                    <span class="n">placed_partners</span><span class="p">,</span>
                    <span class="n">current_packing_position</span><span class="o">=</span><span class="n">jtrans</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">targetPoint</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">targetPoint</span> <span class="o">=</span> <span class="n">jtrans</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">targetPoint</span> <span class="o">=</span> <span class="n">jtrans</span>
        <span class="c1"># setup the target position</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">place_method</span> <span class="o">==</span> <span class="s2">&quot;spring&quot;</span><span class="p">:</span>
            <span class="n">afvi</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">setRigidBody</span><span class="p">(</span><span class="n">afvi</span><span class="o">.</span><span class="n">movingMesh</span><span class="p">,</span> <span class="o">**</span><span class="n">env</span><span class="o">.</span><span class="n">dynamicOptions</span><span class="p">[</span><span class="s2">&quot;spring&quot;</span><span class="p">])</span>
            <span class="c1"># target can be partner position?</span>
            <span class="n">target</span> <span class="o">=</span> <span class="n">afvi</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">getObject</span><span class="p">(</span><span class="s2">&quot;target&quot;</span> <span class="o">+</span> <span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">target</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">target</span> <span class="o">=</span> <span class="n">afvi</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="s2">&quot;target&quot;</span> <span class="o">+</span> <span class="n">name</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mf">5.0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">afvi</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">setTranslation</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">targetPoint</span><span class="p">)</span>
            <span class="n">afvi</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">addObjectToScene</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
            <span class="c1"># 3- we setup the spring (using the sphere position empty)</span>
            <span class="n">spring</span> <span class="o">=</span> <span class="n">afvi</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">getObject</span><span class="p">(</span><span class="s2">&quot;afspring&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">spring</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">spring</span> <span class="o">=</span> <span class="n">afvi</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">createSpring</span><span class="p">(</span>
                    <span class="s2">&quot;afspring&quot;</span><span class="p">,</span> <span class="n">targetA</span><span class="o">=</span><span class="n">moving</span><span class="p">,</span> <span class="n">tragetB</span><span class="o">=</span><span class="n">target</span><span class="p">,</span> <span class="o">**</span><span class="n">springOptions</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">afvi</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">updateSpring</span><span class="p">(</span>
                    <span class="n">spring</span><span class="p">,</span> <span class="n">targetA</span><span class="o">=</span><span class="n">moving</span><span class="p">,</span> <span class="n">tragetB</span><span class="o">=</span><span class="n">target</span><span class="p">,</span> <span class="o">**</span><span class="n">springOptions</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># before assigning should get outside thge object</span>
            <span class="n">afvi</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">setRigidBody</span><span class="p">(</span><span class="n">afvi</span><span class="o">.</span><span class="n">movingMesh</span><span class="p">,</span> <span class="o">**</span><span class="n">env</span><span class="o">.</span><span class="n">dynamicOptions</span><span class="p">[</span><span class="s2">&quot;moving&quot;</span><span class="p">])</span>
            <span class="n">afvi</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">setTranslation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">moving</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">targetPoint</span><span class="p">)</span>
        <span class="n">afvi</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">setRigidBody</span><span class="p">(</span><span class="n">afvi</span><span class="o">.</span><span class="n">staticMesh</span><span class="p">,</span> <span class="o">**</span><span class="n">env</span><span class="o">.</span><span class="n">dynamicOptions</span><span class="p">[</span><span class="s2">&quot;static&quot;</span><span class="p">])</span>
        <span class="c1"># 4- we run the simulation</span>
        <span class="c1"># c4d.documents.RunAnimation(c4d.documents.GetActiveDocument(), False,True)</span>
        <span class="c1"># if runTimeDisplay :</span>
        <span class="n">afvi</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
        <span class="c1">#        rTrans = afvi.vi.ToVec(afvi.vi.getTranslation(moving))</span>
        <span class="c1">#        rRot = afvi.vi.getMatRotation(moving)</span>

        <span class="c1"># print afvi.vi.ToVec(moving.GetAllPoints()[0])</span>
        <span class="c1"># afvi.vi.animationStart(duration = simulationTimes)</span>
        <span class="c1"># afvi.vi.update()</span>
        <span class="n">afvi</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">frameAdvanced</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="n">simulationTimes</span><span class="p">,</span> <span class="n">display</span><span class="o">=</span><span class="n">runTimeDisplay</span><span class="p">)</span>  <span class="c1"># ,</span>
        <span class="c1"># 5- we get the resuling transofrmation matrix and decompose -&gt;rTrans rRot</span>
        <span class="c1"># if runTimeDisplay :</span>
        <span class="n">afvi</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
        <span class="n">rTrans</span> <span class="o">=</span> <span class="n">afvi</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">ToVec</span><span class="p">(</span><span class="n">afvi</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">getTranslation</span><span class="p">(</span><span class="n">moving</span><span class="p">))</span>
        <span class="n">rRot</span> <span class="o">=</span> <span class="n">afvi</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">getMatRotation</span><span class="p">(</span><span class="n">moving</span><span class="p">)</span>
        <span class="c1">#        M=moving.GetMg()</span>
        <span class="c1"># print afvi.vi.ToVec(moving.GetAllPoints()[0])</span>

        <span class="c1"># 6- clean and delete everything except the spring</span>
        <span class="n">afvi</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">deleteObject</span><span class="p">(</span><span class="n">moving</span><span class="p">)</span>
        <span class="n">afvi</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">deleteObject</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">static</span><span class="p">:</span>
            <span class="n">afvi</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">deleteObject</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
        <span class="n">jtrans</span> <span class="o">=</span> <span class="n">rTrans</span><span class="p">[:]</span>
        <span class="n">rotMatj</span> <span class="o">=</span> <span class="n">rRot</span><span class="p">[:]</span>
        <span class="n">centT</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformPoints</span><span class="p">(</span><span class="n">jtrans</span><span class="p">,</span> <span class="n">rotMatj</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">insidePoints</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">newDistPoints</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">insidePoints</span><span class="p">,</span> <span class="n">newDistPoints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_new_distance_values</span><span class="p">(</span>
            <span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span>
            <span class="n">env</span><span class="o">.</span><span class="n">masterGridPositions</span><span class="p">,</span>
            <span class="n">dpad</span><span class="p">,</span>
            <span class="n">distance</span><span class="p">,</span>
            <span class="n">centT</span><span class="p">,</span>
            <span class="n">jtrans</span><span class="p">,</span>
            <span class="n">rotMatj</span><span class="p">,</span>
            <span class="n">dpad</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># save dropped ingredient</span>

        <span class="n">env</span><span class="o">.</span><span class="n">rTrans</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">jtrans</span><span class="p">)</span>
        <span class="n">env</span><span class="o">.</span><span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">jtrans</span><span class="p">,</span> <span class="n">rotMatj</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">ptInd</span><span class="p">])</span>
        <span class="n">env</span><span class="o">.</span><span class="n">rRot</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rotMatj</span><span class="p">)</span>
        <span class="n">env</span><span class="o">.</span><span class="n">rIngr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rRot</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rotMatj</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tTrans</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">jtrans</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;Success nbfp:</span><span class="si">%d</span><span class="s2"> </span><span class="si">%d</span><span class="s2">/</span><span class="si">%d</span><span class="s2"> dpad </span><span class="si">%.2f</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="n">nbFreePoints</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">counter</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">count</span><span class="p">,</span>
            <span class="n">dpad</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">success</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">success</span><span class="p">,</span> <span class="n">jtrans</span><span class="p">,</span> <span class="n">rotMatj</span><span class="p">,</span> <span class="n">insidePoints</span><span class="p">,</span> <span class="n">newDistPoints</span></div>


<div class="viewcode-block" id="Ingredient.merge_place_results">
<a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.Ingredient.Ingredient.merge_place_results">[docs]</a>
    <span class="k">def</span> <span class="nf">merge_place_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_results</span><span class="p">,</span> <span class="n">accum_results</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">new_results</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">pt</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">accum_results</span><span class="p">:</span>
                <span class="n">accum_results</span><span class="p">[</span><span class="n">pt</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_results</span><span class="p">[</span><span class="n">pt</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">new_results</span><span class="p">[</span><span class="n">pt</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">accum_results</span><span class="p">[</span><span class="n">pt</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># newly inside point</span>
                    <span class="n">accum_results</span><span class="p">[</span><span class="n">pt</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_results</span><span class="p">[</span><span class="n">pt</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">new_results</span><span class="p">[</span><span class="n">pt</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">accum_results</span><span class="p">[</span><span class="n">pt</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># was already inside, get closet distance</span>
                    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">new_results</span><span class="p">[</span><span class="n">pt</span><span class="p">])</span> <span class="o">&lt;</span> <span class="nb">abs</span><span class="p">(</span><span class="n">accum_results</span><span class="p">[</span><span class="n">pt</span><span class="p">]):</span>
                        <span class="n">accum_results</span><span class="p">[</span><span class="n">pt</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_results</span><span class="p">[</span><span class="n">pt</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">accum_results</span><span class="p">[</span><span class="n">pt</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">accum_results</span><span class="p">[</span><span class="n">pt</span><span class="p">],</span> <span class="n">new_results</span><span class="p">[</span><span class="n">pt</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">accum_results</span></div>


<div class="viewcode-block" id="Ingredient.get_all_positions_to_check">
<a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.Ingredient.Ingredient.get_all_positions_to_check">[docs]</a>
    <span class="k">def</span> <span class="nf">get_all_positions_to_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">packing_location</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Takes a starting position in the packing space, and returns all the points that</span>
<span class="sd">        need to be tested for a collision as an array.</span>

<span class="sd">            If the point isn&#39;t close to an edge, will return just the staring point.</span>
<span class="sd">            If the point is close to the side of the bounding box, will return an array of 2.</span>
<span class="sd">            If the point is close to an edge of the bb (which is a &quot;corner&quot; in 2D), will return an array of 3.</span>
<span class="sd">            If the point is close to a corner in 3D will return an array of 8.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">points_to_check</span> <span class="o">=</span> <span class="p">[</span><span class="n">packing_location</span><span class="p">]</span>
        <span class="c1"># periodicity check</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">packing_mode</span> <span class="o">!=</span> <span class="s2">&quot;graident&quot;</span><span class="p">:</span>
            <span class="n">periodic_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">getPositionPeridocity</span><span class="p">(</span>
                <span class="n">packing_location</span><span class="p">,</span>
                <span class="n">getNormedVectorOnes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_jitter</span><span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">encapsulating_radius</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">points_to_check</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">periodic_pos</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">points_to_check</span></div>


<div class="viewcode-block" id="Ingredient.jitter_place">
<a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.Ingredient.Ingredient.jitter_place">[docs]</a>
    <span class="k">def</span> <span class="nf">jitter_place</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">env</span><span class="p">,</span>
        <span class="n">targeted_master_grid_point</span><span class="p">,</span>
        <span class="n">rot_mat</span><span class="p">,</span>
        <span class="n">moving</span><span class="p">,</span>
        <span class="n">distance</span><span class="p">,</span>
        <span class="n">dpad</span><span class="p">,</span>
        <span class="n">pt_index</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if the given grid point is available for packing using the jitter collision detection</span>
<span class="sd">        method. Returns packing location and new grid point values if packing is successful.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">packing_location</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">is_realtime</span> <span class="o">=</span> <span class="n">moving</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="n">level</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">collisionLevel</span>
        <span class="k">for</span> <span class="n">attempt_number</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">jitter_attempts</span><span class="p">):</span>
            <span class="n">insidePoints</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">newDistPoints</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="p">(</span>
                <span class="n">packing_location</span><span class="p">,</span>
                <span class="n">packing_rotation</span><span class="p">,</span>
            <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_new_jitter_location_and_rotation</span><span class="p">(</span>
                <span class="n">env</span><span class="p">,</span> <span class="n">targeted_master_grid_point</span><span class="p">,</span> <span class="n">rot_mat</span>
            <span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Jitter attempt </span><span class="si">{</span><span class="n">attempt_number</span><span class="si">}</span><span class="s2"> for </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> at </span><span class="si">{</span><span class="n">packing_location</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="n">is_realtime</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">update_display_rt</span><span class="p">(</span><span class="n">moving</span><span class="p">,</span> <span class="n">packing_location</span><span class="p">,</span> <span class="n">packing_rotation</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">point_is_available</span><span class="p">(</span><span class="n">packing_location</span><span class="p">):</span>
                <span class="c1"># jittered out of container or too close to boundary</span>
                <span class="c1"># check next random jitter</span>
                <span class="k">continue</span>

            <span class="n">collision_results</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">points_to_check</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_all_positions_to_check</span><span class="p">(</span><span class="n">packing_location</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">points_to_check</span><span class="p">:</span>
                <span class="p">(</span>
                    <span class="n">collision</span><span class="p">,</span>
                    <span class="n">new_inside_points</span><span class="p">,</span>
                    <span class="n">new_dist_points</span><span class="p">,</span>
                <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">collision_jitter</span><span class="p">(</span>
                    <span class="n">pt</span><span class="p">,</span>
                    <span class="n">packing_rotation</span><span class="p">,</span>
                    <span class="n">level</span><span class="p">,</span>
                    <span class="n">env</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">masterGridPositions</span><span class="p">,</span>
                    <span class="n">distance</span><span class="p">,</span>
                    <span class="n">env</span><span class="p">,</span>
                    <span class="n">dpad</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">collision_results</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">collision</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">is_realtime</span><span class="p">:</span>
                    <span class="n">box</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">getObject</span><span class="p">(</span><span class="s2">&quot;collBox&quot;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">changeObjColorMat</span><span class="p">(</span>
                        <span class="n">box</span><span class="p">,</span>
                        <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="kc">True</span> <span class="ow">in</span> <span class="n">collision_results</span> <span class="k">else</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                    <span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">update_display_rt</span><span class="p">(</span><span class="n">moving</span><span class="p">,</span> <span class="n">pt</span><span class="p">,</span> <span class="n">packing_rotation</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">collision</span><span class="p">:</span>
                    <span class="c1"># found a collision, break this loop</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">insidePoints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">merge_place_results</span><span class="p">(</span>
                        <span class="n">new_inside_points</span><span class="p">,</span>
                        <span class="n">insidePoints</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">newDistPoints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">merge_place_results</span><span class="p">(</span>
                        <span class="n">new_dist_points</span><span class="p">,</span>
                        <span class="n">newDistPoints</span><span class="p">,</span>
                    <span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">collides_with_compartment</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">packing_location</span><span class="p">,</span> <span class="n">packing_rotation</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">is_realtime</span><span class="p">:</span>
                <span class="n">box</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">getObject</span><span class="p">(</span><span class="s2">&quot;collBox&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vi</span><span class="o">.</span><span class="n">changeObjColorMat</span><span class="p">(</span><span class="n">box</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">collision</span> <span class="k">else</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="kc">True</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">collision_results</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="s2">&quot;no collision, new points </span><span class="si">%d</span><span class="s2">, </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">insidePoints</span><span class="p">),</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">newDistPoints</span><span class="p">),</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">points_to_check</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">store_packed_object</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">packing_rotation</span><span class="p">,</span> <span class="n">pt_index</span><span class="p">)</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="kc">True</span><span class="p">,</span>
                    <span class="n">packing_location</span><span class="p">,</span>
                    <span class="n">packing_rotation</span><span class="p">,</span>
                    <span class="n">insidePoints</span><span class="p">,</span>
                    <span class="n">newDistPoints</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">packing_location</span><span class="p">,</span> <span class="n">packing_rotation</span><span class="p">,</span> <span class="p">{},</span> <span class="p">{}</span></div>


<div class="viewcode-block" id="Ingredient.lookForNeighbours">
<a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.Ingredient.Ingredient.lookForNeighbours">[docs]</a>
    <span class="k">def</span> <span class="nf">lookForNeighbours</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">env</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">rotMat</span><span class="p">,</span> <span class="n">organelle</span><span class="p">):</span>
        <span class="n">near_by_ingredients</span><span class="p">,</span> <span class="n">placed_partners</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_partners</span><span class="p">(</span>
            <span class="n">env</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">rotMat</span><span class="p">,</span> <span class="n">organelle</span>
        <span class="p">)</span>
        <span class="n">targetPoint</span> <span class="o">=</span> <span class="n">trans</span>
        <span class="n">found</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">placed_partners</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;partner found&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">force_random</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">jitterPos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">jitter_attempts</span><span class="p">):</span>  <span class="c1">#</span>
                    <span class="n">targetPoint</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pick_partner_grid_index</span><span class="p">(</span>
                        <span class="n">near_by_ingredients</span><span class="p">,</span>
                        <span class="n">placed_partners</span><span class="p">,</span>
                        <span class="n">current_packing_position</span><span class="o">=</span><span class="n">trans</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="n">targetPoint</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">break</span>
                <span class="k">if</span> <span class="n">targetPoint</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">found</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">return</span> <span class="n">targetPoint</span><span class="p">,</span> <span class="n">rotMat</span><span class="p">,</span> <span class="n">found</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># maybe get the ptid that can have it</span>
                    <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">compartment_id</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="c1"># surface</span>
                        <span class="n">d</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="n">organelle</span><span class="o">.</span><span class="n">OGsrfPtsBht</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">targetPoint</span><span class="p">)</span>
                        <span class="n">vx</span><span class="p">,</span> <span class="n">vy</span><span class="p">,</span> <span class="n">vz</span> <span class="o">=</span> <span class="n">v1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">principal_vector</span>
                        <span class="c1"># surfacePointsNormals problem here</span>
                        <span class="n">v2</span> <span class="o">=</span> <span class="n">organelle</span><span class="o">.</span><span class="n">ogsurfacePointsNormals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">rotMat</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rotVectToVect</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">),</span> <span class="s2">&quot;f&quot;</span><span class="p">)</span>
                        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;PROBLEM </span><span class="si">%s</span><span class="s2"> </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
                            <span class="n">rotMat</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
                    <span class="c1"># find a newpoint here?</span>
                    <span class="k">return</span> <span class="n">targetPoint</span><span class="p">,</span> <span class="n">rotMat</span><span class="p">,</span> <span class="n">found</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">targetPoint</span> <span class="o">=</span> <span class="n">trans</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;no partner found&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">targetPoint</span><span class="p">,</span> <span class="n">rotMat</span><span class="p">,</span> <span class="n">found</span></div>


<div class="viewcode-block" id="Ingredient.get_compartment">
<a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.Ingredient.Ingredient.get_compartment">[docs]</a>
    <span class="k">def</span> <span class="nf">get_compartment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">env</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">compartment_id</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">env</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">env</span><span class="o">.</span><span class="n">compartments</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">compartment_id</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span></div>


<div class="viewcode-block" id="Ingredient.close_partner_check">
<a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.Ingredient.Ingredient.close_partner_check">[docs]</a>
    <span class="k">def</span> <span class="nf">close_partner_check</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">env</span><span class="p">,</span> <span class="n">translation</span><span class="p">,</span> <span class="n">rotation</span><span class="p">,</span> <span class="n">compartment</span><span class="p">,</span> <span class="n">afvi</span><span class="p">,</span> <span class="n">moving</span>
    <span class="p">):</span>
        <span class="n">target_point</span><span class="p">,</span> <span class="n">rot_matrix</span><span class="p">,</span> <span class="n">found</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lookForNeighbours</span><span class="p">(</span>
            <span class="n">env</span><span class="p">,</span>
            <span class="n">translation</span><span class="p">,</span>
            <span class="n">rotation</span><span class="p">,</span>
            <span class="n">compartment</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">found</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">counter</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reject</span><span class="p">()</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

        <span class="c1"># if partner:pickNewPoit like in fill3</span>
        <span class="k">if</span> <span class="n">moving</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_display_rt</span><span class="p">(</span><span class="n">moving</span><span class="p">,</span> <span class="n">target_point</span><span class="p">,</span> <span class="n">rot_matrix</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">target_point</span><span class="p">,</span> <span class="n">rot_matrix</span></div>


<div class="viewcode-block" id="Ingredient.handle_real_time_visualization">
<a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.Ingredient.Ingredient.handle_real_time_visualization">[docs]</a>
    <span class="k">def</span> <span class="nf">handle_real_time_visualization</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">helper</span><span class="p">,</span> <span class="n">ptInd</span><span class="p">,</span> <span class="n">target_point</span><span class="p">,</span> <span class="n">rot_mat</span><span class="p">):</span>
        <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="n">instance_id</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">ptInd</span><span class="si">}</span><span class="s2">&quot;</span>  <span class="c1"># copy of the ingredient being packed</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="n">getObject</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>  <span class="c1"># parent object of all the instances</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">helper</span><span class="o">.</span><span class="n">add_object_to_scene</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">instance_id</span><span class="p">,</span> <span class="n">target_point</span><span class="p">,</span> <span class="n">rot_mat</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">helper</span><span class="o">.</span><span class="n">add_new_instance_and_update_time</span><span class="p">(</span>
                <span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">instance_id</span><span class="p">,</span> <span class="n">target_point</span><span class="p">,</span> <span class="n">rot_mat</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">instance_id</span></div>


<div class="viewcode-block" id="Ingredient.spheres_SST_place">
<a class="viewcode-back" href="../../../../cellpack.autopack.ingredient.html#cellpack.autopack.ingredient.Ingredient.Ingredient.spheres_SST_place">[docs]</a>
    <span class="k">def</span> <span class="nf">spheres_SST_place</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">env</span><span class="p">,</span>
        <span class="n">compartment</span><span class="p">,</span>
        <span class="n">ptInd</span><span class="p">,</span>
        <span class="n">target_grid_point_position</span><span class="p">,</span>
        <span class="n">rotation_matrix</span><span class="p">,</span>
        <span class="n">moving</span><span class="p">,</span>
        <span class="n">distance</span><span class="p">,</span>
        <span class="n">dpad</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        drop the ingredient on grid point ptInd</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">is_realtime</span> <span class="o">=</span> <span class="n">moving</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

        <span class="n">targetPoint</span> <span class="o">=</span> <span class="n">target_grid_point_position</span>

        <span class="k">if</span> <span class="n">is_realtime</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_display_rt</span><span class="p">(</span><span class="n">moving</span><span class="p">,</span> <span class="n">targetPoint</span><span class="p">,</span> <span class="n">rotation_matrix</span><span class="p">)</span>

        <span class="c1"># do we get the list of neighbours first &gt; and give a different trans...closer to the partner</span>
        <span class="c1"># we should look up for an available ptID around the picked partner if any</span>
        <span class="c1"># getListCloseIngredient</span>
        <span class="c1"># should se a distance_of_influence ? or self.env.largestProteinSize+self.encapsulating_radius*2.0</span>
        <span class="c1"># or the grid diagonal</span>
        <span class="c1"># we need to change here in case tilling, the pos,rot ade deduced fromte tilling.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">packing_mode</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">:]</span> <span class="o">==</span> <span class="s2">&quot;tile&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tilling</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">setTilling</span><span class="p">(</span><span class="n">compartment</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">counter</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># pick the next Hexa pos/rot.</span>
                <span class="n">t</span><span class="p">,</span> <span class="n">collision_results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tilling</span><span class="o">.</span><span class="n">getNextHexaPosRot</span><span class="p">()</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
                    <span class="n">rotation_matrix</span> <span class="o">=</span> <span class="n">collision_results</span>
                    <span class="n">targetPoint</span> <span class="o">=</span> <span class="n">t</span>
                    <span class="k">if</span> <span class="n">is_realtime</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">update_display_rt</span><span class="p">(</span><span class="n">moving</span><span class="p">,</span> <span class="n">targetPoint</span><span class="p">,</span> <span class="n">rotation_matrix</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">{},</span> <span class="p">{}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tilling</span><span class="o">.</span><span class="n">init_seed</span><span class="p">(</span><span class="n">env</span><span class="o">.</span><span class="n">seed_used</span><span class="p">)</span>
        <span class="c1"># we may increase the jitter, or pick from xyz-&gt;Id free for its radius</span>
        <span class="c1"># create the rb only once and not at ever jitter</span>
        <span class="c1"># rbnode = histoVol.callFunction(self.env.addRB,(self, jtrans, rotMat,),{&quot;rtype&quot;:self.type},)</span>
        <span class="c1"># jitter loop</span>
        <span class="c1"># level = self.collisionLevel</span>
        <span class="k">for</span> <span class="n">attempt_number</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">jitter_attempts</span><span class="p">):</span>
            <span class="n">insidePoints</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">newDistPoints</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">env</span><span class="o">.</span><span class="n">totnbJitter</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="p">(</span>
                <span class="n">packing_location</span><span class="p">,</span>
                <span class="n">packing_rotation</span><span class="p">,</span>
            <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_new_jitter_location_and_rotation</span><span class="p">(</span>
                <span class="n">env</span><span class="p">,</span>
                <span class="n">targetPoint</span><span class="p">,</span>
                <span class="n">rotation_matrix</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">is_realtime</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">update_display_rt</span><span class="p">(</span><span class="n">moving</span><span class="p">,</span> <span class="n">packing_location</span><span class="p">,</span> <span class="n">packing_rotation</span><span class="p">)</span>

            <span class="n">collision_results</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">rbnode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_rb_model</span><span class="p">()</span>
            <span class="n">pts_to_check</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_all_positions_to_check</span><span class="p">(</span><span class="n">packing_location</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">pts_to_check</span><span class="p">:</span>
                <span class="n">collision</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">np_check_collision</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">packing_rotation</span><span class="p">)</span>
                <span class="n">collision_results</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">collision</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">is_realtime</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">update_display_rt</span><span class="p">(</span><span class="n">moving</span><span class="p">,</span> <span class="n">packing_location</span><span class="p">,</span> <span class="n">packing_rotation</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">collision</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">point_is_available</span><span class="p">(</span><span class="n">packing_location</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="kc">True</span> <span class="ow">in</span> <span class="n">collision_results</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># need to check compartment too</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;no collision&quot;</span><span class="p">)</span>
            <span class="c1"># if self.compareCompartment:</span>
            <span class="c1">#     collision = self.compareCompartmentPrimitive(</span>
            <span class="c1">#         level,</span>
            <span class="c1">#         packing_location,</span>
            <span class="c1">#         packing_rotation,</span>
            <span class="c1">#         gridPointsCoords,</span>
            <span class="c1">#         distance,</span>
            <span class="c1">#     )</span>
            <span class="c1">#     collision_results.extend([collision])</span>
            <span class="k">if</span> <span class="kc">True</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">collision_results</span><span class="p">:</span>
                <span class="n">env</span><span class="o">.</span><span class="n">static</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rbnode</span><span class="p">)</span>
                <span class="n">env</span><span class="o">.</span><span class="n">moving</span> <span class="o">=</span> <span class="kc">None</span>

                <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">pts_to_check</span><span class="p">:</span>
                    <span class="n">new_inside_pts</span><span class="p">,</span> <span class="n">new_dist_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pack_at_grid_pt_location</span><span class="p">(</span>
                        <span class="n">env</span><span class="p">,</span>
                        <span class="n">pt</span><span class="p">,</span>
                        <span class="n">packing_rotation</span><span class="p">,</span>
                        <span class="n">dpad</span><span class="p">,</span>
                        <span class="n">distance</span><span class="p">,</span>
                        <span class="n">insidePoints</span><span class="p">,</span>
                        <span class="n">newDistPoints</span><span class="p">,</span>
                        <span class="n">ptInd</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">insidePoints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">merge_place_results</span><span class="p">(</span>
                        <span class="n">new_inside_pts</span><span class="p">,</span> <span class="n">insidePoints</span>
                    <span class="p">)</span>
                    <span class="n">newDistPoints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">merge_place_results</span><span class="p">(</span>
                        <span class="n">new_dist_points</span><span class="p">,</span> <span class="n">newDistPoints</span>
                    <span class="p">)</span>

                <span class="n">success</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">success</span><span class="p">,</span>
                    <span class="n">packing_location</span><span class="p">,</span>
                    <span class="n">packing_rotation</span><span class="p">,</span>
                    <span class="n">insidePoints</span><span class="p">,</span>
                    <span class="n">newDistPoints</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="n">success</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">success</span><span class="p">,</span> <span class="n">packing_location</span><span class="p">,</span> <span class="n">packing_rotation</span><span class="p">,</span> <span class="n">insidePoints</span><span class="p">,</span> <span class="n">newDistPoints</span></div>
</div>

</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">cellPack 1.0.7 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../../cellpack.html" >cellpack</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="../../autopack.html" >cellpack.autopack</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">cellpack.autopack.ingredient.Ingredient</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2021, Megan Riel-Mehan.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    </div>
  </body>
</html>